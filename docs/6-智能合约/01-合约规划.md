# Eidos 智能合约规划

> **当前模式**: 模拟验证 (Mock Mode)

---

## 一、当前阶段：模拟验证模式

### 1.1 设计原则

在合约未部署阶段，后端采用**模拟验证模式**：
- 前端正常使用 EIP-712 签名流程
- 后端验证签名恢复的地址与请求者一致
- 不依赖链上合约，可独立开发测试

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          模拟验证模式 (Mock Mode)                            │
│                                                                              │
│  前端                          后端                          链上           │
│  ─────                         ─────                        ─────           │
│                                                                              │
│  1. 构造 EIP-712 TypedData                                                  │
│  2. 调用 wallet.signTypedData()                                             │
│  3. 发送 { order, signature }                                               │
│         ────────────────────────▶                                           │
│                                                                              │
│                               4. 解析 TypedData                              │
│                               5. ECDSA.recover(digest, sig)                 │
│                               6. 验证 signer == order.maker                 │
│                               7. 写入数据库，返回成功                        │
│         ◀────────────────────────                                           │
│                                                                              │
│                               (链上合约暂不接入)           ───────────────  │
│                                                             │ TODO: 接入合约 │  │
│                                                             ───────────────  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 后端验证代码

```go
package crypto

import (
    "errors"
    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/crypto"
    "github.com/ethereum/go-ethereum/signer/core/apitypes"
)

var (
    ErrInvalidSignature = errors.New("invalid signature")
    ErrSignerMismatch   = errors.New("signer does not match maker")
)

// EIP712Domain 配置 (与前端保持一致)
var DomainConfig = apitypes.TypedDataDomain{
    Name:              "EidosExchange",
    Version:           "1",
    ChainId:           nil, // 运行时从配置读取
    VerifyingContract: common.Address{}, // Mock 模式可为空
}

// VerifyOrderSignature 验证订单签名 (模拟模式)
func VerifyOrderSignature(typedData *apitypes.TypedData, signature []byte, expectedSigner common.Address) error {
    // 1. 计算 EIP-712 digest
    domainSeparator, err := typedData.HashStruct("EIP712Domain", typedData.Domain.Map())
    if err != nil {
        return err
    }

    messageHash, err := typedData.HashStruct(typedData.PrimaryType, typedData.Message)
    if err != nil {
        return err
    }

    digest := crypto.Keccak256Hash(
        []byte("\x19\x01"),
        domainSeparator.Bytes(),
        messageHash.Bytes(),
    )

    // 2. 恢复签名者地址
    if len(signature) != 65 {
        return ErrInvalidSignature
    }

    // 调整 V 值 (以太坊签名格式)
    if signature[64] >= 27 {
        signature[64] -= 27
    }

    pubKey, err := crypto.SigToPub(digest.Bytes(), signature)
    if err != nil {
        return ErrInvalidSignature
    }

    signer := crypto.PubkeyToAddress(*pubKey)

    // 3. 验证签名者
    if signer != expectedSigner {
        return ErrSignerMismatch
    }

    return nil
}
```

### 1.3 环境配置

```yaml
# config/eidos-trading.yaml

crypto:
  mode: mock                    # mock | contract

  eip712_domain:
    name: "EidosExchange"
    version: "1"
    chain_id: 42161             # Arbitrum One
    verifying_contract: "0x0000000000000000000000000000000000000000"  # Mock 模式用零地址

  # 合约接入后启用
  # contract:
  #   address: "0x..."
  #   rpc_url: "https://arb1.arbitrum.io/rpc"

# 重要: Mock 模式必须使用零地址，保证与前端 EIP-712 domain hash 一致
# 详见: 3-开发规范/00-协议总表.md
```

---

## 二、合约实现规划

### 2.1 合约功能清单

| 功能 | 优先级 | 说明 |
|------|--------|------|
| 充值 (Deposit) | P0 | 用户将 ERC20 存入合约 |
| 提现 (Withdraw) | P0 | 用户签名提现，合约验证后转账 |
| 批量结算 (Settle) | P0 | 系统批量更新余额 (成交结果) |
| 暂停/恢复 | P1 | 紧急情况暂停合约 |
| 管理员权限 | P1 | 多签/时间锁 |
| 升级机制 | P2 | 可升级代理模式 |

### 2.2 合约接口设计 (草案)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol";

interface IEidosExchange {
    // ============================================
    // Events
    // ============================================
    event Deposit(address indexed user, address indexed token, uint256 amount);
    event Withdraw(address indexed user, address indexed token, uint256 amount, uint256 nonce);
    event Settled(bytes32 indexed batchId, uint256 tradeCount);
    event Paused(address indexed by);
    event Unpaused(address indexed by);

    // ============================================
    // User Functions
    // ============================================

    /// @notice 充值 ERC20 到交易所
    function deposit(address token, uint256 amount) external;

    /// @notice 使用 EIP-712 签名提现
    function withdraw(
        address token,
        uint256 amount,
        uint256 nonce,
        uint256 expiration,
        bytes calldata signature
    ) external;

    /// @notice 查询用户余额
    function balanceOf(address user, address token) external view returns (uint256);

    // ============================================
    // Admin Functions (需要权限)
    // ============================================

    /// @notice 批量结算成交
    function settle(
        address[] calldata makers,
        address[] calldata takers,
        address[] calldata baseTokens,
        address[] calldata quoteTokens,
        uint256[] calldata baseAmounts,
        uint256[] calldata quoteAmounts,
        bytes32 batchId
    ) external;

    /// @notice 暂停合约
    function pause() external;

    /// @notice 恢复合约
    function unpause() external;

    /// @notice 添加支持的代币
    function addSupportedToken(address token) external;

    /// @notice 移除支持的代币
    function removeSupportedToken(address token) external;
}
```

### 2.3 TypeHash 定义

```solidity
// 提现 TypeHash
bytes32 public constant WITHDRAW_TYPEHASH = keccak256(
    "Withdraw(address user,address token,uint256 amount,uint256 nonce,uint256 expiration)"
);

// 订单 TypeHash (链下撮合，链上验证时可选)
bytes32 public constant ORDER_TYPEHASH = keccak256(
    "Order(bytes32 orderId,string market,uint8 side,uint256 price,uint256 size,uint256 nonce,uint256 expiration)"
);
```

### 2.4 安全考虑

| 风险 | 缓解措施 |
|------|----------|
| 重入攻击 | 使用 ReentrancyGuard，遵循 CEI 模式 |
| 签名重放 | nonce 机制 + expiration |
| 权限泄露 | 多签钱包 + 时间锁 |
| 合约升级 | UUPS 代理模式 + 48h 时间锁 |
| 资金安全 | 提现限额 + 大额延迟 |

---

## 三、接入计划

### 3.1 里程碑

| 阶段 | 时间 | 内容 |
|------|------|------|
| 当前 | 当前 | 模拟验证模式，专注后端开发 |
| 合约开发 | 后续 | 编写合约代码 + 单元测试 |
| 审计准备 | 后续 | 代码冻结，准备审计材料 |
| 安全审计 | 后续 | 外部审计 |
| 测试网部署 | 后续 | Arbitrum Sepolia 测试 |
| 主网部署 | 后续 | Arbitrum One 正式上线 |

### 3.2 切换步骤

```
1. 部署合约到测试网
2. 修改配置 crypto.mode = contract
3. 配置合约地址和 RPC
4. 重启 eidos-trading, eidos-chain
5. 端到端测试
6. 主网部署
```

### 3.3 回滚方案

如果合约出现问题：
1. 暂停合约 (pause)
2. 后端切回 mock 模式
3. 用户资金安全，等待修复

---

## 四、TODO 清单

- [ ] 完成合约代码编写
- [ ] 编写合约单元测试 (Foundry)
- [ ] 编写集成测试
- [ ] 准备审计材料
- [ ] 选择审计公司
- [ ] 测试网部署脚本
- [ ] 主网部署脚本
- [ ] 监控告警配置
- [ ] 应急预案文档

---

## 五、参考资料

- [EIP-712: Typed Structured Data Hashing and Signing](https://eips.ethereum.org/EIPS/eip-712)
- [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts)
- [Foundry Book](https://book.getfoundry.sh/)
- [dYdX V4 Contracts](https://github.com/dydxprotocol/v4-chain)
