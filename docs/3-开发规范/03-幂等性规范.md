# Eidos 幂等性规范

> **适用范围**: 所有后端服务

---

## 一、概述

### 1.1 什么是幂等性？

幂等性是指同一操作执行多次，结果与执行一次相同。在分布式系统中，由于网络抖动、重试机制、消息重复等原因，同一请求可能被处理多次，必须保证系统状态一致。

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           幂等性必要场景                                      │
│                                                                              │
│  1. 网络超时重试                                                             │
│     Client ──────▶ Server (处理成功，响应丢失)                              │
│     Client ──────▶ Server (重试，如何保证不重复？)                          │
│                                                                              │
│  2. Kafka 消息重复                                                           │
│     Producer ──▶ Kafka ──▶ Consumer (消费成功，offset 提交失败)             │
│     Kafka ──▶ Consumer (重新消费同一消息)                                   │
│                                                                              │
│  3. 分布式事务补偿                                                           │
│     Service A ──▶ Service B (B 成功，A 不知道)                              │
│     Service A ──▶ Service B (重试调用)                                      │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 幂等键设计原则

| 原则 | 说明 |
|------|------|
| **唯一性** | 同一业务操作的幂等键全局唯一 |
| **确定性** | 相同输入产生相同的幂等键 |
| **不可变** | 幂等键一旦生成不可修改 |
| **可追溯** | 幂等键应包含业务语义，便于排查 |

---

## 二、各环节幂等键定义

### 2.1 幂等键总表

| 环节 | 幂等键 | 存储位置 | TTL | 说明 |
|------|--------|---------|-----|------|
| 订单创建 | `order:{wallet}:{nonce}` | Redis + DB | 7d | 防止 nonce 重用 |
| 订单取消 | `cancel:{order_id}` | Redis | 1h | 防止重复取消 |
| 撮合成交 | `trade:{maker_order_id}:{taker_order_id}:{seq}` | Kafka offset | - | Kafka 保证 |
| 余额冻结 | `freeze:{order_id}` | DB 事务 | - | 数据库唯一约束 |
| 余额扣款 | `debit:{trade_id}` | DB 事务 | - | 数据库唯一约束 |
| 链上结算 | `settle:{batch_id}` | DB + Chain | ∞ | 链上 nonce |
| 充值入账 | `deposit:{tx_hash}:{log_index}` | DB | ∞ | 链上事件唯一 |
| 提现处理 | `withdraw:{wallet}:{nonce}` | DB + Chain | ∞ | 用户签名 nonce |

### 2.2 交易服务 (eidos-trading)

```go
// 订单创建幂等键
type OrderIdempotencyKey struct {
    Wallet string
    Nonce  uint64
}

func (k *OrderIdempotencyKey) String() string {
    return fmt.Sprintf("order:%s:%d", k.Wallet, k.Nonce)
}

// 检查 nonce 是否已使用
func (s *TradeService) CheckNonce(ctx context.Context, wallet string, nonce uint64) error {
    key := fmt.Sprintf("nonce:%s:%d", wallet, nonce)

    // 1. 先查 Redis (快速路径)
    exists, err := s.redis.Exists(ctx, key).Result()
    if err != nil {
        return err
    }
    if exists > 0 {
        return ErrNonceAlreadyUsed
    }

    // 2. 再查数据库 (确保持久化的也检查到)
    used, err := s.repo.IsNonceUsed(ctx, wallet, nonce)
    if err != nil {
        return err
    }
    if used {
        // 回填到 Redis
        s.redis.Set(ctx, key, "1", 7*24*time.Hour)
        return ErrNonceAlreadyUsed
    }

    return nil
}

// 标记 nonce 已使用 (原子操作)
func (s *TradeService) MarkNonceUsed(ctx context.Context, wallet string, nonce uint64) error {
    key := fmt.Sprintf("nonce:%s:%d", wallet, nonce)

    // SETNX 保证原子性
    set, err := s.redis.SetNX(ctx, key, "1", 7*24*time.Hour).Result()
    if err != nil {
        return err
    }
    if !set {
        return ErrNonceAlreadyUsed
    }

    // 异步写入数据库 (持久化)
    go s.repo.SaveNonce(context.Background(), wallet, nonce)

    return nil
}
```

**数据库表设计:**

```sql
CREATE TABLE used_nonces (
    id          BIGSERIAL PRIMARY KEY,
    wallet      VARCHAR(42) NOT NULL,
    nonce       BIGINT NOT NULL,
    order_id    VARCHAR(64),
    created_at  BIGINT NOT NULL,

    CONSTRAINT uk_wallet_nonce UNIQUE (wallet, nonce)
);

CREATE INDEX idx_nonces_wallet ON used_nonces (wallet);
CREATE INDEX idx_nonces_created ON used_nonces (created_at);
```

### 2.3 撮合引擎 (eidos-matching)

撮合引擎的幂等性主要依赖 Kafka 的 exactly-once 语义：

```go
// Kafka 消费者配置
config := sarama.NewConfig()
config.Consumer.Offsets.AutoCommit.Enable = false  // 手动提交 offset
config.Consumer.IsolationLevel = sarama.ReadCommitted  // 读已提交

// 消费处理
func (e *Engine) ConsumeOrder(msg *sarama.ConsumerMessage) error {
    order, err := e.parseOrder(msg.Value)
    if err != nil {
        return err // 解析失败，不提交 offset，会重试
    }

    // 1. 检查订单是否已处理 (基于 order_id)
    if e.orderBook.HasOrder(order.OrderID) {
        // 已存在，直接提交 offset，跳过处理
        return nil
    }

    // 2. 执行撮合
    trades := e.Match(order)

    // 3. 发送成交结果到 Kafka
    for _, trade := range trades {
        if err := e.producer.SendTrade(trade); err != nil {
            return err // 发送失败，不提交 offset，会重试
        }
    }

    // 4. 所有操作成功，提交 offset
    return nil
}
```

**成交记录幂等键:**

```go
// 成交 ID 生成规则
// trade_id = hash(maker_order_id + taker_order_id + sequence)
func GenerateTradeID(makerOrderID, takerOrderID string, seq uint64) string {
    data := fmt.Sprintf("%s:%s:%d", makerOrderID, takerOrderID, seq)
    hash := sha256.Sum256([]byte(data))
    return hex.EncodeToString(hash[:16]) // 取前 16 字节
}
```

### 2.4 清算模块 (eidos-trading)

```go
// 余额操作使用数据库事务 + 唯一约束保证幂等

func (s *ClearingService) ProcessTrade(ctx context.Context, trade *Trade) error {
    return s.db.Transaction(func(tx *gorm.DB) error {
        // 1. 检查成交是否已处理
        var count int64
        tx.Model(&BalanceLog{}).Where("trade_id = ?", trade.TradeID).Count(&count)
        if count > 0 {
            return nil // 已处理，跳过
        }

        // 2. 更新余额
        // Maker: +base, -quote
        if err := s.updateBalance(tx, trade.Maker, trade.BaseToken, trade.BaseAmount); err != nil {
            return err
        }
        if err := s.updateBalance(tx, trade.Maker, trade.QuoteToken, -trade.QuoteAmount); err != nil {
            return err
        }

        // Taker: -base, +quote
        if err := s.updateBalance(tx, trade.Taker, trade.BaseToken, -trade.BaseAmount); err != nil {
            return err
        }
        if err := s.updateBalance(tx, trade.Taker, trade.QuoteToken, trade.QuoteAmount); err != nil {
            return err
        }

        // 3. 写入余额日志 (带唯一约束)
        log := &BalanceLog{
            TradeID:   trade.TradeID,
            // ...
        }
        if err := tx.Create(log).Error; err != nil {
            if isDuplicateKeyError(err) {
                return nil // 重复插入，视为成功
            }
            return err
        }

        return nil
    })
}
```

**余额日志表:**

```sql
CREATE TABLE balance_logs (
    id              BIGSERIAL PRIMARY KEY,
    trade_id        VARCHAR(64),                  -- 成交幂等键
    order_id        VARCHAR(64),                  -- 订单关联
    wallet          VARCHAR(42) NOT NULL,
    token           VARCHAR(20) NOT NULL,
    amount          DECIMAL(36,18) NOT NULL,      -- 正数增加，负数减少
    balance_before  DECIMAL(36,18) NOT NULL,
    balance_after   DECIMAL(36,18) NOT NULL,
    type            SMALLINT NOT NULL,            -- 1:成交 2:冻结 3:解冻 4:充值 5:提现
    created_at      BIGINT NOT NULL,

    CONSTRAINT uk_trade_wallet_token UNIQUE (trade_id, wallet, token)
);
```

### 2.5 结算模块 (eidos-chain)

```go
// 批次结算幂等键
type SettlementBatch struct {
    BatchID    string    // UUID，全局唯一
    Trades     []Trade
    Status     int       // 0:pending 1:submitted 2:confirmed 3:failed
    TxHash     string
    CreatedAt  int64
}

func (s *SettlementService) SettleBatch(ctx context.Context, batch *SettlementBatch) error {
    // 1. 检查批次状态
    existing, err := s.repo.GetBatch(ctx, batch.BatchID)
    if err != nil && !errors.Is(err, ErrNotFound) {
        return err
    }

    if existing != nil {
        switch existing.Status {
        case StatusConfirmed:
            return nil // 已完成
        case StatusSubmitted:
            // 检查链上状态
            return s.checkOnChainStatus(ctx, existing)
        case StatusFailed:
            // 可以重试
        }
    }

    // 2. 构造链上交易
    tx, err := s.buildSettleTx(batch)
    if err != nil {
        return err
    }

    // 3. 提交到链上
    txHash, err := s.submitTx(ctx, tx)
    if err != nil {
        batch.Status = StatusFailed
        s.repo.UpdateBatch(ctx, batch)
        return err
    }

    // 4. 更新状态
    batch.Status = StatusSubmitted
    batch.TxHash = txHash
    return s.repo.UpdateBatch(ctx, batch)
}
```

### 2.6 索引模块 (eidos-chain)

```go
// 充值事件幂等键: tx_hash + log_index
type DepositEvent struct {
    TxHash   string
    LogIndex uint
    User     string
    Token    string
    Amount   *big.Int
}

func (i *Indexer) ProcessDeposit(ctx context.Context, event *DepositEvent) error {
    key := fmt.Sprintf("deposit:%s:%d", event.TxHash, event.LogIndex)

    // 1. 检查是否已处理
    processed, err := i.repo.IsEventProcessed(ctx, key)
    if err != nil {
        return err
    }
    if processed {
        return nil
    }

    // 2. 调用账户服务入账
    if err := i.accountClient.Credit(ctx, &CreditRequest{
        Wallet:      event.User,
        Token:       event.Token,
        Amount:      event.Amount.String(),
        IdempotentKey: key,
    }); err != nil {
        return err
    }

    // 3. 标记已处理
    return i.repo.MarkEventProcessed(ctx, key)
}
```

---

## 三、Kafka 消息幂等性

### 3.1 生产者幂等配置

```go
config := sarama.NewConfig()
config.Producer.Idempotent = true
config.Producer.RequiredAcks = sarama.WaitForAll
config.Producer.Retry.Max = 3
config.Net.MaxOpenRequests = 1  // 幂等生产者要求
```

### 3.2 消费者幂等处理

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Kafka 消费幂等处理流程                                │
│                                                                              │
│  1. 消费消息                                                                 │
│     │                                                                        │
│     ▼                                                                        │
│  2. 提取幂等键 (从消息体或 header)                                          │
│     │                                                                        │
│     ▼                                                                        │
│  3. 检查是否已处理 ─────────────────┐                                       │
│     │                               │                                        │
│     │ 未处理                        │ 已处理                                │
│     ▼                               ▼                                        │
│  4. 处理业务逻辑                 直接提交 offset                            │
│     │                                                                        │
│     ▼                                                                        │
│  5. 标记已处理                                                               │
│     │                                                                        │
│     ▼                                                                        │
│  6. 提交 offset                                                              │
│                                                                              │
│  注意: 步骤 4-6 应尽量在同一事务中完成                                      │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 Topic 幂等键规范

| Topic | 幂等键字段 | 说明 |
|-------|-----------|------|
| orders | order_id | 订单唯一 ID |
| cancel-requests | order_id | 要取消的订单 ID |
| trade-results | trade_id | 成交唯一 ID |
| balance-updates | trade_id / order_id | 关联业务 ID |
| orderbook-updates | sequence | 序列号 |
| settlements | batch_id | 结算批次 ID |

---

## 四、去重存储设计

### 4.1 Redis 去重

```go
// 通用幂等检查器
type IdempotencyChecker struct {
    redis *redis.Client
    ttl   time.Duration
}

// CheckAndMark 检查并标记 (原子操作)
func (c *IdempotencyChecker) CheckAndMark(ctx context.Context, key string) (bool, error) {
    // SETNX + EXPIRE 原子操作
    script := `
        if redis.call('EXISTS', KEYS[1]) == 1 then
            return 0
        end
        redis.call('SET', KEYS[1], ARGV[1], 'EX', ARGV[2])
        return 1
    `
    result, err := c.redis.Eval(ctx, script, []string{key}, "1", int(c.ttl.Seconds())).Int()
    if err != nil {
        return false, err
    }
    return result == 1, nil
}

// 使用示例
func (s *Service) ProcessWithIdempotency(ctx context.Context, req *Request) error {
    key := fmt.Sprintf("idempotent:%s:%s", req.Type, req.ID)

    isNew, err := s.checker.CheckAndMark(ctx, key)
    if err != nil {
        return err
    }
    if !isNew {
        // 已处理过，返回之前的结果或直接成功
        return s.getExistingResult(ctx, req.ID)
    }

    // 首次处理
    return s.doProcess(ctx, req)
}
```

### 4.2 数据库去重

```sql
-- 幂等记录表
CREATE TABLE idempotency_records (
    id              BIGSERIAL PRIMARY KEY,
    idempotency_key VARCHAR(128) NOT NULL UNIQUE,
    result          JSONB,                        -- 存储处理结果
    created_at      BIGINT NOT NULL,
    expires_at      BIGINT                        -- 可选过期时间
);

CREATE INDEX idx_idempotency_expires ON idempotency_records (expires_at);

-- 定期清理过期记录
DELETE FROM idempotency_records WHERE expires_at < EXTRACT(EPOCH FROM NOW()) * 1000;
```

---

## 五、乱序与重复处理策略

### 5.1 消息乱序处理

```go
// 使用序列号处理乱序
type SequencedMessage struct {
    Sequence  uint64
    Data      []byte
    Timestamp int64
}

type SequenceTracker struct {
    lastSeq sync.Map  // key -> last processed sequence
}

func (t *SequenceTracker) ShouldProcess(key string, seq uint64) bool {
    last, ok := t.lastSeq.Load(key)
    if !ok {
        return true
    }
    return seq > last.(uint64)
}

func (t *SequenceTracker) UpdateSequence(key string, seq uint64) {
    t.lastSeq.Store(key, seq)
}
```

### 5.2 重复检测窗口

```go
// 滑动窗口去重
type DeduplicateWindow struct {
    size     int
    window   map[string]struct{}
    order    []string
    mu       sync.Mutex
}

func (w *DeduplicateWindow) IsDuplicate(key string) bool {
    w.mu.Lock()
    defer w.mu.Unlock()

    if _, exists := w.window[key]; exists {
        return true
    }

    // 添加到窗口
    w.window[key] = struct{}{}
    w.order = append(w.order, key)

    // 窗口满了，移除最旧的
    if len(w.order) > w.size {
        oldest := w.order[0]
        w.order = w.order[1:]
        delete(w.window, oldest)
    }

    return false
}
```

---

## 六、监控与告警

### 6.1 幂等相关指标

```go
var (
    idempotencyHits = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "idempotency_hits_total",
            Help: "Number of idempotent request hits (duplicates)",
        },
        []string{"service", "operation"},
    )

    idempotencyMisses = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "idempotency_misses_total",
            Help: "Number of new requests processed",
        },
        []string{"service", "operation"},
    )

    nonceReuseAttempts = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "nonce_reuse_attempts_total",
            Help: "Number of nonce reuse attempts blocked",
        },
        []string{"wallet"},
    )
)
```

### 6.2 告警规则

```yaml
groups:
  - name: idempotency
    rules:
      - alert: HighDuplicateRate
        expr: rate(idempotency_hits_total[5m]) / rate(idempotency_misses_total[5m]) > 0.1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High duplicate request rate"
          description: "Duplicate rate > 10%, possible client retry issue"

      - alert: NonceReuseSpike
        expr: rate(nonce_reuse_attempts_total[1m]) > 10
        for: 2m
        labels:
          severity: critical
        annotations:
          summary: "Nonce reuse attack detected"
          description: "Multiple nonce reuse attempts, possible replay attack"
```

---

## 七、最佳实践

### 7.1 幂等键生成规范

```go
// ✅ 好的幂等键
"order:0x1234...abcd:42"          // 包含业务语义
"trade:abc123:def456:1"           // 可追溯
"deposit:0xtxhash...:3"           // 不可变

// ❌ 不好的幂等键
"req-12345"                       // 无业务语义
fmt.Sprintf("%d", time.Now().UnixNano())  // 不确定性
uuid.New().String()               // 每次都不同
```

### 7.2 幂等性测试检查清单

- [ ] 相同请求连续发送 3 次，结果一致
- [ ] 网络超时后重试，不产生重复数据
- [ ] Kafka 消费者重启，不重复处理消息
- [ ] 服务崩溃恢复后，幂等状态正确
- [ ] 并发相同请求，只有一个成功处理
