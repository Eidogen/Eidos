# 服务设计补充：一致性与可靠性保障

> 本文档是对 01-交易服务.md 和 02-撮合引擎.md 的补充设计

---

## 一、Outbox Pattern：解决 Kafka 与数据库事务一致性

### 1.1 问题描述

原设计中，订单创建流程存在事务边界问题：

```
7. BEGIN 事务 → INSERT order → COMMIT
8. 发送到撮合引擎 (Kafka)  ← 在事务外，可能失败
```

如果 Kafka 发送失败：
- 订单已入库，状态为 PENDING
- 用户余额已冻结
- 但订单永远不会进入撮合引擎

### 1.2 解决方案：本地消息表 (Outbox Pattern)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      Outbox Pattern 架构                                     │
│                                                                              │
│  eidos-trading                                                               │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                        同一个数据库事务                              │     │
│  │                                                                     │     │
│  │  1. INSERT INTO orders (...)                                       │     │
│  │  2. UPDATE balances SET frozen = frozen + ?                        │     │
│  │  3. INSERT INTO outbox_messages (...)  ← 消息也在事务内            │     │
│  │                                                                     │     │
│  │  COMMIT  ← 要么全成功，要么全失败                                   │     │
│  │                                                                     │     │
│  └────────────────────────────────────────────────────────────────────┘     │
│                                  │                                          │
│                                  ▼                                          │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                    Outbox Relay (后台协程)                          │     │
│  │                                                                     │     │
│  │  定时轮询 outbox_messages 表:                                       │     │
│  │  1. SELECT * FROM outbox_messages WHERE status = 'pending'         │     │
│  │     ORDER BY created_at LIMIT 100                                  │     │
│  │                                                                     │     │
│  │  2. 发送到 Kafka                                                    │     │
│  │                                                                     │     │
│  │  3. UPDATE outbox_messages SET status = 'sent'                     │     │
│  │     WHERE id = ?                                                    │     │
│  │                                                                     │     │
│  └────────────────────────────────────────────────────────────────────┘     │
│                                  │                                          │
│                                  ▼                                          │
│                             Kafka                                           │
│                                  │                                          │
│                                  ▼                                          │
│                          eidos-matching                                     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.3 outbox_messages 表设计

```sql
CREATE TABLE outbox_messages (
    id              BIGSERIAL PRIMARY KEY,

    -- 消息标识
    message_id      VARCHAR(64) NOT NULL UNIQUE,    -- 全局唯一 ID，用于幂等

    -- 消息内容
    topic           VARCHAR(100) NOT NULL,          -- Kafka topic
    partition_key   VARCHAR(100) NOT NULL,          -- 分区键 (如 market)
    payload         JSONB NOT NULL,                 -- 消息内容

    -- 关联信息
    aggregate_type  VARCHAR(50) NOT NULL,           -- order, cancel, withdraw
    aggregate_id    VARCHAR(64) NOT NULL,           -- 关联的业务 ID

    -- 状态: pending, sent, failed
    status          VARCHAR(20) NOT NULL DEFAULT 'pending',
    retry_count     INT NOT NULL DEFAULT 0,
    max_retries     INT NOT NULL DEFAULT 5,
    last_error      VARCHAR(500),

    -- 时间
    created_at      BIGINT NOT NULL,
    sent_at         BIGINT,

    INDEX idx_outbox_status_created (status, created_at),
    INDEX idx_outbox_aggregate (aggregate_type, aggregate_id)
);
```

### 1.4 Outbox Relay 实现

```go
// OutboxRelay 负责将 outbox 消息发送到 Kafka
type OutboxRelay struct {
    db       *sql.DB
    producer *kafka.Producer
    interval time.Duration
}

func (r *OutboxRelay) Start(ctx context.Context) {
    ticker := time.NewTicker(r.interval) // 默认 100ms
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            r.processBatch(ctx)
        }
    }
}

func (r *OutboxRelay) processBatch(ctx context.Context) error {
    // 1. 查询待发送消息
    messages, err := r.fetchPendingMessages(ctx, 100)
    if err != nil {
        return err
    }

    for _, msg := range messages {
        // 2. 发送到 Kafka
        err := r.producer.Send(ctx, msg.Topic, msg.PartitionKey, msg.Payload)

        if err != nil {
            // 发送失败，更新重试次数
            r.markFailed(ctx, msg.ID, err)
            continue
        }

        // 3. 标记已发送
        r.markSent(ctx, msg.ID)
    }

    return nil
}

func (r *OutboxRelay) markFailed(ctx context.Context, id int64, err error) {
    r.db.ExecContext(ctx, `
        UPDATE outbox_messages
        SET retry_count = retry_count + 1,
            last_error = $1,
            status = CASE WHEN retry_count >= max_retries THEN 'failed' ELSE 'pending' END
        WHERE id = $2
    `, err.Error(), id)
}
```

### 1.5 订单创建流程 (修改后)

```go
func (s *OrderService) CreateOrder(ctx context.Context, req *CreateOrderRequest) error {
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // 1. 创建订单
    order := &Order{
        OrderID:   uuid.New().String(),
        Market:    req.Market,
        Maker:     req.Maker,
        Side:      req.Side,
        Price:     req.Price,
        Size:      req.Size,
        Status:    OrderStatusPending,
        CreatedAt: time.Now().UnixNano(),
    }

    if err := s.insertOrder(tx, order); err != nil {
        return err
    }

    // 2. 冻结余额
    if err := s.freezeBalance(tx, req.Maker, req.Token, freezeAmount); err != nil {
        return err
    }

    // 3. 写入 outbox (同一事务)
    outboxMsg := &OutboxMessage{
        MessageID:     order.OrderID,
        Topic:         "orders",
        PartitionKey:  req.Market,
        Payload:       order.ToKafkaPayload(),
        AggregateType: "order",
        AggregateID:   order.OrderID,
        Status:        "pending",
        CreatedAt:     time.Now().UnixNano(),
    }

    if err := s.insertOutboxMessage(tx, outboxMsg); err != nil {
        return err
    }

    // 4. 提交事务 - 订单、余额冻结、outbox 消息同时生效
    return tx.Commit()
}
```

### 1.6 消息清理策略

```go
// 定时清理已发送的 outbox 消息 (每小时执行)
func (r *OutboxRelay) cleanup(ctx context.Context) {
    // 删除 24 小时前已发送的消息
    cutoff := time.Now().Add(-24 * time.Hour).UnixNano()

    r.db.ExecContext(ctx, `
        DELETE FROM outbox_messages
        WHERE status = 'sent' AND sent_at < $1
    `, cutoff)
}

// 告警: 超过 max_retries 的失败消息
func (r *OutboxRelay) alertFailedMessages(ctx context.Context) {
    var count int
    r.db.QueryRowContext(ctx, `
        SELECT COUNT(*) FROM outbox_messages WHERE status = 'failed'
    `).Scan(&count)

    if count > 0 {
        alert.Send(alert.Critical, "Outbox messages failed",
            "count", count)
    }
}
```

---

## 二、余额模型增强：已结算与待结算分离

### 2.1 问题描述

原 balances 表只有 `available` 和 `frozen`，无法区分：
- 已结算余额（链上已确认，可提现）
- 待结算余额（链下成交，待上链）

### 2.2 增强后的余额模型

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        增强后的余额模型                                       │
│                                                                              │
│  用户总资产 = 已结算可用 + 已结算冻结 + 待结算可用 + 待结算冻结               │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                        balances 表                                   │    │
│  │                                                                      │    │
│  │  ┌──────────────────────┐    ┌──────────────────────┐               │    │
│  │  │    已结算 (Settled)   │    │    待结算 (Pending)   │               │    │
│  │  │                      │    │                      │               │    │
│  │  │  settled_available   │    │  pending_available   │               │    │
│  │  │  (可交易、可提现)     │    │  (可交易、不可提现)   │               │    │
│  │  │                      │    │                      │               │    │
│  │  │  settled_frozen      │    │  pending_frozen      │               │    │
│  │  │  (挂单冻结)          │    │  (挂单冻结)          │               │    │
│  │  │                      │    │                      │               │    │
│  │  └──────────────────────┘    └──────────────────────┘               │    │
│  │                                                                      │    │
│  │  计算公式:                                                           │    │
│  │  ─────────                                                           │    │
│  │  可用余额 = settled_available + pending_available                    │    │
│  │  可交易余额 = settled_available + pending_available                  │    │
│  │  可提现余额 = settled_available  (只有已结算才能提)                   │    │
│  │  总冻结 = settled_frozen + pending_frozen                            │    │
│  │  总资产 = 可用余额 + 总冻结                                          │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.3 增强后的 balances 表

```sql
CREATE TABLE balances (
    id                  BIGSERIAL PRIMARY KEY,
    wallet_address      VARCHAR(42) NOT NULL,
    token               VARCHAR(20) NOT NULL,

    -- 已结算余额 (链上已确认)
    settled_available   DECIMAL(36, 18) NOT NULL DEFAULT 0,
    settled_frozen      DECIMAL(36, 18) NOT NULL DEFAULT 0,

    -- 待结算余额 (链下成交，待上链)
    pending_available   DECIMAL(36, 18) NOT NULL DEFAULT 0,
    pending_frozen      DECIMAL(36, 18) NOT NULL DEFAULT 0,

    -- 待结算限额追踪
    pending_total       DECIMAL(36, 18) NOT NULL DEFAULT 0,  -- 用户待结算总额

    -- 审计字段
    created_by          VARCHAR(42),
    created_at          BIGINT NOT NULL,
    updated_by          VARCHAR(42),
    updated_at          BIGINT NOT NULL,
    version             BIGINT NOT NULL DEFAULT 0,           -- 乐观锁

    UNIQUE (wallet_address, token),

    -- 约束: 余额不能为负
    CONSTRAINT chk_settled_available CHECK (settled_available >= 0),
    CONSTRAINT chk_settled_frozen CHECK (settled_frozen >= 0),
    CONSTRAINT chk_pending_available CHECK (pending_available >= 0),
    CONSTRAINT chk_pending_frozen CHECK (pending_frozen >= 0)
);

-- 创建视图方便查询
CREATE VIEW balance_summary AS
SELECT
    wallet_address,
    token,
    settled_available + pending_available AS total_available,
    settled_frozen + pending_frozen AS total_frozen,
    settled_available AS withdrawable,
    settled_available + pending_available + settled_frozen + pending_frozen AS total_balance,
    pending_total
FROM balances;
```

### 2.4 余额操作场景

#### 场景 1: 充值入账

```go
// 充值直接进入已结算可用 (链上已确认)
func (s *BalanceService) CreditDeposit(ctx context.Context, wallet, token string, amount decimal.Decimal) error {
    return s.db.ExecContext(ctx, `
        UPDATE balances
        SET settled_available = settled_available + $1,
            updated_at = $2,
            version = version + 1
        WHERE wallet_address = $3 AND token = $4
    `, amount, time.Now().UnixNano(), wallet, token)
}
```

#### 场景 2: 下单冻结

```go
// 下单时优先冻结已结算余额，不足部分冻结待结算余额
func (s *BalanceService) FreezeForOrder(ctx context.Context, wallet, token string, amount decimal.Decimal) error {
    return s.db.ExecContext(ctx, `
        UPDATE balances
        SET
            -- 优先冻结已结算
            settled_frozen = settled_frozen + LEAST(settled_available, $1),
            settled_available = settled_available - LEAST(settled_available, $1),
            -- 不足部分冻结待结算
            pending_frozen = pending_frozen + GREATEST(0, $1 - settled_available),
            pending_available = pending_available - GREATEST(0, $1 - settled_available),
            updated_at = $2,
            version = version + 1
        WHERE wallet_address = $3 AND token = $4
          AND (settled_available + pending_available) >= $1
    `, amount, time.Now().UnixNano(), wallet, token)
}
```

#### 场景 3: 成交清算 (链下)

```go
// 成交后，买方获得 base，卖方获得 quote
// 都进入待结算可用
func (s *BalanceService) SettleTrade(ctx context.Context, trade *Trade) error {
    tx, _ := s.db.BeginTx(ctx, nil)
    defer tx.Rollback()

    // 买方: 解冻 quote，增加 base (待结算)
    tx.ExecContext(ctx, `
        UPDATE balances
        SET settled_frozen = settled_frozen - LEAST(settled_frozen, $1),
            pending_frozen = pending_frozen - GREATEST(0, $1 - settled_frozen),
            pending_available = pending_available + $2,
            pending_total = pending_total + $2,
            updated_at = $3
        WHERE wallet_address = $4 AND token = $5
    `, trade.QuoteAmount, trade.BaseAmount, now, trade.Buyer, trade.QuoteToken)

    // 卖方: 解冻 base，增加 quote (待结算)
    tx.ExecContext(ctx, `
        UPDATE balances
        SET settled_frozen = settled_frozen - LEAST(settled_frozen, $1),
            pending_frozen = pending_frozen - GREATEST(0, $1 - settled_frozen),
            pending_available = pending_available + $2,
            pending_total = pending_total + $2,
            updated_at = $3
        WHERE wallet_address = $4 AND token = $5
    `, trade.BaseAmount, trade.QuoteAmount, now, trade.Seller, trade.BaseToken)

    return tx.Commit()
}
```

#### 场景 4: 链上结算确认

```go
// 链上结算成功后，待结算转为已结算
func (s *BalanceService) ConfirmSettlement(ctx context.Context, settlements []Settlement) error {
    tx, _ := s.db.BeginTx(ctx, nil)
    defer tx.Rollback()

    for _, s := range settlements {
        tx.ExecContext(ctx, `
            UPDATE balances
            SET settled_available = settled_available + $1,
                pending_available = pending_available - $1,
                pending_total = pending_total - $1,
                updated_at = $2
            WHERE wallet_address = $3 AND token = $4
        `, s.Amount, now, s.Wallet, s.Token)
    }

    return tx.Commit()
}
```

#### 场景 5: 提现

```go
// 提现只能从已结算可用中扣除
func (s *BalanceService) Withdraw(ctx context.Context, wallet, token string, amount decimal.Decimal) error {
    result := s.db.ExecContext(ctx, `
        UPDATE balances
        SET settled_available = settled_available - $1,
            updated_at = $2
        WHERE wallet_address = $3 AND token = $4
          AND settled_available >= $1  -- 只能提已结算
    `, amount, time.Now().UnixNano(), wallet, token)

    if result.RowsAffected() == 0 {
        return ErrInsufficientWithdrawable
    }
    return nil
}
```

### 2.5 待结算限额控制

```go
// 检查用户待结算是否超限
func (s *BalanceService) CheckPendingLimit(ctx context.Context, wallet string, additionalAmount decimal.Decimal) error {
    var currentPending decimal.Decimal
    s.db.QueryRowContext(ctx, `
        SELECT COALESCE(SUM(pending_total), 0) FROM balances WHERE wallet_address = $1
    `, wallet).Scan(&currentPending)

    // 单用户待结算上限: 10,000 USDC
    if currentPending.Add(additionalAmount).GreaterThan(decimal.NewFromInt(10000)) {
        return ErrPendingLimitExceeded
    }

    return nil
}
```

---

## 三、取消订单竞态条件解决方案

### 3.1 问题描述

原设计中取消订单流程：
```
3. 更新订单状态 CANCELLING
4. 发送取消请求到撮合引擎
```

可能与撮合引擎正在进行的成交产生竞态。

### 3.2 解决方案：撮合引擎主导取消

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      改进后的取消订单流程                                     │
│                                                                              │
│  User          eidos-trading          Kafka           eidos-matching        │
│    │                │                   │                   │               │
│    │ 取消订单       │                   │                   │               │
│    │──────────────>│                   │                   │               │
│    │                │                   │                   │               │
│    │                │ 1. 验证请求       │                   │               │
│    │                │    (签名、权限)   │                   │               │
│    │                │                   │                   │               │
│    │                │ 2. 写入 outbox    │                   │               │
│    │                │    (不改订单状态) │                   │               │
│    │                │                   │                   │               │
│    │                │ 3. 返回"取消中"   │                   │               │
│    │<───────────────│                   │                   │               │
│    │                │                   │                   │               │
│    │                │                   │ cancel-requests  │               │
│    │                │                   │─────────────────>│               │
│    │                │                   │                   │               │
│    │                │                   │                   │ 4. 从订单簿移除│
│    │                │                   │                   │    (如果存在)  │
│    │                │                   │                   │               │
│    │                │                   │ order-cancelled  │               │
│    │                │                   │<─────────────────│               │
│    │                │                   │                   │               │
│    │                │ 5. 收到取消确认   │                   │               │
│    │                │<───────────────────                   │               │
│    │                │                   │                   │               │
│    │                │ 6. 更新订单状态   │                   │               │
│    │                │    CANCELLED      │                   │               │
│    │                │    解冻余额       │                   │               │
│    │                │                   │                   │               │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 取消确认消息增强

```protobuf
// order-cancelled topic 消息
message OrderCancelledMessage {
    string order_id = 1;
    string market = 2;

    // 取消结果
    CancelResult result = 3;

    // 取消时的订单状态
    string remaining_size = 4;      // 剩余数量
    string filled_size = 5;         // 已成交数量

    // 时间戳
    int64 timestamp = 6;
    int64 sequence = 7;
}

enum CancelResult {
    CANCEL_RESULT_SUCCESS = 0;           // 成功取消
    CANCEL_RESULT_NOT_FOUND = 1;         // 订单不存在 (可能已全部成交)
    CANCEL_RESULT_ALREADY_CANCELLED = 2; // 已取消过
}
```

### 3.4 Trading 服务处理取消确认

```go
func (s *OrderService) HandleCancelConfirm(ctx context.Context, msg *OrderCancelledMessage) error {
    tx, _ := s.db.BeginTx(ctx, nil)
    defer tx.Rollback()

    // 获取订单当前状态
    order, err := s.getOrderForUpdate(tx, msg.OrderID)
    if err != nil {
        return err
    }

    switch msg.Result {
    case CancelResultSuccess:
        // 成功取消
        order.Status = OrderStatusCancelled
        order.RemainingSize = msg.RemainingSize

        // 解冻剩余冻结金额
        unfreezeAmount := calculateUnfreezeAmount(order, msg.RemainingSize)
        s.unfreezeBalance(tx, order.Maker, order.Token, unfreezeAmount)

    case CancelResultNotFound:
        // 订单不在撮合引擎，可能已全部成交
        // 检查是否有对应的成交记录
        if order.FilledSize == order.OrigSize {
            order.Status = OrderStatusFilled
        } else {
            // 异常情况，记录日志
            log.Warn("cancel order not found but not fully filled",
                "order_id", msg.OrderID,
                "filled", order.FilledSize,
                "orig", order.OrigSize)
            order.Status = OrderStatusCancelled
        }

    case CancelResultAlreadyCancelled:
        // 幂等处理，忽略
        return nil
    }

    s.updateOrder(tx, order)
    return tx.Commit()
}
```

### 3.5 撮合引擎处理取消请求

```go
func (e *Engine) HandleCancelRequest(orderID string) *CancelResult {
    // 尝试从订单簿移除
    order, exists := e.orderBook.Orders[orderID]

    if !exists {
        // 订单不存在，可能已成交或已取消
        return &CancelResult{
            OrderID: orderID,
            Result:  CancelResultNotFound,
        }
    }

    // 从订单簿移除
    remainingSize := order.Quantity
    filledSize := order.OrigQty - order.Quantity
    e.removeOrder(order)

    return &CancelResult{
        OrderID:       orderID,
        Result:        CancelResultSuccess,
        RemainingSize: remainingSize,
        FilledSize:    filledSize,
    }
}
```

### 3.6 成交与取消的顺序保证

由于同一交易对的消息在同一 Kafka 分区，保证 FIFO 顺序：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     消息顺序保证                                              │
│                                                                              │
│  场景: 用户下单后立即取消                                                     │
│                                                                              │
│  Kafka 分区 (partition_key = market):                                        │
│  ─────────────────────────────────────                                       │
│  [Order1-Create] → [Order1-Cancel] → ...                                     │
│       │                  │                                                   │
│       ▼                  ▼                                                   │
│  撮合引擎按顺序处理:                                                          │
│  1. 处理 Order1-Create → 加入订单簿，可能部分成交                             │
│  2. 处理 Order1-Cancel → 从订单簿移除剩余部分                                 │
│                                                                              │
│  结果: 订单可能部分成交 + 剩余取消，状态一致                                   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 四、撮合引擎快照原子性保障

### 4.1 问题描述

快照保存和 Kafka offset 提交不是原子操作，可能导致：
- 快照保存成功，但 offset 提交前崩溃
- 重启后从旧 offset 回放，快照中的订单被重复处理

### 4.2 解决方案：两阶段快照

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      两阶段快照机制                                           │
│                                                                              │
│  阶段 1: 预写快照 (Pre-write)                                                │
│  ─────────────────────────────                                               │
│  1. 生成快照数据                                                              │
│  2. 保存到 Redis: snapshot:{market}:preparing                               │
│  3. 快照包含当前 Kafka offset                                                │
│                                                                              │
│  阶段 2: 确认快照 (Confirm)                                                  │
│  ─────────────────────────────                                               │
│  4. 提交 Kafka offset                                                        │
│  5. 原子重命名: snapshot:{market}:preparing → snapshot:{market}:latest      │
│  6. 删除旧快照                                                                │
│                                                                              │
│  恢复逻辑:                                                                   │
│  ──────────                                                                  │
│  - 如果存在 :preparing 快照，说明上次崩溃在阶段 2                             │
│  - 检查 Kafka offset 是否已提交                                              │
│    - 已提交: 使用 :preparing 快照                                            │
│    - 未提交: 使用 :latest 快照                                               │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.3 快照管理器实现

```go
type SnapshotManager struct {
    redis    *redis.Client
    consumer *kafka.Consumer
}

// 保存快照 (两阶段)
func (m *SnapshotManager) SaveSnapshot(ctx context.Context, market string, orderBook *OrderBook, offset int64) error {
    snapshot := &Snapshot{
        Market:      market,
        Timestamp:   time.Now().UnixNano(),
        KafkaOffset: offset,
        Bids:        orderBook.SerializeBids(),
        Asks:        orderBook.SerializeAsks(),
        LastPrice:   orderBook.LastPrice,
    }
    snapshot.Checksum = m.calculateChecksum(snapshot)

    data, _ := json.Marshal(snapshot)

    // 阶段 1: 预写快照
    preparingKey := fmt.Sprintf("snapshot:%s:preparing", market)
    if err := m.redis.Set(ctx, preparingKey, data, 1*time.Hour).Err(); err != nil {
        return err
    }

    // 阶段 2: 提交 Kafka offset
    if err := m.consumer.CommitOffset(offset); err != nil {
        // 提交失败，清理预写快照
        m.redis.Del(ctx, preparingKey)
        return err
    }

    // 阶段 2: 确认快照 (原子重命名)
    latestKey := fmt.Sprintf("snapshot:%s:latest", market)
    pipe := m.redis.Pipeline()
    pipe.Rename(ctx, preparingKey, latestKey)
    _, err := pipe.Exec(ctx)

    return err
}

// 加载快照 (处理不一致状态)
func (m *SnapshotManager) LoadSnapshot(ctx context.Context, market string) (*Snapshot, error) {
    preparingKey := fmt.Sprintf("snapshot:%s:preparing", market)
    latestKey := fmt.Sprintf("snapshot:%s:latest", market)

    // 检查是否有未完成的快照
    preparingData, err := m.redis.Get(ctx, preparingKey).Bytes()
    if err == nil {
        // 存在 preparing 快照，检查 Kafka offset
        var preparingSnapshot Snapshot
        json.Unmarshal(preparingData, &preparingSnapshot)

        committedOffset := m.consumer.GetCommittedOffset()

        if committedOffset >= preparingSnapshot.KafkaOffset {
            // offset 已提交，使用 preparing 快照
            m.redis.Rename(ctx, preparingKey, latestKey)
            return &preparingSnapshot, nil
        } else {
            // offset 未提交，删除 preparing，使用 latest
            m.redis.Del(ctx, preparingKey)
        }
    }

    // 加载 latest 快照
    latestData, err := m.redis.Get(ctx, latestKey).Bytes()
    if err != nil {
        return nil, ErrNoSnapshot
    }

    var snapshot Snapshot
    if err := json.Unmarshal(latestData, &snapshot); err != nil {
        return nil, err
    }

    // 验证 checksum
    if !m.verifyChecksum(&snapshot) {
        return nil, ErrSnapshotCorrupted
    }

    return &snapshot, nil
}
```

### 4.4 消息回放去重

```go
type Engine struct {
    orderBook     *OrderBook
    processedIDs  map[string]bool  // 已处理的消息 ID (回放时使用)
    lastSequence  int64
}

// 回放消息时的去重
func (e *Engine) ReplayMessage(msg *Message) error {
    // 序列号检查
    if msg.Sequence <= e.lastSequence {
        return nil // 跳过旧消息
    }

    // 订单 ID 去重
    if msg.Type == MsgTypeOrder {
        if e.processedIDs[msg.OrderID] {
            return nil // 跳过已处理的订单
        }
        if _, exists := e.orderBook.Orders[msg.OrderID]; exists {
            return nil // 订单已在订单簿中
        }
    }

    // 正常处理
    err := e.processMessage(msg)
    if err == nil {
        e.lastSequence = msg.Sequence
        if msg.Type == MsgTypeOrder {
            e.processedIDs[msg.OrderID] = true
        }
    }

    return err
}

// 回放完成后清理
func (e *Engine) FinishReplay() {
    e.processedIDs = nil // 释放内存
}
```

---

## 五、市价单最新价维护机制

### 5.1 问题描述

市价单滑点保护依赖"最新价"，但文档未说明：
- lastPrice 如何初始化
- 新上线交易对如何处理
- 更新时机

### 5.2 最新价维护方案

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      最新价 (Last Price) 维护机制                            │
│                                                                              │
│  来源优先级:                                                                 │
│  ═══════════                                                                 │
│  1. 最近成交价 (最高优先级)                                                   │
│  2. 中间价 (best_bid + best_ask) / 2                                        │
│  3. 外部指数价格 (从 price feed 获取)                                        │
│  4. 初始价格 (市场配置中指定)                                                 │
│                                                                              │
│  更新时机:                                                                   │
│  ═══════════                                                                 │
│  - 每次成交后立即更新                                                         │
│  - 无成交时，每秒从 price feed 同步                                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.3 实现代码

```go
type Engine struct {
    market       string
    orderBook    *OrderBook
    lastPrice    int64           // 最新价 (定点数)
    lastPriceAt  int64           // 最新价更新时间
    indexPrice   int64           // 外部指数价格
    indexPriceAt int64           // 指数价格更新时间
    initialPrice int64           // 初始价格 (配置)
}

// 获取参考价格 (用于市价单滑点保护)
func (e *Engine) getReferencePrice() int64 {
    now := time.Now().UnixNano()

    // 1. 最近成交价 (5分钟内有效)
    if e.lastPrice > 0 && (now-e.lastPriceAt) < 5*time.Minute.Nanoseconds() {
        return e.lastPrice
    }

    // 2. 中间价
    if e.orderBook.BestBid != nil && e.orderBook.BestAsk != nil {
        midPrice := (e.orderBook.BestBid.Price + e.orderBook.BestAsk.Price) / 2
        return midPrice
    }

    // 3. 外部指数价格 (1分钟内有效)
    if e.indexPrice > 0 && (now-e.indexPriceAt) < 1*time.Minute.Nanoseconds() {
        return e.indexPrice
    }

    // 4. 初始价格
    return e.initialPrice
}

// 成交后更新最新价
func (e *Engine) updateLastPrice(tradePrice int64) {
    e.lastPrice = tradePrice
    e.lastPriceAt = time.Now().UnixNano()
}

// 外部指数价格更新 (由 price feed 服务调用)
func (e *Engine) UpdateIndexPrice(price int64) {
    e.indexPrice = price
    e.indexPriceAt = time.Now().UnixNano()
}
```

### 5.4 新市场启动流程

```go
// 新市场启动检查
func (e *Engine) validateMarketReady() error {
    refPrice := e.getReferencePrice()

    if refPrice == 0 {
        return ErrMarketNotReady
    }

    // 检查订单簿是否有足够深度 (可选)
    if e.orderBook.BidCount < 5 || e.orderBook.AskCount < 5 {
        log.Warn("market has low liquidity", "market", e.market)
    }

    return nil
}

// 市场配置中指定初始价格
type MarketConfig struct {
    Symbol       string
    InitialPrice string  // 新市场的初始价格
    // ...
}
```

### 5.5 市价单拒绝策略

```go
func (e *Engine) MatchMarketOrder(order *Order, slippage int64) ([]*Trade, error) {
    refPrice := e.getReferencePrice()

    // 无参考价格时拒绝市价单
    if refPrice == 0 {
        return nil, ErrNoReferencePrice
    }

    // 订单簿为空时拒绝市价单
    if order.Side == SideBuy && e.orderBook.BestAsk == nil {
        return nil, ErrNoLiquidity
    }
    if order.Side == SideSell && e.orderBook.BestBid == nil {
        return nil, ErrNoLiquidity
    }

    // 计算保护价格
    var protectPrice int64
    if order.Side == SideBuy {
        protectPrice = refPrice * (PricePrecision + slippage) / PricePrecision
    } else {
        protectPrice = refPrice * (PricePrecision - slippage) / PricePrecision
    }

    // ... 执行撮合
}
```

---

## 六、分布式时间戳生成方案

### 6.1 问题描述

原设计中时间戳由 eidos-trading 分配，但多实例部署时无法保证全局单调递增。

### 6.2 解决方案：Snowflake ID 生成器

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      Snowflake ID 结构 (64 bit)                              │
│                                                                              │
│  ┌────────┬──────────────────┬───────────────┬────────────────────┐         │
│  │ 1 bit  │     41 bits      │   10 bits     │      12 bits       │         │
│  │ (符号) │   (时间戳)        │  (机器ID)      │     (序列号)        │         │
│  └────────┴──────────────────┴───────────────┴────────────────────┘         │
│                                                                              │
│  - 时间戳: 毫秒级，可用约 69 年                                               │
│  - 机器ID: 支持 1024 个实例                                                   │
│  - 序列号: 每毫秒可生成 4096 个 ID                                            │
│                                                                              │
│  保证:                                                                       │
│  - 全局唯一                                                                   │
│  - 单实例内单调递增                                                           │
│  - 可按时间大致排序                                                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.3 ID 生成器实现

```go
package idgen

import (
    "sync"
    "time"
)

const (
    epoch          = 1704067200000 // 2024-01-01 00:00:00 UTC (毫秒)
    machineIDBits  = 10
    sequenceBits   = 12
    maxMachineID   = -1 ^ (-1 << machineIDBits)
    maxSequence    = -1 ^ (-1 << sequenceBits)
    machineIDShift = sequenceBits
    timestampShift = machineIDBits + sequenceBits
)

type Snowflake struct {
    mu        sync.Mutex
    machineID int64
    sequence  int64
    lastTime  int64
}

func NewSnowflake(machineID int64) (*Snowflake, error) {
    if machineID < 0 || machineID > maxMachineID {
        return nil, fmt.Errorf("machine ID must be between 0 and %d", maxMachineID)
    }
    return &Snowflake{machineID: machineID}, nil
}

func (s *Snowflake) Generate() int64 {
    s.mu.Lock()
    defer s.mu.Unlock()

    now := time.Now().UnixMilli() - epoch

    if now == s.lastTime {
        s.sequence = (s.sequence + 1) & maxSequence
        if s.sequence == 0 {
            // 当前毫秒序列号用尽，等待下一毫秒
            for now <= s.lastTime {
                now = time.Now().UnixMilli() - epoch
            }
        }
    } else {
        s.sequence = 0
    }

    s.lastTime = now

    return (now << timestampShift) | (s.machineID << machineIDShift) | s.sequence
}

// 从 ID 中解析时间戳
func ParseTime(id int64) time.Time {
    ms := (id >> timestampShift) + epoch
    return time.UnixMilli(ms)
}
```

### 6.4 机器 ID 分配

```go
// 使用 Redis 自动分配机器 ID
func acquireMachineID(ctx context.Context, redis *redis.Client, serviceName string) (int64, error) {
    for i := int64(0); i <= maxMachineID; i++ {
        key := fmt.Sprintf("machine_id:%s:%d", serviceName, i)

        // 尝试获取锁 (30秒过期，需要定期续期)
        ok, err := redis.SetNX(ctx, key, "1", 30*time.Second).Result()
        if err != nil {
            return 0, err
        }

        if ok {
            // 成功获取，启动续期协程
            go renewMachineID(ctx, redis, key)
            return i, nil
        }
    }

    return 0, ErrNoAvailableMachineID
}

func renewMachineID(ctx context.Context, redis *redis.Client, key string) {
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            redis.Del(context.Background(), key)
            return
        case <-ticker.C:
            redis.Expire(ctx, key, 30*time.Second)
        }
    }
}
```

### 6.5 订单使用 Snowflake ID

```go
type OrderService struct {
    idGen *Snowflake
}

func (s *OrderService) CreateOrder(ctx context.Context, req *CreateOrderRequest) (*Order, error) {
    order := &Order{
        OrderID:   fmt.Sprintf("%d", s.idGen.Generate()),  // 使用 Snowflake ID
        // ...
    }
    // ...
}
```

### 6.6 撮合引擎排序

```go
// 撮合引擎使用订单 ID 作为时间优先的比较依据
// 因为 Snowflake ID 本身就是按时间大致排序的

func (o *Order) CompareTo(other *Order) int {
    // 同价格时，按 ID 排序 (ID 包含时间信息)
    if o.ID < other.ID {
        return -1
    }
    if o.ID > other.ID {
        return 1
    }
    return 0
}
```

---

## 七、服务间状态同步与确认机制

### 7.1 订单状态同步

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      订单状态同步机制                                         │
│                                                                              │
│  订单状态流转:                                                               │
│  ════════════                                                                │
│                                                                              │
│  Trading              Matching              Trading                          │
│  ┌──────────┐        ┌──────────┐         ┌──────────┐                      │
│  │ PENDING  │ ────>  │ 加入订单簿 │ ────>   │   OPEN   │                      │
│  └──────────┘        └──────────┘         └──────────┘                      │
│       │                   │                    │                             │
│       │                   │ 部分成交           │                             │
│       │                   ▼                    ▼                             │
│       │              ┌──────────┐         ┌──────────┐                      │
│       │              │ 发送成交  │ ────>   │ PARTIALLY│                      │
│       │              │ 结果      │         │ _FILLED  │                      │
│       │              └──────────┘         └──────────┘                      │
│       │                   │                    │                             │
│       │                   │ 完全成交           │                             │
│       │                   ▼                    ▼                             │
│       │              ┌──────────┐         ┌──────────┐                      │
│       │              │ 从订单簿  │ ────>   │  FILLED  │                      │
│       │              │ 移除      │         │          │                      │
│       │              └──────────┘         └──────────┘                      │
│                                                                              │
│  新增 Topic: order-accepted                                                  │
│  ─────────────────────────────                                               │
│  当订单成功加入订单簿时，matching 发送 order-accepted 消息                    │
│  trading 收到后将订单状态从 PENDING 更新为 OPEN                              │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 7.2 订单接受确认消息

```protobuf
// 新增 topic: order-accepted
message OrderAcceptedMessage {
    string order_id = 1;
    string market = 2;
    int64 timestamp = 3;
    int64 sequence = 4;
}
```

### 7.3 Trading 处理订单确认

```go
func (s *OrderService) HandleOrderAccepted(ctx context.Context, msg *OrderAcceptedMessage) error {
    return s.db.ExecContext(ctx, `
        UPDATE orders
        SET status = $1, accepted_at = $2, updated_at = $3
        WHERE order_id = $4 AND status = $5
    `, OrderStatusOpen, msg.Timestamp, time.Now().UnixNano(), msg.OrderID, OrderStatusPending)
}
```

### 7.4 成交确认 ACK 机制

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      成交确认 ACK 机制                                        │
│                                                                              │
│  问题: matching 发送 trade-results 后，trading 可能处理失败                   │
│                                                                              │
│  解决: 使用 Kafka Consumer Group 的 at-least-once 语义                       │
│  ═══════════════════════════════════════════════════                         │
│                                                                              │
│  Matching                   Kafka                   Trading                  │
│      │                        │                        │                     │
│      │  trade-results         │                        │                     │
│      │───────────────────────>│                        │                     │
│      │                        │                        │                     │
│      │                        │   消费消息             │                     │
│      │                        │───────────────────────>│                     │
│      │                        │                        │                     │
│      │                        │                        │ 处理成交            │
│      │                        │                        │ (幂等处理)          │
│      │                        │                        │                     │
│      │                        │   提交 offset          │                     │
│      │                        │<───────────────────────│                     │
│      │                        │   (处理成功后)         │                     │
│      │                        │                        │                     │
│                                                                              │
│  幂等处理关键:                                                               │
│  ───────────────                                                             │
│  - trade_id 作为幂等键                                                       │
│  - 数据库唯一约束防止重复插入                                                 │
│  - 即使消息重复消费，也不会产生重复数据                                       │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 7.5 成交处理幂等实现

```go
func (s *ClearingService) HandleTradeResult(ctx context.Context, msg *TradeResultMessage) error {
    tx, _ := s.db.BeginTx(ctx, nil)
    defer tx.Rollback()

    // 1. 尝试插入成交记录 (幂等)
    _, err := tx.ExecContext(ctx, `
        INSERT INTO trades (trade_id, maker_order_id, taker_order_id, ...)
        VALUES ($1, $2, $3, ...)
        ON CONFLICT (trade_id) DO NOTHING
    `, msg.TradeID, msg.MakerOrderID, msg.TakerOrderID, ...)

    if err != nil {
        return err
    }

    // 检查是否真正插入了新记录
    var tradeExists bool
    tx.QueryRowContext(ctx, `
        SELECT EXISTS(SELECT 1 FROM trades WHERE trade_id = $1 AND processed = true)
    `, msg.TradeID).Scan(&tradeExists)

    if tradeExists {
        // 已处理过，跳过
        return tx.Commit()
    }

    // 2. 更新订单状态
    s.updateOrderFromTrade(tx, msg)

    // 3. 更新余额
    s.settleBalance(tx, msg)

    // 4. 标记成交为已处理
    tx.ExecContext(ctx, `
        UPDATE trades SET processed = true WHERE trade_id = $1
    `, msg.TradeID)

    return tx.Commit()
}
```

### 7.6 余额冻结超时解冻

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      余额冻结超时解冻机制                                      │
│                                                                              │
│  场景: 订单发送到 Kafka 但 matching 未收到，余额一直冻结                       │
│                                                                              │
│  解决方案: 定时任务检查 + 超时解冻                                            │
│  ══════════════════════════════════                                          │
│                                                                              │
│  定时任务 (每分钟执行):                                                       │
│  ─────────────────────                                                       │
│  1. 查找状态为 PENDING 且创建时间超过 5 分钟的订单                            │
│  2. 检查 outbox_messages 状态                                                │
│     - 如果消息发送失败，取消订单并解冻                                        │
│     - 如果消息已发送但订单仍是 PENDING，可能 matching 丢失                    │
│  3. 重发订单到 matching 或标记为异常                                          │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

```go
// 订单超时检查任务
func (s *OrderService) CheckPendingOrders(ctx context.Context) error {
    timeout := time.Now().Add(-5 * time.Minute).UnixNano()

    orders, err := s.db.QueryContext(ctx, `
        SELECT o.order_id, o.maker, o.token, o.frozen_amount, m.status as msg_status
        FROM orders o
        LEFT JOIN outbox_messages m ON o.order_id = m.aggregate_id
        WHERE o.status = 'PENDING' AND o.created_at < $1
    `, timeout)
    if err != nil {
        return err
    }

    for orders.Next() {
        var order struct {
            OrderID      string
            Maker        string
            Token        string
            FrozenAmount decimal.Decimal
            MsgStatus    sql.NullString
        }
        orders.Scan(&order.OrderID, &order.Maker, &order.Token,
                    &order.FrozenAmount, &order.MsgStatus)

        switch order.MsgStatus.String {
        case "failed":
            // 消息发送失败，取消订单
            s.cancelOrderAndUnfreeze(ctx, order)

        case "sent":
            // 消息已发送但订单仍 PENDING
            // 可能是 order-accepted 消息丢失，查询 matching 状态
            s.checkMatchingStatus(ctx, order)

        default:
            // 消息还在等待发送
            log.Warn("order message stuck in outbox", "order_id", order.OrderID)
        }
    }

    return nil
}
```

### 7.7 手续费计算位置明确

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      手续费计算流程                                           │
│                                                                              │
│  明确分工:                                                                   │
│  ═════════                                                                   │
│  - Matching: 根据费率计算手续费，包含在 trade-results 中                      │
│  - Trading:  直接使用 Matching 计算的手续费，执行扣款                         │
│                                                                              │
│  计算逻辑 (在 Matching 中):                                                  │
│  ──────────────────────────                                                  │
│  maker_fee = trade_amount * maker_fee_rate                                   │
│  taker_fee = trade_amount * taker_fee_rate                                   │
│                                                                              │
│  费率来源:                                                                   │
│  ──────────                                                                  │
│  - 从市场配置中读取基础费率                                                   │
│  - 可选: 从用户等级服务获取折扣 (异步更新到 Matching)                        │
│                                                                              │
│  trade-results 消息内容:                                                     │
│  ─────────────────────────                                                   │
│  {                                                                           │
│    "trade_id": "...",                                                        │
│    "price": "50000",                                                         │
│    "size": "0.1",                                                            │
│    "quote_amount": "5000",         // 成交金额                               │
│    "maker_fee": "2.5",             // maker 手续费 (Matching 计算)           │
│    "taker_fee": "5",               // taker 手续费 (Matching 计算)           │
│    ...                                                                       │
│  }                                                                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 八、配置补充

### 8.1 eidos-trading 新增配置

```yaml
# Outbox 配置
outbox:
  relay_interval: 100ms         # 轮询间隔
  batch_size: 100               # 每批处理数量
  max_retries: 5                # 最大重试次数
  cleanup_interval: 1h          # 清理间隔
  retention: 24h                # 已发送消息保留时间

# 订单超时配置
order:
  pending_timeout: 5m           # PENDING 状态超时
  check_interval: 1m            # 检查间隔

# ID 生成器
idgen:
  type: snowflake
  machine_id_source: redis      # redis, env, config
```

### 8.2 eidos-matching 新增配置

```yaml
# 快照配置 (增强)
snapshot:
  interval: 30s
  max_count: 10
  two_phase: true               # 启用两阶段快照

# 最新价配置
last_price:
  stale_threshold: 5m           # 成交价过期时间
  index_price_stale: 1m         # 指数价过期时间

# 新增 topic
kafka:
  producer:
    topics:
      order_accepted: order-accepted
```

---

## 九、总结

本补充文档解决了以下关键问题：

| 问题 | 解决方案 | 关键点 |
|------|----------|--------|
| Kafka 与事务一致性 | Outbox Pattern | 本地消息表 + 后台 Relay |
| 余额模型不完整 | 四字段模型 | settled/pending × available/frozen |
| 取消订单竞态 | Matching 主导 | 先发请求后更新状态 |
| 快照原子性 | 两阶段快照 | 预写 + 确认 |
| 市价单最新价 | 多源优先级 | 成交价 > 中间价 > 指数价 |
| 时间戳多实例 | Snowflake ID | 分布式唯一 ID |
| 服务间状态同步 | ACK 机制 | 幂等处理 + 超时检查 |

这些改进确保了系统在分布式环境下的一致性和可靠性。
