# Eidos 链上服务设计

> 服务名: eidos-chain
> 语言: Go

---

## 一、服务概述

### 1.1 核心定位

eidos-chain 是链上交互核心服务，整合了链上结算和链上索引两大功能模块。

**设计原则**:
- 将链上交互逻辑整合到同一服务，简化部署和运维
- Settlement 负责系统 → 链上的数据写入
- Indexer 负责链上 → 系统的数据同步

### 1.2 内部模块

```
eidos-chain
├── settlement/     结算模块 (原 eidos-settlement)
│   ├── 批量收集成交结果
│   ├── 构造链上交易
│   ├── 提交结算到区块链
│   └── 处理提现请求
└── indexer/        索引模块 (原 eidos-indexer)
    ├── 监听链上事件
    ├── 检测充值
    ├── 确认提现
    └── 同步链上状态
```

### 1.3 职责边界

| 职责 | 描述 | 属于本服务 |
|------|------|-----------|
| 成交收集 | 从 Kafka 收集成交结果 | ✅ settlement |
| 批量打包 | 合并多笔成交为一次交易 | ✅ settlement |
| 交易构造 | 构造链上交易数据 | ✅ settlement |
| 提交上链 | 发送交易到区块链 | ✅ settlement |
| 提现处理 | 处理用户提现请求 | ✅ settlement |
| 区块监听 | 监听新区块和事件 | ✅ indexer |
| 充值检测 | 检测 Deposit 事件 | ✅ indexer |
| 入账通知 | 通知余额服务入账 | ✅ indexer |
| 状态同步 | 同步链上合约状态 | ✅ indexer |
| 余额管理 | 用户余额增减 | ❌ (eidos-trading) |

### 1.4 对外能力

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      eidos-chain 对外能力                                    │
│                                                                              │
│  gRPC 接口:                                                                  │
│  ═══════════                                                                 │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐              │
│  │  GetSettlement  │  │ GetWithdrawTx   │  │  GetDeposit     │              │
│  │  查询结算批次    │  │  查询提现交易    │  │  查询充值状态    │              │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘              │
│  ┌─────────────────┐  ┌─────────────────┐                                   │
│  │  RetrySettle    │  │  GetBlockHeight │                                   │
│  │  重试结算       │  │  查询区块高度    │                                   │
│  └─────────────────┘  └─────────────────┘                                   │
│                                                                              │
│  Kafka 消费:                                                                 │
│  ───────────                                                                 │
│  - topic: settlements   (待结算成交)                                         │
│  - topic: withdrawals   (提现请求)                                           │
│                                                                              │
│  Kafka 生产:                                                                 │
│  ───────────                                                                 │
│  - topic: deposits              (充值事件，给 eidos-trading)                 │
│  - topic: settlement-confirmed  (结算确认)                                   │
│  - topic: withdrawal-confirmed  (提现确认)                                   │
│                                                                              │
│  链上交互:                                                                   │
│  ───────────                                                                 │
│  - Vault.deposit() 监听                                                      │
│  - Vault.withdraw() 执行                                                     │
│  - Exchange.batchSettle() 执行                                               │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 二、Settlement 模块

### 2.1 批量结算流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          批量结算流程                                        │
│                                                                              │
│  Kafka                eidos-chain.settlement              Blockchain        │
│    │                          │                              │              │
│    │ settlements              │                              │              │
│    │──────────────────────────>                              │              │
│    │                          │                              │              │
│    │                          │ 1. 收集成交                  │              │
│    │                          │    累积到批次                │              │
│    │                          │                              │              │
│    │                          │ 2. 触发条件:                 │              │
│    │                          │    - 成交数 >= 100           │              │
│    │                          │    - 或 时间 >= 5s           │              │
│    │                          │                              │              │
│    │                          │ 3. 构造批量结算交易          │              │
│    │                          │    Exchange.batchSettle()    │              │
│    │                          │─────────────────────────────>│              │
│    │                          │                              │              │
│    │                          │ 4. 等待确认                  │              │
│    │                          │    (轮询或事件)              │              │
│    │                          │<─────────────────────────────│              │
│    │                          │                              │              │
│    │                          │ 5. 更新结算状态              │              │
│    │                          │    Kafka: settlement-confirmed               │
│    │                          │                              │              │
│    │                          │ 6. 下一批次                  │              │
│    │                          │                              │              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 提现处理流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          提现处理流程                                        │
│                                                                              │
│  Kafka                eidos-chain.settlement              Blockchain        │
│    │                          │                              │              │
│    │ withdrawals              │                              │              │
│    │ {                        │                              │              │
│    │   withdraw_id: "...",    │                              │              │
│    │   wallet: "0x...",       │                              │              │
│    │   token: "USDC",         │                              │              │
│    │   amount: "1000",        │                              │              │
│    │   signature: "0x..."     │                              │              │
│    │ }                        │                              │              │
│    │──────────────────────────>                              │              │
│    │                          │                              │              │
│    │                          │ 1. 验证签名                  │              │
│    │                          │                              │              │
│    │                          │ 2. 检查链上余额              │              │
│    │                          │                              │              │
│    │                          │ 3. 构造提现交易              │              │
│    │                          │    Vault.withdraw()          │              │
│    │                          │─────────────────────────────>│              │
│    │                          │                              │              │
│    │                          │ 4. 等待确认                  │              │
│    │                          │<─────────────────────────────│              │
│    │                          │                              │              │
│    │                          │ 5. 发送确认事件              │              │
│    │                          │    Kafka: withdrawal-confirmed               │
│    │                          │                              │              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.3 结算失败回滚策略

> **重要**: 详见 [04-状态机规范.md](../3-开发规范/04-状态机规范.md) 中的成交结算状态机

**设计原则:**
```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         结算失败处理设计原则                                  │
│                                                                              │
│  核心原则: 链下余额是链上的"乐观视图"，回滚是最后手段                          │
│                                                                              │
│  1. 优先重试，不轻易回滚                                                     │
│     - 大多数失败是临时性的 (Gas/Nonce/网络)                                  │
│     - 3 次重试 + 指数退避足以覆盖 99%+ 的临时故障                            │
│                                                                              │
│  2. 限额控制，降低回滚影响                                                   │
│     - 单用户待结算上限: 10,000 USDC                                          │
│     - 全系统待结算上限: 1,000,000 USDC                                       │
│                                                                              │
│  3. 保险金兜底                                                               │
│     - 系统保险金账户覆盖极端损失                                             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

**失败类型与处理:**

| 失败类型 | 原因 | 处理策略 | 是否回滚 |
|----------|------|----------|----------|
| Gas 不足 | 热钱包 ETH 不足 | 充值 ETH 后自动重试 | ❌ |
| Nonce 冲突 | 并发提交导致 | 重新获取 Nonce 重试 | ❌ |
| 网络超时 | RPC 节点问题 | 切换节点重试 | ❌ |
| 合约 Revert | 余额不足/权限问题 | 人工分析，可能拆分批次 | ⚠️ 视情况 |
| 持续失败 | 合约 Bug/不可恢复错误 | 熔断 + 人工介入 | ✅ 可能 |

**回滚触发条件:**
- 重试次数用尽 (>= 3 次)
- 人工审核确认无法恢复
- 管理后台明确触发回滚操作
- **自动回滚被禁用**: 避免误操作放大问题

---

## 三、Indexer 模块

### 3.1 充值检测流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          充值检测流程                                        │
│                                                                              │
│  Blockchain          eidos-chain.indexer          eidos-trading.account     │
│      │                     │                            │                   │
│      │ New Block           │                            │                   │
│      │ (Events)            │                            │                   │
│      │────────────────────>│                            │                   │
│      │                     │                            │                   │
│      │                     │ 1. 解析 Deposit 事件       │                   │
│      │                     │    user: 0x123            │                   │
│      │                     │    token: USDC            │                   │
│      │                     │    amount: 1000           │                   │
│      │                     │                            │                   │
│      │                     │ 2. 保存待确认记录          │                   │
│      │                     │                            │                   │
│      │ Block + N           │                            │                   │
│      │ (确认数达标)         │                            │                   │
│      │────────────────────>│                            │                   │
│      │                     │                            │                   │
│      │                     │ 3. 确认充值有效            │                   │
│      │                     │    检查无重组              │                   │
│      │                     │                            │                   │
│      │                     │ 4. Kafka: deposits         │                   │
│      │                     │───────────────────────────>│                   │
│      │                     │                            │                   │
│      │                     │                            │ 5. 入账           │
│      │                     │                            │    available += 1000
│      │                     │                            │                   │
│      │                     │ 6. 更新记录状态            │                   │
│      │                     │    status = CREDITED      │                   │
│      │                     │                            │                   │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 区块处理策略

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          区块处理策略                                        │
│                                                                              │
│  安全考虑:                                                                   │
│  ═══════════                                                                 │
│  - 区块重组风险: 等待足够确认数                                              │
│  - 服务重启: 从检查点恢复                                                    │
│  - 事件遗漏: 定期全量同步                                                    │
│                                                                              │
│  确认数配置:                                                                 │
│  ──────────────                                                              │
│  - 所有环境: 0 个确认 (即时入账)                                            │
│  - Arbitrum L2 finality 机制保证交易快速确认                                │
│                                                                              │
│  检查点机制:                                                                 │
│  ──────────────                                                              │
│  - 每处理 100 个区块保存检查点                                               │
│  - 存储: Redis + PostgreSQL 双写                                            │
│  - 重启时从检查点恢复                                                        │
│                                                                              │
│  处理流程:                                                                   │
│  ──────────                                                                  │
│  1. 获取最新区块高度                                                         │
│  2. 从检查点开始扫描                                                         │
│  3. 解析每个区块的事件                                                       │
│  4. 处理 Deposit/Withdraw 事件                                              │
│  5. 等待确认数                                                               │
│  6. 更新检查点                                                               │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 四、链上链下对账机制

### 4.1 对账架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        链上链下对账架构                                       │
│                                                                              │
│  问题: 链下余额与链上状态可能出现不一致                                       │
│  原因:                                                                       │
│  - 结算延迟 (批量提交间隔)                                                   │
│  - 结算失败 (Gas/网络问题)                                                   │
│  - 重组/回滚 (区块链特性)                                                    │
│                                                                              │
│  解决方案: 定期对账 + 差异处理                                               │
│                                                                              │
│  ┌─────────────┐              ┌─────────────┐                               │
│  │  链下余额    │              │  链上余额    │                               │
│  │  (PostgreSQL)│   <─对比─>   │  (合约状态)  │                               │
│  │             │              │             │                               │
│  │ available   │              │ balanceOf() │                               │
│  │ frozen      │              │             │                               │
│  │ pending     │              │             │                               │
│  └─────────────┘              └─────────────┘                               │
│         │                            │                                       │
│         └────────────┬───────────────┘                                       │
│                      ▼                                                       │
│              ┌─────────────┐                                                 │
│              │  对账任务    │                                                 │
│              │ (eidos-jobs)│                                                 │
│              └─────────────┘                                                 │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 对账类型

| 对账类型 | 频率 | 内容 | 处理方式 |
|----------|------|------|----------|
| **实时对账** | 每次结算后 | 验证结算交易成功 | 失败则重试/告警 |
| **定时对账** | 每小时 | 抽样用户余额校验 | 差异记录，人工处理 |
| **全量对账** | 每日 | 全部用户余额校验 | 生成对账报告 |
| **紧急对账** | 手动触发 | 指定用户/全量 | 人工发起 |

### 4.3 对账计算公式

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        余额一致性校验公式                                     │
│                                                                              │
│  链上余额 = 链下已结算余额                                                    │
│  ════════════════════════                                                    │
│                                                                              │
│  定义:                                                                       │
│  - on_chain_balance:   合约 balanceOf(user)                                  │
│  - off_chain_settled:  已结算到链上的余额                                    │
│                                                                              │
│  计算 off_chain_settled:                                                     │
│  ─────────────────────────                                                   │
│  off_chain_settled = initial_deposit                                         │
│                    + SUM(settled_deposits)                                   │
│                    - SUM(confirmed_withdrawals)                              │
│                    + SUM(settled_trade_gains)                                │
│                    - SUM(settled_trade_losses)                               │
│                    - SUM(settled_fees)                                       │
│                                                                              │
│  差异容忍度:                                                                 │
│  ────────────                                                                │
│  - 允许差异: 待结算金额 (pending_settle)                                     │
│  - 不允许差异: 已确认结算但金额不符                                          │
│                                                                              │
│  校验公式:                                                                   │
│  ──────────                                                                  │
│  on_chain_balance = off_chain_settled                                        │
│  off_chain_available + off_chain_frozen + pending_settle = on_chain_balance  │
│                                                                              │
│  如果不等:                                                                   │
│  - 差异 = pending_settle -> 正常 (待结算)                                    │
│  - 差异 != pending_settle -> 异常 (需人工处理)                               │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 五、数据库设计

### 5.1 结算批次表 (settlement_batches)

```sql
CREATE TABLE settlement_batches (
    id              BIGSERIAL PRIMARY KEY,
    batch_id        VARCHAR(64) NOT NULL UNIQUE,

    -- 批次信息
    trade_count     INT NOT NULL,
    trade_ids       TEXT NOT NULL,                -- 成交ID列表 (JSON)

    -- 链上信息
    chain_id        INT NOT NULL,
    tx_hash         VARCHAR(66),
    block_number    BIGINT,
    gas_used        BIGINT,
    gas_price       VARCHAR(36),

    -- 状态: 0=PENDING, 1=SUBMITTED, 2=CONFIRMED, 3=FAILED
    status          SMALLINT NOT NULL DEFAULT 0,
    error_message   VARCHAR(500),
    retry_count     INT NOT NULL DEFAULT 0,

    created_at      BIGINT NOT NULL,
    updated_at      BIGINT NOT NULL,

    INDEX idx_batches_status (status),
    INDEX idx_batches_created_at (created_at)
);
```

### 5.2 提现交易表 (withdrawal_txs)

```sql
CREATE TABLE withdrawal_txs (
    id              BIGSERIAL PRIMARY KEY,
    withdraw_id     VARCHAR(64) NOT NULL UNIQUE,

    -- 提现信息
    wallet_address  VARCHAR(42) NOT NULL,
    to_address      VARCHAR(42) NOT NULL,
    token           VARCHAR(20) NOT NULL,
    token_address   VARCHAR(42) NOT NULL,
    amount          DECIMAL(36, 18) NOT NULL,

    -- 链上信息
    chain_id        INT NOT NULL,
    tx_hash         VARCHAR(66),
    block_number    BIGINT,
    gas_used        BIGINT,

    -- 状态: 0=PENDING, 1=SUBMITTED, 2=CONFIRMED, 3=FAILED
    status          SMALLINT NOT NULL DEFAULT 0,
    error_message   VARCHAR(500),
    retry_count     INT NOT NULL DEFAULT 0,

    created_at      BIGINT NOT NULL,
    updated_at      BIGINT NOT NULL,

    INDEX idx_withdrawal_txs_wallet (wallet_address),
    INDEX idx_withdrawal_txs_status (status)
);
```

### 5.3 充值记录表 (deposit_records)

```sql
CREATE TABLE deposit_records (
    id              BIGSERIAL PRIMARY KEY,
    deposit_id      VARCHAR(64) NOT NULL UNIQUE,

    -- 用户信息
    wallet_address  VARCHAR(42) NOT NULL,

    -- 代币信息
    token           VARCHAR(20) NOT NULL,
    token_address   VARCHAR(42) NOT NULL,
    amount          DECIMAL(36, 18) NOT NULL,

    -- 链上信息
    chain_id        INT NOT NULL,
    tx_hash         VARCHAR(66) NOT NULL UNIQUE,
    block_number    BIGINT NOT NULL,
    block_hash      VARCHAR(66) NOT NULL,
    log_index       INT NOT NULL,

    -- 确认信息
    confirmations   INT NOT NULL DEFAULT 0,
    required_confirmations INT NOT NULL,

    -- 状态: 0=PENDING, 1=CONFIRMED, 2=CREDITED
    status          SMALLINT NOT NULL DEFAULT 0,
    credited_at     BIGINT,

    created_at      BIGINT NOT NULL,
    updated_at      BIGINT NOT NULL,

    INDEX idx_deposits_wallet (wallet_address),
    INDEX idx_deposits_tx (tx_hash),
    INDEX idx_deposits_status (status),
    INDEX idx_deposits_block (block_number)
);
```

### 5.4 区块检查点表 (block_checkpoints)

```sql
CREATE TABLE block_checkpoints (
    id              BIGSERIAL PRIMARY KEY,
    chain_id        INT NOT NULL,
    block_number    BIGINT NOT NULL,
    block_hash      VARCHAR(66) NOT NULL,
    processed_at    BIGINT NOT NULL,

    created_at      BIGINT NOT NULL,
    updated_at      BIGINT NOT NULL,

    UNIQUE (chain_id)
);
```

### 5.5 链上事件表 (chain_events)

```sql
CREATE TABLE chain_events (
    id              BIGSERIAL PRIMARY KEY,
    chain_id        INT NOT NULL,
    block_number    BIGINT NOT NULL,
    tx_hash         VARCHAR(66) NOT NULL,
    log_index       INT NOT NULL,
    event_type      VARCHAR(50) NOT NULL,         -- Deposit, Withdraw, Settlement
    event_data      JSONB NOT NULL,

    created_at      BIGINT NOT NULL,
    updated_at      BIGINT NOT NULL,

    UNIQUE (chain_id, tx_hash, log_index),
    INDEX idx_events_block (chain_id, block_number),
    INDEX idx_events_type (event_type)
);
```

### 5.6 回滚审计表 (settlement_rollback_logs)

```sql
CREATE TABLE settlement_rollback_logs (
    id              BIGSERIAL PRIMARY KEY,
    batch_id        VARCHAR(64) NOT NULL,

    -- 回滚内容
    trade_count     INT NOT NULL,
    affected_users  INT NOT NULL,
    total_base_amount   DECIMAL(36, 18) NOT NULL,
    total_quote_amount  DECIMAL(36, 18) NOT NULL,

    -- 原因与审批
    failure_reason  VARCHAR(500) NOT NULL,
    rollback_reason VARCHAR(500) NOT NULL,
    operator        VARCHAR(42) NOT NULL,
    approved_by     VARCHAR(42) NOT NULL,         -- 双人审批

    -- 时间
    rollback_at     BIGINT NOT NULL,

    -- 关联
    original_tx_hash VARCHAR(66),

    created_at      BIGINT NOT NULL,

    INDEX idx_rollback_batch (batch_id),
    INDEX idx_rollback_time (rollback_at)
);
```

### 5.7 对账记录表 (reconciliation_records)

```sql
CREATE TABLE reconciliation_records (
    id              BIGSERIAL PRIMARY KEY,

    wallet_address  VARCHAR(42) NOT NULL,
    token           VARCHAR(20) NOT NULL,

    -- 余额快照
    on_chain_balance    DECIMAL(36, 18) NOT NULL,
    off_chain_settled   DECIMAL(36, 18) NOT NULL,
    off_chain_available DECIMAL(36, 18) NOT NULL,
    off_chain_frozen    DECIMAL(36, 18) NOT NULL,
    pending_settle      DECIMAL(36, 18) NOT NULL,

    -- 差异
    difference      DECIMAL(36, 18) NOT NULL,

    -- 状态: OK, DISCREPANCY, RESOLVED, IGNORED
    status          VARCHAR(20) NOT NULL,
    resolution      VARCHAR(500),
    resolved_by     VARCHAR(42),
    resolved_at     BIGINT,

    -- 时间
    checked_at      BIGINT NOT NULL,
    created_at      BIGINT NOT NULL,

    INDEX idx_recon_wallet (wallet_address),
    INDEX idx_recon_status (status),
    INDEX idx_recon_checked (checked_at)
);
```

---

## 六、错误码

```go
const (
    // 结算相关
    ErrCodeSettlementPending     = "CHAIN_SETTLEMENT_PENDING"
    ErrCodeSettlementFailed      = "CHAIN_SETTLEMENT_FAILED"
    ErrCodeSettlementNotFound    = "CHAIN_SETTLEMENT_NOT_FOUND"
    ErrCodeBatchTooLarge         = "CHAIN_BATCH_TOO_LARGE"

    // 提现相关
    ErrCodeWithdrawPending       = "CHAIN_WITHDRAW_PENDING"
    ErrCodeWithdrawFailed        = "CHAIN_WITHDRAW_FAILED"
    ErrCodeInsufficientOnChain   = "CHAIN_INSUFFICIENT_BALANCE"

    // 充值相关
    ErrCodeDepositNotConfirmed   = "CHAIN_DEPOSIT_NOT_CONFIRMED"
    ErrCodeDepositAlreadyCredited = "CHAIN_DEPOSIT_ALREADY_CREDITED"

    // 链上相关
    ErrCodeGasInsufficient       = "CHAIN_GAS_INSUFFICIENT"
    ErrCodeNonceConflict         = "CHAIN_NONCE_CONFLICT"
    ErrCodeRPCError              = "CHAIN_RPC_ERROR"
    ErrCodeContractRevert        = "CHAIN_CONTRACT_REVERT"
)
```

---

## 七、配置

```yaml
service:
  name: eidos-chain
  grpc_port: 50054
  http_port: 8080

# 数据库
postgres:
  host: postgres
  port: 5432
  database: eidos_chain
  max_connections: 100

# Redis
redis:
  cluster:
    nodes:
      - redis-1:6379
      - redis-2:6379
      - redis-3:6379

# Kafka
kafka:
  brokers:
    - kafka-1:9092
    - kafka-2:9092
    - kafka-3:9092
  consumer:
    group_id: eidos-chain
    topics:
      - settlements
      - withdrawals
  producer:
    topics:
      deposits: deposits
      settlement_confirmed: settlement-confirmed
      withdrawal_confirmed: withdrawal-confirmed

# 区块链配置
blockchain:
  rpc_url: "https://arb-mainnet.g.alchemy.com/v2/xxx"
  backup_rpc_urls:
    - "https://arb1.arbitrum.io/rpc"
  chain_id: 42161
  contracts:
    vault: "0x..."
    exchange: "0x..."
  hot_wallet:
    address: "0x..."
    key_path: "/secrets/hot_wallet.key"
  gas:
    max_price: "50000000000"      # 50 Gwei
    limit_multiplier: 1.2

# Settlement 模块配置
settlement:
  batch_size: 100                 # 每批最多成交数
  batch_interval: 5s              # 最大等待时间
  retry_count: 3
  retry_delay: 10s
  limits:
    single_user_pending: "10000"  # 单用户待结算上限 USDC
    total_pending: "1000000"      # 全系统待结算上限 USDC

# Indexer 模块配置
indexer:
  start_block: 0                  # 0 = 从检查点或最新
  confirmations: 0                # 确认数 (Arbitrum 默认 0)
  poll_interval: 1s               # 轮询间隔
  checkpoint_interval: 100        # 检查点保存间隔 (区块数)
```

---

## 八、监控指标

```go
var (
    // Settlement 模块
    settlementBatchesTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "chain_settlement_batches_total",
            Help: "Total settlement batches",
        },
        []string{"status"},
    )

    settlementTradesTotal = prometheus.NewCounter(
        prometheus.CounterOpts{
            Name: "chain_settlement_trades_total",
            Help: "Total trades settled",
        },
    )

    settlementDuration = prometheus.NewHistogram(
        prometheus.HistogramOpts{
            Name:    "chain_settlement_duration_seconds",
            Help:    "Settlement batch processing duration",
            Buckets: []float64{1, 5, 10, 30, 60},
        },
    )

    withdrawalsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "chain_withdrawals_total",
            Help: "Total withdrawals processed",
        },
        []string{"status"},
    )

    // Indexer 模块
    depositsDetected = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "chain_deposits_detected_total",
            Help: "Total deposits detected",
        },
        []string{"token", "status"},
    )

    blockHeight = prometheus.NewGauge(
        prometheus.GaugeOpts{
            Name: "chain_indexer_block_height",
            Help: "Current indexed block height",
        },
    )

    indexerLag = prometheus.NewGauge(
        prometheus.GaugeOpts{
            Name: "chain_indexer_lag_blocks",
            Help: "Blocks behind latest",
        },
    )

    // 对账
    reconciliationDiscrepancies = prometheus.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "chain_reconciliation_discrepancies",
            Help: "Current discrepancy count",
        },
        []string{"token"},
    )

    // 链上交互
    rpcLatency = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "chain_rpc_latency_seconds",
            Help:    "RPC call latency",
            Buckets: []float64{0.1, 0.5, 1, 2, 5},
        },
        []string{"method"},
    )

    gasUsed = prometheus.NewHistogram(
        prometheus.HistogramOpts{
            Name:    "chain_gas_used",
            Help:    "Gas used per transaction",
            Buckets: []float64{50000, 100000, 200000, 500000, 1000000},
        },
    )

    // Nonce 管理
    nonceConflicts = prometheus.NewCounter(
        prometheus.CounterOpts{
            Name: "chain_nonce_conflicts_total",
            Help: "Total nonce conflicts detected",
        },
    )

    // RPC 健康
    rpcHealthy = prometheus.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "chain_rpc_healthy",
            Help: "RPC endpoint health status",
        },
        []string{"endpoint"},
    )
)
```

---

## 九、Nonce 管理策略

### 9.1 问题分析

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Nonce 并发竞争问题                                    │
│                                                                              │
│  场景: 批量结算和提现同时使用热钱包                                          │
│                                                                              │
│  时间线:                                                                     │
│  ────────                                                                    │
│  t1: 结算模块获取 nonce=100，构造交易                                        │
│  t2: 提现模块获取 nonce=100，构造交易 (竞争!)                                │
│  t3: 结算交易广播 nonce=100 ✓                                                │
│  t4: 提现交易广播 nonce=100 ✗ (nonce already used)                           │
│                                                                              │
│  影响:                                                                       │
│  ──────                                                                      │
│  - 提现交易失败，需要重试                                                    │
│  - 用户体验差，提现延迟                                                      │
│  - 严重时可能导致交易队列阻塞                                                │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 9.2 解决方案：分布式 Nonce 管理器

```go
// Nonce 管理器接口
type NonceManager interface {
    // 获取并锁定 nonce
    AcquireNonce(ctx context.Context) (uint64, func(), error)

    // 确认 nonce 使用成功
    ConfirmNonce(ctx context.Context, nonce uint64) error

    // 释放未使用的 nonce (回滚)
    ReleaseNonce(ctx context.Context, nonce uint64) error

    // 同步链上 nonce
    SyncFromChain(ctx context.Context) error
}

// Redis 实现的分布式 Nonce 管理器
type RedisNonceManager struct {
    redis   *redis.Client
    wallet  string
    client  *ethclient.Client
    mu      sync.Mutex
}

const (
    nonceKey       = "eidos:chain:nonce:{wallet}"
    nonceLockKey   = "eidos:chain:nonce_lock:{wallet}"
    nonceLockTTL   = 30 * time.Second
)

// 获取并锁定 nonce
func (m *RedisNonceManager) AcquireNonce(ctx context.Context) (uint64, func(), error) {
    // 1. 获取分布式锁
    lockKey := fmt.Sprintf(nonceLockKey, m.wallet)
    lock, err := m.redis.SetNX(ctx, lockKey, "1", nonceLockTTL).Result()
    if err != nil {
        return 0, nil, fmt.Errorf("failed to acquire lock: %w", err)
    }
    if !lock {
        return 0, nil, ErrNonceLockContention
    }

    // 2. 获取当前 nonce
    key := fmt.Sprintf(nonceKey, m.wallet)
    nonce, err := m.redis.Incr(ctx, key).Result()
    if err != nil {
        m.redis.Del(ctx, lockKey)
        return 0, nil, fmt.Errorf("failed to get nonce: %w", err)
    }

    // 3. 返回释放函数
    release := func() {
        m.redis.Del(ctx, lockKey)
    }

    return uint64(nonce - 1), release, nil
}

// 确认 nonce 使用成功
func (m *RedisNonceManager) ConfirmNonce(ctx context.Context, nonce uint64) error {
    // 交易成功后调用，nonce 已被使用
    // 这里可以记录日志或更新统计
    log.Info("Nonce confirmed", "wallet", m.wallet, "nonce", nonce)
    return nil
}

// 释放未使用的 nonce (交易失败时回滚)
func (m *RedisNonceManager) ReleaseNonce(ctx context.Context, nonce uint64) error {
    key := fmt.Sprintf(nonceKey, m.wallet)

    // 只有当前 nonce 等于预期时才回滚
    script := `
        local current = tonumber(redis.call('GET', KEYS[1]))
        if current and current == tonumber(ARGV[1]) + 1 then
            redis.call('DECR', KEYS[1])
            return 1
        end
        return 0
    `

    result, err := m.redis.Eval(ctx, script, []string{key}, nonce).Int()
    if err != nil {
        return fmt.Errorf("failed to release nonce: %w", err)
    }

    if result == 0 {
        // 有其他交易使用了更新的 nonce，无法回滚
        log.Warn("Could not release nonce, newer nonce in use",
            "wallet", m.wallet, "nonce", nonce)
    }

    return nil
}

// 从链上同步 nonce (启动时或检测到不一致时)
func (m *RedisNonceManager) SyncFromChain(ctx context.Context) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    // 获取链上 nonce
    onChainNonce, err := m.client.PendingNonceAt(ctx, common.HexToAddress(m.wallet))
    if err != nil {
        return fmt.Errorf("failed to get on-chain nonce: %w", err)
    }

    // 更新 Redis
    key := fmt.Sprintf(nonceKey, m.wallet)
    err = m.redis.Set(ctx, key, onChainNonce, 0).Err()
    if err != nil {
        return fmt.Errorf("failed to sync nonce: %w", err)
    }

    log.Info("Nonce synced from chain", "wallet", m.wallet, "nonce", onChainNonce)
    return nil
}
```

### 9.3 使用方式

```go
// 在发送交易时使用
func (s *SettlementService) sendTransaction(ctx context.Context, tx *types.Transaction) error {
    // 1. 获取 nonce
    nonce, release, err := s.nonceManager.AcquireNonce(ctx)
    if err != nil {
        if errors.Is(err, ErrNonceLockContention) {
            // 等待重试
            time.Sleep(100 * time.Millisecond)
            return s.sendTransaction(ctx, tx)
        }
        return err
    }
    defer release()

    // 2. 设置 nonce
    tx = types.NewTx(&types.DynamicFeeTx{
        Nonce:     nonce,
        // ... 其他字段
    })

    // 3. 签名并发送
    signedTx, err := s.signTransaction(tx)
    if err != nil {
        s.nonceManager.ReleaseNonce(ctx, nonce)
        return err
    }

    err = s.client.SendTransaction(ctx, signedTx)
    if err != nil {
        // 检查是否是 nonce 错误
        if isNonceError(err) {
            s.nonceManager.SyncFromChain(ctx)
            s.nonceManager.ReleaseNonce(ctx, nonce)
            return ErrNonceConflict
        }
        return err
    }

    // 4. 确认 nonce
    s.nonceManager.ConfirmNonce(ctx, nonce)

    return nil
}

func isNonceError(err error) bool {
    errStr := err.Error()
    return strings.Contains(errStr, "nonce too low") ||
           strings.Contains(errStr, "nonce too high") ||
           strings.Contains(errStr, "replacement transaction underpriced")
}
```

### 9.4 Nonce 异常处理

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Nonce 异常处理流程                                    │
│                                                                              │
│  异常类型及处理:                                                             │
│  ════════════════                                                            │
│                                                                              │
│  1. Nonce too low (链上 nonce > 本地 nonce)                                  │
│     原因: 有其他客户端使用了该钱包                                           │
│     处理: 从链上同步 nonce，重新发送                                         │
│                                                                              │
│  2. Nonce too high (链上 nonce < 本地 nonce)                                 │
│     原因: 之前的交易失败/未广播                                              │
│     处理: 发送空交易填补 nonce 缺口，或等待                                  │
│                                                                              │
│  3. Replacement transaction underpriced                                      │
│     原因: 相同 nonce 的交易已在 pending                                      │
│     处理: 增加 gas price 替换，或等待原交易完成                              │
│                                                                              │
│  4. Lock contention                                                          │
│     原因: 另一个进程正在使用 nonce                                           │
│     处理: 等待 + 指数退避重试                                                │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

```go
// Nonce 异常处理
func (s *SettlementService) handleNonceError(ctx context.Context, err error, nonce uint64) error {
    errStr := err.Error()

    switch {
    case strings.Contains(errStr, "nonce too low"):
        // 同步链上 nonce
        if syncErr := s.nonceManager.SyncFromChain(ctx); syncErr != nil {
            return fmt.Errorf("failed to sync nonce: %w", syncErr)
        }
        s.metrics.nonceConflicts.Inc()
        return ErrRetryable

    case strings.Contains(errStr, "nonce too high"):
        // 检查是否需要填补缺口
        onChainNonce, _ := s.client.PendingNonceAt(ctx, s.hotWallet)
        if nonce > onChainNonce+10 {
            // 缺口太大，同步 nonce
            s.nonceManager.SyncFromChain(ctx)
            return ErrRetryable
        }
        // 等待之前的交易完成
        return ErrPendingTransaction

    case strings.Contains(errStr, "replacement transaction underpriced"):
        // 需要更高 gas price 替换
        return ErrNeedsGasBoost

    default:
        return err
    }
}
```

---

## 十、热钱包安全设计

### 10.1 安全架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        热钱包安全架构                                        │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                        密钥管理层                                    │    │
│  │                                                                      │    │
│  │  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐          │    │
│  │  │   AWS KMS    │    │   Vault      │    │   HSM        │          │    │
│  │  │  (推荐生产)  │    │   (可选)     │    │  (最高安全) │          │    │
│  │  └──────────────┘    └──────────────┘    └──────────────┘          │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                              │                                              │
│                              ▼                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                        签名服务层                                    │    │
│  │                                                                      │    │
│  │  - 密钥永不离开 KMS/HSM                                             │    │
│  │  - 仅对交易哈希签名                                                 │    │
│  │  - 支持签名审批流程                                                 │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                              │                                              │
│                              ▼                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                        风控层                                        │    │
│  │                                                                      │    │
│  │  - 单笔交易限额                                                     │    │
│  │  - 每日累计限额                                                     │    │
│  │  - 异常交易检测                                                     │    │
│  │  - 大额交易多签审批                                                 │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 10.2 AWS KMS 集成

```go
// KMS 签名器接口
type KMSSigner struct {
    kmsClient *kms.Client
    keyID     string
    address   common.Address
    chainID   *big.Int
}

func NewKMSSigner(cfg *config.KMSConfig) (*KMSSigner, error) {
    sess := session.Must(session.NewSession())
    client := kms.New(sess, aws.NewConfig().WithRegion(cfg.Region))

    // 获取公钥并计算地址
    pubKeyOutput, err := client.GetPublicKey(&kms.GetPublicKeyInput{
        KeyId: aws.String(cfg.KeyID),
    })
    if err != nil {
        return nil, fmt.Errorf("failed to get public key: %w", err)
    }

    address, err := publicKeyToAddress(pubKeyOutput.PublicKey)
    if err != nil {
        return nil, err
    }

    return &KMSSigner{
        kmsClient: client,
        keyID:     cfg.KeyID,
        address:   address,
        chainID:   big.NewInt(cfg.ChainID),
    }, nil
}

// 签名交易
func (s *KMSSigner) SignTransaction(tx *types.Transaction) (*types.Transaction, error) {
    // 1. 获取交易哈希
    signer := types.LatestSignerForChainID(s.chainID)
    txHash := signer.Hash(tx)

    // 2. 使用 KMS 签名
    signOutput, err := s.kmsClient.Sign(&kms.SignInput{
        KeyId:            aws.String(s.keyID),
        Message:          txHash.Bytes(),
        MessageType:      aws.String("DIGEST"),
        SigningAlgorithm: aws.String("ECDSA_SHA_256"),
    })
    if err != nil {
        return nil, fmt.Errorf("KMS sign failed: %w", err)
    }

    // 3. 解析 DER 签名并转换为以太坊格式
    signature, err := derToEthSignature(signOutput.Signature, txHash, s.address)
    if err != nil {
        return nil, err
    }

    // 4. 组装签名后的交易
    signedTx, err := tx.WithSignature(signer, signature)
    if err != nil {
        return nil, err
    }

    return signedTx, nil
}

// 验证交易发送者
func (s *KMSSigner) VerifySender(tx *types.Transaction) bool {
    signer := types.LatestSignerForChainID(s.chainID)
    sender, err := types.Sender(signer, tx)
    if err != nil {
        return false
    }
    return sender == s.address
}
```

### 10.3 多签机制

```go
// 多签配置
type MultiSigConfig struct {
    Threshold       int      `yaml:"threshold"`        // 签名阈值 (如: 2/3)
    Signers         []string `yaml:"signers"`          // 授权签名者地址
    LargeAmountUSD  string   `yaml:"large_amount"`     // 大额阈值
}

// 多签管理器
type MultiSigManager struct {
    config   *MultiSigConfig
    contract *SafeContract  // Gnosis Safe 合约
}

// 判断是否需要多签
func (m *MultiSigManager) RequiresMultiSig(amount *big.Int, token string) bool {
    threshold, _ := new(big.Int).SetString(m.config.LargeAmountUSD, 10)

    // 转换为 USD
    amountUSD := m.toUSD(amount, token)

    return amountUSD.Cmp(threshold) >= 0
}

// 发起多签提案
func (m *MultiSigManager) ProposeTransaction(
    ctx context.Context,
    to common.Address,
    value *big.Int,
    data []byte,
) (string, error) {
    // 1. 计算交易哈希
    txHash := m.contract.GetTransactionHash(to, value, data)

    // 2. 存储提案
    proposal := &MultiSigProposal{
        ID:        uuid.New().String(),
        TxHash:    txHash.Hex(),
        To:        to.Hex(),
        Value:     value.String(),
        Data:      hexutil.Encode(data),
        Status:    "pending",
        Approvals: []string{},
        CreatedAt: time.Now().Unix(),
    }

    err := m.storeProposal(ctx, proposal)
    if err != nil {
        return "", err
    }

    // 3. 发送审批通知
    m.notifySigners(proposal)

    return proposal.ID, nil
}

// 审批提案
func (m *MultiSigManager) ApproveProposal(
    ctx context.Context,
    proposalID string,
    signer string,
    signature []byte,
) error {
    proposal, err := m.getProposal(ctx, proposalID)
    if err != nil {
        return err
    }

    // 验证签名者授权
    if !m.isAuthorizedSigner(signer) {
        return ErrUnauthorizedSigner
    }

    // 验证签名
    txHash := common.HexToHash(proposal.TxHash)
    if !m.verifySignature(txHash, signer, signature) {
        return ErrInvalidSignature
    }

    // 添加审批
    proposal.Approvals = append(proposal.Approvals, signer)
    proposal.Signatures = append(proposal.Signatures, hexutil.Encode(signature))

    // 检查是否达到阈值
    if len(proposal.Approvals) >= m.config.Threshold {
        proposal.Status = "ready"
    }

    return m.updateProposal(ctx, proposal)
}

// 执行已批准的提案
func (m *MultiSigManager) ExecuteProposal(ctx context.Context, proposalID string) error {
    proposal, err := m.getProposal(ctx, proposalID)
    if err != nil {
        return err
    }

    if proposal.Status != "ready" {
        return ErrProposalNotReady
    }

    // 组装签名
    signatures := m.combineSignatures(proposal.Signatures)

    // 调用 Safe 合约执行
    tx, err := m.contract.ExecTransaction(
        common.HexToAddress(proposal.To),
        new(big.Int).SetString(proposal.Value, 10),
        common.FromHex(proposal.Data),
        signatures,
    )
    if err != nil {
        return err
    }

    proposal.Status = "executed"
    proposal.TxHash = tx.Hash().Hex()
    return m.updateProposal(ctx, proposal)
}
```

### 10.4 热钱包余额监控

```go
// 热钱包余额监控
type WalletMonitor struct {
    client    *ethclient.Client
    wallet    common.Address
    alerter   Alerter
    config    *WalletConfig
}

// 检查余额
func (m *WalletMonitor) CheckBalance(ctx context.Context) error {
    // 1. 检查 ETH 余额 (用于 gas)
    ethBalance, err := m.client.BalanceAt(ctx, m.wallet, nil)
    if err != nil {
        return err
    }

    minETH, _ := new(big.Int).SetString(m.config.MinETHBalance, 10)
    if ethBalance.Cmp(minETH) < 0 {
        m.alerter.Alert(AlertLevelCritical, "Hot wallet ETH low",
            map[string]string{
                "wallet":  m.wallet.Hex(),
                "balance": ethBalance.String(),
                "minimum": minETH.String(),
            })
    }

    // 2. 检查代币余额
    for _, token := range m.config.Tokens {
        balance, err := m.getTokenBalance(ctx, token.Address)
        if err != nil {
            continue
        }

        minBalance, _ := new(big.Int).SetString(token.MinBalance, 10)
        if balance.Cmp(minBalance) < 0 {
            m.alerter.Alert(AlertLevelWarning, "Hot wallet token low",
                map[string]string{
                    "wallet":  m.wallet.Hex(),
                    "token":   token.Symbol,
                    "balance": balance.String(),
                    "minimum": minBalance.String(),
                })
        }
    }

    return nil
}

// 定期监控任务
func (m *WalletMonitor) StartMonitoring(ctx context.Context) {
    ticker := time.NewTicker(5 * time.Minute)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            if err := m.CheckBalance(ctx); err != nil {
                log.Error("Failed to check wallet balance", "error", err)
            }
        }
    }
}
```

---

## 十一、提现签名验证增强

### 11.1 完整签名验证

```go
// 提现请求结构
type WithdrawRequest struct {
    Wallet    string `json:"wallet"`
    Token     string `json:"token"`
    Amount    string `json:"amount"`
    ToAddress string `json:"to_address"`
    Nonce     uint64 `json:"nonce"`
    Signature string `json:"signature"`  // hex encoded
}

// EIP-712 提现类型定义
const WithdrawTypeName = "Withdraw"
var WithdrawType = []apitypes.Type{
    {Name: "wallet", Type: "address"},
    {Name: "token", Type: "string"},
    {Name: "amount", Type: "uint256"},
    {Name: "toAddress", Type: "address"},
    {Name: "nonce", Type: "uint256"},
}

// 增强的签名验证
func (s *ChainService) verifyWithdrawSignature(req *WithdrawRequest) error {
    // 1. 构建 EIP-712 消息
    typedData := apitypes.TypedData{
        Types: apitypes.Types{
            "EIP712Domain": []apitypes.Type{
                {Name: "name", Type: "string"},
                {Name: "version", Type: "string"},
                {Name: "chainId", Type: "uint256"},
                {Name: "verifyingContract", Type: "address"},
            },
            WithdrawTypeName: WithdrawType,
        },
        PrimaryType: WithdrawTypeName,
        Domain: apitypes.TypedDataDomain{
            Name:              "EidosExchange",
            Version:           "1",
            ChainId:           math.NewHexOrDecimal256(s.chainID),
            VerifyingContract: s.exchangeContract.Hex(),
        },
        Message: map[string]interface{}{
            "wallet":    req.Wallet,
            "token":     req.Token,
            "amount":    req.Amount,
            "toAddress": req.ToAddress,
            "nonce":     fmt.Sprintf("%d", req.Nonce),
        },
    }

    // 2. 计算消息哈希
    domainSeparator, err := typedData.HashStruct("EIP712Domain", typedData.Domain.Map())
    if err != nil {
        return fmt.Errorf("failed to hash domain: %w", err)
    }

    messageHash, err := typedData.HashStruct(WithdrawTypeName, typedData.Message)
    if err != nil {
        return fmt.Errorf("failed to hash message: %w", err)
    }

    // \x19\x01 + domainSeparator + messageHash
    rawData := append([]byte("\x19\x01"), domainSeparator...)
    rawData = append(rawData, messageHash...)
    digest := crypto.Keccak256Hash(rawData)

    // 3. 恢复签名者地址
    signature := common.FromHex(req.Signature)
    if len(signature) != 65 {
        return ErrInvalidSignatureLength
    }

    // 调整 v 值
    if signature[64] >= 27 {
        signature[64] -= 27
    }

    pubKey, err := crypto.Ecrecover(digest.Bytes(), signature)
    if err != nil {
        return fmt.Errorf("failed to recover public key: %w", err)
    }

    recoveredAddr := common.BytesToAddress(crypto.Keccak256(pubKey[1:])[12:])

    // 4. 验证签名者是否为请求的钱包
    if !strings.EqualFold(recoveredAddr.Hex(), req.Wallet) {
        return ErrSignerMismatch
    }

    return nil
}
```

### 11.2 幂等键增强

```go
// 使用签名内容哈希作为幂等键
func (s *ChainService) getWithdrawIdempotencyKey(req *WithdrawRequest) string {
    // 包含完整请求内容的哈希
    data := fmt.Sprintf("%s:%s:%s:%s:%d:%s",
        strings.ToLower(req.Wallet),
        strings.ToLower(req.Token),
        req.Amount,
        strings.ToLower(req.ToAddress),
        req.Nonce,
        req.Signature,
    )
    hash := crypto.Keccak256Hash([]byte(data))
    return hash.Hex()
}

// 处理提现请求
func (s *ChainService) processWithdraw(ctx context.Context, req *WithdrawRequest) error {
    // 1. 计算幂等键
    idempotencyKey := s.getWithdrawIdempotencyKey(req)

    // 2. 检查是否已处理
    exists, err := s.redis.Exists(ctx, "withdraw:processed:"+idempotencyKey).Result()
    if err != nil {
        return err
    }
    if exists > 0 {
        log.Info("Withdraw already processed (idempotent)", "key", idempotencyKey)
        return nil
    }

    // 3. 验证签名
    if err := s.verifyWithdrawSignature(req); err != nil {
        return fmt.Errorf("signature verification failed: %w", err)
    }

    // 4. 验证 nonce 未使用 (用户级别)
    nonceKey := fmt.Sprintf("withdraw:nonce:%s", strings.ToLower(req.Wallet))
    lastNonce, _ := s.redis.Get(ctx, nonceKey).Uint64()
    if req.Nonce <= lastNonce {
        return ErrNonceAlreadyUsed
    }

    // 5. 执行提现...
    // ...

    // 6. 标记已处理
    s.redis.Set(ctx, "withdraw:processed:"+idempotencyKey, "1", 7*24*time.Hour)
    s.redis.Set(ctx, nonceKey, req.Nonce, 0)

    return nil
}
```

---

## 十二、结算批次拆分策略

### 12.1 拆分策略

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        结算批次拆分策略                                      │
│                                                                              │
│  触发条件: 批量结算合约调用 revert                                          │
│                                                                              │
│  拆分策略:                                                                   │
│  ══════════                                                                  │
│                                                                              │
│  1. 二分拆分 (默认策略)                                                      │
│     ─────────────────────                                                    │
│     原批次: [T1, T2, T3, T4, T5, T6, T7, T8]  → revert                      │
│     拆分: [T1, T2, T3, T4] + [T5, T6, T7, T8]                               │
│     继续: [T1, T2] + [T3, T4] ...                                           │
│     直到找到问题交易                                                        │
│                                                                              │
│  2. 逐条处理 (最后手段)                                                      │
│     ─────────────────────                                                    │
│     当二分后批次仍失败时，逐条提交                                          │
│     成功的标记已结算，失败的标记需人工处理                                  │
│                                                                              │
│  3. 快速失败检测                                                             │
│     ─────────────────────                                                    │
│     调用前先用 eth_call 模拟执行                                            │
│     提前发现问题，避免浪费 gas                                              │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 12.2 实现

```go
// 批量结算处理器
type BatchSettler struct {
    contract  *SettlementContract
    minBatch  int  // 最小批次大小
    maxRetry  int  // 最大重试次数
}

// 结算批次，支持自动拆分
func (s *BatchSettler) SettleBatch(ctx context.Context, trades []*Trade) (*SettlementResult, error) {
    result := &SettlementResult{
        TotalTrades:   len(trades),
        SuccessTrades: make([]*Trade, 0),
        FailedTrades:  make([]*Trade, 0),
    }

    // 使用队列处理
    queue := []([]*Trade){trades}

    for len(queue) > 0 {
        batch := queue[0]
        queue = queue[1:]

        // 1. 先用 eth_call 模拟
        err := s.simulateBatch(ctx, batch)
        if err == nil {
            // 模拟成功，真正执行
            if err := s.executeBatch(ctx, batch); err != nil {
                // 执行失败，尝试拆分
                if len(batch) > s.minBatch {
                    mid := len(batch) / 2
                    queue = append(queue, batch[:mid], batch[mid:])
                    continue
                }
                // 无法再拆分，标记失败
                result.FailedTrades = append(result.FailedTrades, batch...)
                continue
            }
            result.SuccessTrades = append(result.SuccessTrades, batch...)
            continue
        }

        // 2. 模拟失败，尝试拆分
        if len(batch) > s.minBatch {
            mid := len(batch) / 2
            queue = append(queue, batch[:mid], batch[mid:])
        } else if len(batch) > 1 {
            // 逐条处理
            for _, trade := range batch {
                if err := s.executeOne(ctx, trade); err != nil {
                    result.FailedTrades = append(result.FailedTrades, trade)
                } else {
                    result.SuccessTrades = append(result.SuccessTrades, trade)
                }
            }
        } else {
            // 单条也失败
            result.FailedTrades = append(result.FailedTrades, batch...)
        }
    }

    return result, nil
}

// 模拟批量执行
func (s *BatchSettler) simulateBatch(ctx context.Context, trades []*Trade) error {
    // 构建调用数据
    data, err := s.contract.abi.Pack("settleBatch", tradesToParams(trades))
    if err != nil {
        return err
    }

    // eth_call 模拟
    msg := ethereum.CallMsg{
        To:   &s.contract.address,
        Data: data,
    }

    _, err = s.client.CallContract(ctx, msg, nil)
    return err
}

// 分析失败原因
func (s *BatchSettler) analyzeFailure(ctx context.Context, trade *Trade, err error) *FailureAnalysis {
    analysis := &FailureAnalysis{
        TradeID: trade.TradeID,
        Error:   err.Error(),
    }

    // 解析 revert 原因
    if revertErr, ok := err.(*revert.Error); ok {
        analysis.RevertReason = revertErr.Reason
    }

    // 常见失败原因
    switch {
    case strings.Contains(err.Error(), "insufficient balance"):
        analysis.Reason = "用户余额不足"
        analysis.Suggestion = "检查用户链上余额"
    case strings.Contains(err.Error(), "already settled"):
        analysis.Reason = "重复结算"
        analysis.Suggestion = "已结算，标记完成"
    case strings.Contains(err.Error(), "invalid signature"):
        analysis.Reason = "签名无效"
        analysis.Suggestion = "检查签名数据"
    default:
        analysis.Reason = "未知错误"
        analysis.Suggestion = "需人工分析"
    }

    return analysis
}
```

---

## 十三、RPC 故障切换机制

### 13.1 RPC 健康检查

```go
// RPC 客户端池
type RPCClientPool struct {
    clients    []*RPCEndpoint
    current    int
    mu         sync.RWMutex
    healthTick *time.Ticker
}

type RPCEndpoint struct {
    URL       string
    Client    *ethclient.Client
    IsHealthy bool
    Latency   time.Duration
    LastCheck time.Time
    FailCount int
}

const (
    HealthCheckInterval = 30 * time.Second
    MaxFailCount        = 3
    HealthTimeout       = 5 * time.Second
)

// 创建客户端池
func NewRPCClientPool(urls []string) (*RPCClientPool, error) {
    pool := &RPCClientPool{
        clients: make([]*RPCEndpoint, 0, len(urls)),
    }

    for _, url := range urls {
        client, err := ethclient.Dial(url)
        if err != nil {
            log.Warn("Failed to connect to RPC", "url", url, "error", err)
            continue
        }

        pool.clients = append(pool.clients, &RPCEndpoint{
            URL:       url,
            Client:    client,
            IsHealthy: true,
        })
    }

    if len(pool.clients) == 0 {
        return nil, ErrNoHealthyRPC
    }

    // 启动健康检查
    pool.startHealthCheck()

    return pool, nil
}

// 获取健康的客户端
func (p *RPCClientPool) GetClient() (*ethclient.Client, error) {
    p.mu.RLock()
    defer p.mu.RUnlock()

    // 优先使用延迟最低的健康节点
    var best *RPCEndpoint
    for _, ep := range p.clients {
        if !ep.IsHealthy {
            continue
        }
        if best == nil || ep.Latency < best.Latency {
            best = ep
        }
    }

    if best == nil {
        return nil, ErrNoHealthyRPC
    }

    return best.Client, nil
}

// 健康检查
func (p *RPCClientPool) startHealthCheck() {
    p.healthTick = time.NewTicker(HealthCheckInterval)

    go func() {
        for range p.healthTick.C {
            p.checkAllEndpoints()
        }
    }()
}

func (p *RPCClientPool) checkAllEndpoints() {
    for _, ep := range p.clients {
        go p.checkEndpoint(ep)
    }
}

func (p *RPCClientPool) checkEndpoint(ep *RPCEndpoint) {
    ctx, cancel := context.WithTimeout(context.Background(), HealthTimeout)
    defer cancel()

    start := time.Now()
    _, err := ep.Client.BlockNumber(ctx)
    latency := time.Since(start)

    p.mu.Lock()
    defer p.mu.Unlock()

    ep.LastCheck = time.Now()
    ep.Latency = latency

    if err != nil {
        ep.FailCount++
        if ep.FailCount >= MaxFailCount {
            ep.IsHealthy = false
            log.Warn("RPC endpoint marked unhealthy", "url", ep.URL, "fails", ep.FailCount)
            rpcHealthy.WithLabelValues(ep.URL).Set(0)
        }
    } else {
        ep.FailCount = 0
        ep.IsHealthy = true
        rpcHealthy.WithLabelValues(ep.URL).Set(1)
    }
}

// 标记调用失败
func (p *RPCClientPool) ReportFailure(client *ethclient.Client) {
    p.mu.Lock()
    defer p.mu.Unlock()

    for _, ep := range p.clients {
        if ep.Client == client {
            ep.FailCount++
            if ep.FailCount >= MaxFailCount {
                ep.IsHealthy = false
                log.Warn("RPC endpoint marked unhealthy after failure", "url", ep.URL)
            }
            break
        }
    }
}
```

### 13.2 自动重试与切换

```go
// 带自动重试和切换的 RPC 调用
func (s *ChainService) callWithRetry(
    ctx context.Context,
    method string,
    call func(*ethclient.Client) error,
) error {
    var lastErr error

    for attempt := 0; attempt < 3; attempt++ {
        client, err := s.rpcPool.GetClient()
        if err != nil {
            return fmt.Errorf("no healthy RPC: %w", err)
        }

        err = call(client)
        if err == nil {
            return nil
        }

        lastErr = err

        // 判断错误类型
        if isRetryableError(err) {
            s.rpcPool.ReportFailure(client)
            log.Warn("RPC call failed, retrying",
                "method", method,
                "attempt", attempt+1,
                "error", err)
            time.Sleep(time.Duration(attempt+1) * 100 * time.Millisecond)
            continue
        }

        // 非可重试错误，直接返回
        return err
    }

    return fmt.Errorf("RPC call failed after retries: %w", lastErr)
}

func isRetryableError(err error) bool {
    errStr := err.Error()
    return strings.Contains(errStr, "connection refused") ||
           strings.Contains(errStr, "timeout") ||
           strings.Contains(errStr, "EOF") ||
           strings.Contains(errStr, "429") ||  // rate limited
           strings.Contains(errStr, "503")     // service unavailable
}
```

---

## 十四、Proto 定义

### 14.1 gRPC 服务定义

```protobuf
syntax = "proto3";

package eidos.chain.v1;

option go_package = "github.com/eidos/chain/v1;chainv1";

// 链上服务
service ChainService {
    // Settlement 模块
    rpc GetSettlementStatus(GetSettlementStatusRequest) returns (GetSettlementStatusResponse);
    rpc GetPendingSettlements(GetPendingSettlementsRequest) returns (GetPendingSettlementsResponse);
    rpc RetrySettlement(RetrySettlementRequest) returns (RetrySettlementResponse);

    // Indexer 模块
    rpc GetDepositStatus(GetDepositStatusRequest) returns (GetDepositStatusResponse);
    rpc GetIndexerStatus(GetIndexerStatusRequest) returns (GetIndexerStatusResponse);

    // 提现模块
    rpc GetWithdrawalStatus(GetWithdrawalStatusRequest) returns (GetWithdrawalStatusResponse);
    rpc GetPendingWithdrawals(GetPendingWithdrawalsRequest) returns (GetPendingWithdrawalsResponse);

    // 对账模块
    rpc TriggerReconciliation(TriggerReconciliationRequest) returns (TriggerReconciliationResponse);
    rpc GetReconciliationStatus(GetReconciliationStatusRequest) returns (GetReconciliationStatusResponse);

    // 热钱包
    rpc GetWalletBalance(GetWalletBalanceRequest) returns (GetWalletBalanceResponse);
}

// ================== Settlement ==================

message GetSettlementStatusRequest {
    string batch_id = 1;
}

message GetSettlementStatusResponse {
    string batch_id = 1;
    string status = 2;              // pending, submitted, confirmed, failed
    int32 trade_count = 3;
    string tx_hash = 4;
    int64 created_at = 5;
    int64 confirmed_at = 6;
    string error_message = 7;
}

message GetPendingSettlementsRequest {
    int32 limit = 1;
    string cursor = 2;
}

message GetPendingSettlementsResponse {
    repeated SettlementBatch batches = 1;
    string next_cursor = 2;
    bool has_more = 3;
}

message SettlementBatch {
    string batch_id = 1;
    int32 trade_count = 2;
    string total_volume = 3;
    string status = 4;
    int64 created_at = 5;
}

message RetrySettlementRequest {
    string batch_id = 1;
}

message RetrySettlementResponse {
    bool success = 1;
    string message = 2;
}

// ================== Indexer ==================

message GetDepositStatusRequest {
    string tx_hash = 1;
}

message GetDepositStatusResponse {
    string tx_hash = 1;
    string wallet = 2;
    string token = 3;
    string amount = 4;
    string status = 5;              // detected, confirmed, credited
    int64 block_number = 6;
    int64 detected_at = 7;
    int64 credited_at = 8;
}

message GetIndexerStatusRequest {}

message GetIndexerStatusResponse {
    int64 current_block = 1;
    int64 latest_block = 2;
    int64 lag = 3;
    int64 last_checkpoint_block = 4;
    string status = 5;              // syncing, synced, stalled
}

// ================== Withdrawal ==================

message GetWithdrawalStatusRequest {
    string withdraw_id = 1;
}

message GetWithdrawalStatusResponse {
    string withdraw_id = 1;
    string wallet = 2;
    string to_address = 3;
    string token = 4;
    string amount = 5;
    string status = 6;              // pending, processing, submitted, confirmed, failed
    string tx_hash = 7;
    int64 created_at = 8;
    int64 confirmed_at = 9;
    string error_message = 10;
}

message GetPendingWithdrawalsRequest {
    int32 limit = 1;
    string cursor = 2;
}

message GetPendingWithdrawalsResponse {
    repeated Withdrawal withdrawals = 1;
    string next_cursor = 2;
    bool has_more = 3;
}

message Withdrawal {
    string withdraw_id = 1;
    string wallet = 2;
    string to_address = 3;
    string token = 4;
    string amount = 5;
    string status = 6;
    int64 created_at = 7;
}

// ================== Reconciliation ==================

message TriggerReconciliationRequest {
    string type = 1;                // realtime, hourly, daily, full
    repeated string tokens = 2;     // 空 = 所有代币
}

message TriggerReconciliationResponse {
    string job_id = 1;
    string status = 2;
}

message GetReconciliationStatusRequest {
    string job_id = 1;
}

message GetReconciliationStatusResponse {
    string job_id = 1;
    string status = 2;              // running, completed, failed
    repeated TokenReconciliation results = 3;
    int64 started_at = 4;
    int64 completed_at = 5;
}

message TokenReconciliation {
    string token = 1;
    string on_chain_balance = 2;
    string off_chain_balance = 3;
    string pending_settlements = 4;
    string pending_withdrawals = 5;
    string discrepancy = 6;
    bool is_balanced = 7;
}

// ================== Wallet ==================

message GetWalletBalanceRequest {
    string wallet_type = 1;         // hot, cold, fee
}

message GetWalletBalanceResponse {
    string address = 1;
    repeated TokenBalance balances = 2;
}

message TokenBalance {
    string token = 1;
    string symbol = 2;
    string balance = 3;
    int32 decimals = 4;
}
```

### 14.2 Kafka 消息格式

```protobuf
// 结算消息 (topic: settlements)
message SettlementMessage {
    string trade_id = 1;
    string maker = 2;
    string taker = 3;
    string market = 4;
    string price = 5;
    string size = 6;
    string maker_token = 7;         // maker 获得的代币
    string maker_amount = 8;        // maker 获得的金额
    string taker_token = 9;         // taker 获得的代币
    string taker_amount = 10;       // taker 获得的金额
    string maker_fee = 11;
    string taker_fee = 12;
    int64 traded_at = 13;
}

// 提现消息 (topic: withdrawals)
message WithdrawalMessage {
    string withdraw_id = 1;
    string wallet = 2;
    string to_address = 3;
    string token = 4;
    string amount = 5;
    uint64 nonce = 6;
    string signature = 7;
    int64 created_at = 8;
}

// 充值事件 (topic: deposits)
message DepositEvent {
    string tx_hash = 1;
    string wallet = 2;
    string token = 3;
    string amount = 4;
    int64 block_number = 5;
    int64 log_index = 6;
    int64 timestamp = 7;
}

// 结算结果 (topic: settlement-results)
message SettlementResult {
    string batch_id = 1;
    repeated string trade_ids = 2;
    string status = 3;              // success, failed
    string tx_hash = 4;
    int64 gas_used = 5;
    string error_message = 6;
    int64 confirmed_at = 7;
}

// 提现结果 (topic: withdrawal-results)
message WithdrawalResult {
    string withdraw_id = 1;
    string status = 2;              // success, failed
    string tx_hash = 3;
    int64 gas_used = 4;
    string error_message = 5;
    int64 confirmed_at = 6;
}
```

---

## 十五、检查点增强

### 15.1 更频繁的检查点保存

```go
// 增强的检查点管理
type CheckpointManager struct {
    redis       *redis.Client
    lastBlock   int64
    lastSave    time.Time
    pendingLogs []*types.Log
    mu          sync.Mutex
}

const (
    CheckpointBlockInterval = 10          // 每 10 个区块保存一次
    CheckpointTimeInterval  = 30 * time.Second  // 或每 30 秒保存一次
    MaxPendingLogs         = 100          // 最多缓存 100 条日志
)

// 处理区块时更新检查点
func (m *CheckpointManager) OnBlockProcessed(block *types.Block, logs []*types.Log) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    m.pendingLogs = append(m.pendingLogs, logs...)

    shouldSave := false

    // 条件1: 区块间隔
    if block.NumberU64()-uint64(m.lastBlock) >= CheckpointBlockInterval {
        shouldSave = true
    }

    // 条件2: 时间间隔
    if time.Since(m.lastSave) >= CheckpointTimeInterval {
        shouldSave = true
    }

    // 条件3: 待处理日志过多
    if len(m.pendingLogs) >= MaxPendingLogs {
        shouldSave = true
    }

    if shouldSave {
        if err := m.saveCheckpoint(block); err != nil {
            return err
        }
        m.lastBlock = int64(block.NumberU64())
        m.lastSave = time.Now()
        m.pendingLogs = nil
    }

    return nil
}

// 保存检查点
func (m *CheckpointManager) saveCheckpoint(block *types.Block) error {
    checkpoint := &IndexerCheckpoint{
        BlockNumber:  block.NumberU64(),
        BlockHash:    block.Hash().Hex(),
        Timestamp:    block.Time(),
        SavedAt:      time.Now().Unix(),
        PendingCount: len(m.pendingLogs),
    }

    data, _ := json.Marshal(checkpoint)
    key := "eidos:chain:checkpoint"

    // 使用 Redis 事务保证原子性
    pipe := m.redis.TxPipeline()
    pipe.Set(ctx, key, data, 0)
    pipe.Set(ctx, key+":backup", data, 0)  // 备份
    _, err := pipe.Exec(ctx)

    return err
}

// 从检查点恢复
func (m *CheckpointManager) RecoverFromCheckpoint() (uint64, error) {
    key := "eidos:chain:checkpoint"

    data, err := m.redis.Get(ctx, key).Bytes()
    if err == redis.Nil {
        // 尝试备份
        data, err = m.redis.Get(ctx, key+":backup").Bytes()
    }
    if err != nil {
        return 0, err
    }

    var checkpoint IndexerCheckpoint
    if err := json.Unmarshal(data, &checkpoint); err != nil {
        return 0, err
    }

    log.Info("Recovered from checkpoint",
        "block", checkpoint.BlockNumber,
        "saved_at", time.Unix(checkpoint.SavedAt, 0))

    return checkpoint.BlockNumber, nil
}
```
