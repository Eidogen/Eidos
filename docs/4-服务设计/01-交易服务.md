# Eidos 交易服务设计

> 服务名: eidos-trading
> 语言: Go

---

## 一、服务概述

### 1.1 核心定位

eidos-trading 是交易核心服务，整合订单管理、成交清算、账户余额三大功能模块。

**设计原则**:
- 参考 ViaBTC 撮合引擎设计，将强关联的交易逻辑整合到同一服务
- 减少跨服务调用，避免分布式事务复杂性
- **资金操作使用 Redis Lua 原子脚本**，DB 异步落盘 (详见第二章资金口径声明)

### 1.2 内部模块

```
eidos-trading
├── order/          订单模块
│   ├── 订单创建、EIP-712 签名验证、Nonce 管理
│   ├── 余额冻结、订单取消、发送到撮合
├── clearing/       清算模块
│   ├── 成交处理、余额划转、手续费扣取
│   └── 流水记录、订单状态更新
└── account/        账户模块
    ├── 余额查询、充值入账
    └── 提现申请、流水查询
```

### 1.3 对外能力

**gRPC 接口**:
| 模块 | 接口 | 说明 |
|------|------|------|
| Order | CreateOrder, CancelOrder, GetOrder | 订单创建、取消、查询 |
| Order | ListOrders, GetOpenOrders, BatchCancel | 订单列表、挂单、批量取消 |
| Account | GetBalance, GetBalances, RequestWithdraw | 余额查询、提现申请 |
| Account | GetTransactions, GetDeposits, GetWithdrawals | 流水、充值、提现记录 |

**Kafka 消费**: order-cancelled, trade-results, deposits, settlement-confirmed, withdrawal-confirmed
**Kafka 生产**: orders, cancel-requests, balance-updates, order-updates, settlements, withdrawals, config-updates

### 1.4 eidos-api 与 eidos-trading 接口关系

> 澄清: eidos-api 的两阶段下单 (prepare + submit) 与 trading 的 CreateOrder 关系

**下单流程**:
```
用户 → eidos-api (REST)                    → eidos-trading (gRPC)
       |                                      |
       | POST /orders/prepare                 |  (无调用，API 本地生成 order_id)
       | ← 返回 order_id + EIP-712 待签数据   |
       |                                      |
       | POST /orders (含签名)                |
       | ─────────────────────────────────────→ CreateOrder(order_id, ...)
       | ← 返回订单状态                       | ← 返回订单详情
```

**接口职责**:
| 阶段 | 服务 | 职责 |
|------|------|------|
| prepare | eidos-api | 生成 order_id (UUID)，构造 EIP-712 待签数据，返回给前端 |
| submit | eidos-api | 验证基础参数，调用 trading.CreateOrder |
| CreateOrder | eidos-trading | 完整验证 (签名、nonce、余额等)，冻结余额，写入订单 |

**关键点**:
- **order_id 生成** (取决于架构版本):
  - MVP 版本: eidos-api 在 prepare 阶段生成 UUID
  - 高性能版本: 确定性派生 `keccak256(wallet+market+nonce+salt)`
- trading 的 CreateOrder 是幂等的 (相同 order_id 返回已有订单)
- trading 不提供 Prepare 接口，所有业务逻辑在 CreateOrder 完成

**⚠️ order_id 全链路契约** (切换高性能版本后生效):
| 约束 | 说明 |
|------|------|
| **全链路统一** | 一旦进入高性能版本，order_id 必须全链路使用 keccak256 派生，**不允许部分客户端仍送 UUID** |
| **不可混用** | 系统启动时检测 order_id 格式，若发现 UUID 格式直接拒绝 |
| **版本切换** | 通过配置开关 `order_id_mode: uuid | keccak256`，切换后不可回退 |
| **迁移期** | 切换前存量订单 (UUID) 仍可查询，但新单必须用新格式 |

**幂等性规则** (order_id 已存在时):
| 场景 | 处理 |
|------|------|
| order_id 存在，参数完全一致 | 直接返回已有订单，不重复处理 |
| order_id 存在，参数不一致 | 返回错误 `TRADING_ORDER_ID_CONFLICT`，拒绝处理 |
| order_id 存在，但签名不同 | 返回错误 `TRADING_ORDER_ID_CONFLICT` (可能是篡改或重放攻击) |

**参数一致性校验字段**: `maker`, `market`, `side`, `order_type`, `price`, `size`, `nonce`, `expiration`, `signature`

---

## 二、Order 模块

> **目标**: 支撑 **20万+ TPS** (多交易对 × 多做市商场景)
>
> **核心设计**: Redis Lua 原子冻结 + Redis Outbox + 异步落盘

**⚠️ 资金口径统一声明** (全链路适用):

| 数据层 | 角色 | 说明 |
|--------|------|------|
| **Redis** | 实时资金真相 | 冻结/解冻/清算的资金变动以 Redis 为准 |
| **PostgreSQL** | 异步物化 + 对账基准 | DB Writer 消费 Kafka 异步落盘，用于查询/审计/灾难恢复 |

**关键约束**:
- 下单/取消/成交/过期/回滚的资金操作**全部走 Redis Lua 原子脚本**
- DB 不参与实时扣减，只作为异步落盘目标
- 对账任务定期比对 Redis 与 DB，差异触发告警
- Redis 重启后由 DB + Kafka 重放恢复状态

**⚠️ Redis 重启恢复流程**:

> **前提**: 使用 Redis Cluster (3主3从)，单节点故障自动 failover，极少触发全量恢复

```
恢复优先级:
1. Redis AOF 自动恢复 (首选)
   - Redis 配置: appendonly yes, appendfsync everysec
   - 重启时自动从 AOF 恢复，最多丢失 1 秒数据
   - 如 AOF 完整，无需额外操作

2. 从 DB 冷启动 (AOF 损坏或新节点)
   步骤:
   a) 暂停交易服务 (设置维护模式)
   b) 从 PostgreSQL 加载最新状态:
      - balances 表 → eidos:trading:balance:{wallet}:{token}
      - orders 表 (status=OPEN/PARTIAL) → eidos:trading:order_freeze:{order_id}
      - order_freezes 表 → 恢复冻结记录
   c) 记录 DB 快照时的 Kafka offset
   d) 从该 offset 重放 Kafka 事件:
      - balance-updates: 重新执行余额变更
      - trade-results: 重新执行清算
   e) 比对重放后 Redis 状态与 DB 最新状态
   f) 恢复交易服务

3. Outbox 恢复
   - PENDING/PROCESSING 状态订单: 重新扫描 orders 表
   - 对比 Kafka orders topic 已发送的 order_id
   - 未发送的重新入队 Outbox

恢复时间目标:
| 场景 | RTO | 说明 |
|------|-----|------|
| 单节点 failover | < 30s | Redis Sentinel 自动切换 |
| AOF 恢复 | < 5min | 取决于 AOF 大小 |
| DB 冷启动 | < 30min | 需人工介入，全量加载 |

安全保障:
- Redis Cluster 配置 min-replicas-to-write=1，确保写入同步到至少 1 个副本
- 每日凌晨执行 BGSAVE，保留 RDB 快照备份
- DB Writer 持续运行，DB 数据最多落后 Redis 数秒
```

### 2.1 创建订单流程 (Redis Lua 原子冻结)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                  创建订单流程 (Redis Lua 原子冻结)                            │
│                                                                              │
│  User          eidos-api      eidos-trading       Redis        Kafka        │
│    │              │                 │               │            │          │
│    │  下单请求    │                 │               │            │          │
│    │  (EIP-712签名)                 │               │            │          │
│    │─────────────>│                 │               │            │          │
│    │              │ CreateOrder     │               │            │          │
│    │              │    (gRPC)       │               │            │          │
│    │              │────────────────>│               │            │          │
│    │              │                 │               │            │          │
│    │              │      ┌──────────────────────────────────────┐           │
│    │              │      │  并发验证 (快速失败，任一失败立即返回)  │           │
│    │              │      │  ┌────────┐ ┌────────┐ ┌──────────┐  │           │
│    │              │      │  │ 验签名 │ │检查nonce│ │ 余额预检 │  │           │
│    │              │      │  │ (本地) │ │(Redis) │ │  (Redis) │  │           │
│    │              │      │  └────────┘ └────────┘ └──────────┘  │           │
│    │              │      │  ┌────────┐ ┌────────┐ ┌──────────┐  │           │
│    │              │      │  │验证过期│ │精度验证│ │ 限额检查 │  │           │
│    │              │      │  │ (本地) │ │ (本地) │ │ (Redis)  │  │           │
│    │              │      │  └────────┘ └────────┘ └──────────┘  │           │
│    │              │      └──────────────────────────────────────┘           │
│    │              │                 │               │            │          │
│    │              │                 │  Lua 原子冻结  │            │          │
│    │              │                 │──────────────>│            │          │
│    │              │                 │  1. 检查余额   │            │          │
│    │              │                 │  2. 检查nonce  │            │          │
│    │              │                 │  3. 冻结余额   │            │          │
│    │              │                 │  4. 标记nonce  │            │          │
│    │              │                 │  5. 写Outbox   │            │          │
│    │              │                 │<──────────────│            │          │
│    │              │                 │               │            │          │
│    │              │<────────────────│  返回 OPEN    │            │          │
│    │<─────────────│                 │               │            │          │
│    │              │                 │               │            │          │
│    │              │            Redis Outbox Relay (独立进程)     │          │
│    │              │                 │               │            │          │
│    │              │                 │  投递到 Kafka │            │          │
│    │              │                 │─────────────────────────────>│         │
│    │              │                 │               │  acks=all  │          │
│    │              │                 │               │            │          │
│    │              │                 │   Matching 消费订单          │          │
│    │              │                 │               │<───────────│          │
│    │              │                 │               │            │          │
│    │              │                 │   DB Writer 异步落盘         │          │
│    │              │                 │               │<───────────│          │
└─────────────────────────────────────────────────────────────────────────────┘
```

**并发验证设计**:

| 阶段 | 操作 | 位置 | 说明 |
|------|------|------|------|
| **并发验证** | 验签名 | 本地 | CPU 计算，无 IO |
| | 检查 nonce | Redis | `EXISTS nonce:{wallet}:{usage}:{nonce}` |
| | 余额预检查 | Redis | 读余额缓存，快速拦截 |
| | 验证过期 | 本地 | 时间比较 |
| | 精度验证 | 本地 | tick_size/step_size 检查 |
| | 限额检查 | Redis | 用户/全局待结算限额 |
| **Lua 原子操作** | 余额冻结 | Redis | check-then-modify 原子执行 |
| | Nonce 标记 | Redis | 同一 Lua 脚本内 |
| | Outbox 写入 | Redis | 同一 Lua 脚本内 |

**关键点**:
- 并发验证**快速失败**: 任一检查失败立即返回，不进入 Lua
- Lua 脚本**原子执行**: 冻结+nonce+outbox 全部成功或全部回滚
- **不等 Kafka 确认**: Lua 成功即返回 OPEN，由 Relay 重试投递

**订单验证规则**:
| 验证项 | 规则 | 错误码 |
|--------|------|--------|
| 签名验证 | EIP-712 + ecrecover | TRADING_INVALID_SIGNATURE |
| Nonce | 同一 (wallet, usage_type) 唯一，7天窗口内拒绝复用 | TRADING_NONCE_ALREADY_USED |
| 过期时间 | 不超过 30 天 | TRADING_ORDER_EXPIRED |
| 价格精度 | 必须是 tick_size 整数倍 | TRADING_INVALID_PRICE_PRECISION |
| 数量精度 | 必须是 step_size 整数倍 | TRADING_INVALID_SIZE_PRECISION |
| 最小数量 | size >= min_size | TRADING_SIZE_TOO_SMALL |
| 最大数量 | size <= max_size (如配置) | TRADING_SIZE_TOO_LARGE |
| 最小金额 | price * size >= min_notional | TRADING_NOTIONAL_TOO_SMALL |
| 余额检查 | available >= freeze_amount | TRADING_INSUFFICIENT_BALANCE |
| 待结算限额 | pending_total < user_limit 且 global < limit | TRADING_PENDING_LIMIT_EXCEEDED |

**OPEN 状态语义**:

> ⚠️ **重要**: `OPEN` 状态表示"资金已冻结 + 订单已入队"，**不是**"已进入订单簿"

| 状态 | 含义 | 用户可见行为 |
|------|------|-------------|
| **OPEN** | 余额已冻结 + 订单已入 Redis Outbox | 订单等待投递到 Kafka，可能尚未进入订单簿 |
| **REJECTED** | 验证失败或冻结失败 | 订单被拒，无资金变动 |
| **UNKNOWN** | Lua 超时或网络异常 | 客户端应查询确认订单状态 |

**用户体验影响**:
| 场景 | 处理 |
|------|------|
| 用户看到 OPEN 但订单簿没有 | 正常，队列处理中 (10-100ms 延迟) |
| 撮合拒单 (市场暂停等) | 触发解冻流程，推送 order-updates |
| 队列积压导致延迟 | 监控告警，用户可见延迟但资金安全 |

**Nonce 验证规则**:

> Nonce 定义: 用户自选的 64 位整数，用于防重放攻击。不强制递增，但同一 (wallet, usage_type) 下必须唯一。

```
Lua 脚本内原子执行:
1. 检查 Redis: EXISTS nonce:{wallet}:{usage}:{nonce}
   - 存在 → 立即返回 NONCE_ALREADY_USED
2. 冻结余额成功后，标记 nonce: SETEX nonce:{wallet}:{usage}:{nonce} 7d 1
```

**Nonce 清理策略**:
- Redis 缓存自动过期 (7d TTL)
- DB Writer 异步落盘 nonce 记录 (用于对账)
- ⚠️ 7 天后技术上可复用，但**强烈不建议**：客户端应始终生成新 nonce

**Redis Outbox 可靠投递策略**:

> ⚠️ **安全关键点**: Redis 冻结 ↔ Kafka 入队不是原子操作，需要可靠投递机制

**Outbox 消息状态机**:
```
┌─────────┐   Relay取走   ┌────────────┐   Kafka确认   ┌──────┐
│ PENDING │─────────────>│ PROCESSING │─────────────>│ SENT │
└────┬────┘              └─────┬──────┘              └──────┘
     │                         │
     │ 用户取消                │ 投递失败 (重试N次)
     ▼                         ▼
┌───────────┐            ┌──────┐
│ CANCELLED │            │ DEAD │ → 人工介入
└───────────┘            └──────┘
```

**Outbox 数据结构** (Redis Hash，非 List):
```
outbox:order:{order_id} = {
  "status": "PENDING|PROCESSING|SENT|CANCELLED|DEAD",
  "order_json": "{...}",
  "shard": 0,
  "retry_count": 0,
  "created_at": 1704067200000,
  "updated_at": 1704067200000
}

// 索引队列 (按 shard 分片)
outbox:pending:{shard} = [order_id1, order_id2, ...]
outbox:processing:{shard} = [order_id1, order_id2, ...]
```

**⚠️ Outbox 分片并行投递**:

```
分片设计:
- 分片数: N = 16 (可配置，建议 2^n)
- 分片规则: shard = crc32(wallet_address) % N
  - 按 wallet 分片，保证同一用户订单按序投递
  - 不用 order_id 分片，避免同用户订单乱序

Relay 部署:
- 每个 shard 对应一个 Relay Worker (goroutine 或独立进程)
- 部署方式:
  | 模式 | 说明 | 适用场景 |
  |------|------|----------|
  | 单进程多协程 | 1 进程 N goroutines，每个负责 1 shard | 中小规模，运维简单 |
  | 多进程单 shard | N 进程，每个进程负责固定 shard 集合 | 大规模，隔离性好 |

- 并行约束:
  - 同一 shard 内串行: 保证同用户订单顺序
  - 不同 shard 间并行: 最大化吞吐
  - Relay 实例数 >= shard 数，否则存在空闲 shard

负载均衡:
- crc32(wallet) 分布均匀，各 shard 负载基本均衡
- 如出现热点钱包，考虑增加 shard 数或单独处理
```

**Lua 脚本原子操作 (下单)**:
```
1. 检查余额 available >= freeze_amount
2. 检查 nonce 未使用
3. 冻结余额: available -= freeze_amount, frozen += freeze_amount
4. 标记 nonce 已使用
5. 创建 Outbox 记录: HSET outbox:order:{order_id} status=PENDING ...
6. 加入待投递队列: LPUSH outbox:pending:{shard} {order_id}
7. 返回冻结成功
```

**Redis Outbox Relay (独立进程)**:
```
LOOP:
  order_id = BRPOPLPUSH outbox:pending:{shard} outbox:processing:{shard}
  HSET outbox:order:{order_id} status=PROCESSING updated_at=now

  order_json = HGET outbox:order:{order_id} order_json
  try:
    kafka.produce("orders", order_json, acks=all)
    HSET outbox:order:{order_id} status=SENT
    LREM outbox:processing:{shard} 1 order_id
  catch timeout/error:
    retry_count = HINCRBY outbox:order:{order_id} retry_count 1
    if retry_count > MAX_RETRY:
      HSET outbox:order:{order_id} status=DEAD
      LREM outbox:processing:{shard} 1 order_id
      alert("outbox_dead_letter", order_id)
    else:
      // 保留在 processing 队列，下次重试
      sleep(backoff)
```

**关键设计**:
| 要素 | 方案 |
|------|------|
| 原子性 | Lua 内冻结+写 Outbox 是原子的 |
| 持久化 | Redis AOF everysec，最多丢 1 秒 |
| 幂等性 | order_id 确定性生成，Kafka 去重 |
| 状态追踪 | Hash 结构支持状态查询和取消竞态处理 |
| 死信处理 | 重试 N 次后标记 DEAD，人工介入 |

**⚠️ OPEN 超时告警** (可见性保障):

> **问题**: 用户收到 OPEN 后，订单可能卡在 PENDING/PROCESSING 未真正进入撮合

```
监控规则:
- 定时任务每 10 秒扫描: status IN (PENDING, PROCESSING) AND created_at < now - 30s
- P1 告警: 订单 OPEN 超过 30 秒未到达 SENT 状态
- P0 告警: 超过 60 秒仍未 SENT

用户侧可见性:
- 返回 OPEN 时附带 estimated_latency_ms，通常 < 100ms
- 如 > 5s 未见订单簿变化，前端提示"订单处理中"
- 如 > 30s，前端提示"系统繁忙，订单可能延迟生效"
```

**⚠️ DEAD 状态资金处理**:

> **问题**: 订单标记 DEAD 后，已冻结资金如何处置

```
处理策略:
| 场景 | 处理方式 | 说明 |
|------|----------|------|
| Kafka 持续不可用 | 保持 DEAD，等待恢复 | 资金保持冻结，防止双花 |
| 网络分区恢复后 | 人工确认后释放 | 避免订单已进撮合但未知 |

DEAD 订单处置流程:
1. 运维收到 P0 告警，介入排查
2. 确认订单未进入 Matching (查 Kafka offset)
3. 如确认未进入:
   - 执行 Lua: 解冻资金，标记订单 SYSTEM_CANCELLED
   - 推送 WebSocket 通知用户
4. 如不确定或已进入:
   - 等待 Matching 返回结果
   - 正常走成交/取消流程

自动解冻 (可选配置):
- 如配置 auto_release_dead_after = 300s
- DEAD 超过 300 秒且确认 Kafka 无该订单 → 自动解冻
- 此配置需谨慎启用，建议默认关闭
```

**⚠️ Outbox Backlog 降级策略** (硬约束):

> **风险**: Outbox 积压时用户看到 OPEN 但订单实际未进撮合，系统"看似可用但订单不动"

```
监控指标:
- pending_count = LLEN outbox:pending:{shard}
- processing_count = LLEN outbox:processing:{shard}
- backlog = pending_count + processing_count

降级规则:
| 阈值 | 动作 |
|------|------|
| backlog > 1000 | P2 告警，开始监控 |
| backlog > 5000 | P1 告警，限流新单 (50% 拒绝) |
| backlog > 10000 | **暂停新单**，只允许取消 |
| relay_lag > 30s | **暂停新单**，只允许取消 |

限流实现 (Lua 脚本内):
1. 检查 backlog = LLEN outbox:pending:{shard}
2. if backlog > HARD_LIMIT:
     return SYSTEM_OVERLOADED  // 拒绝新单
3. if backlog > SOFT_LIMIT:
     if random() > 0.5:
       return SYSTEM_BUSY  // 概率拒绝
```

**降级恢复**:
- backlog < 1000 持续 5 分钟后自动恢复
- 需运维确认后手动解除暂停 (防止抖动)

**待结算限额检查**:
```
// 并发验证阶段快速检查
user_pending = redis.get("pending:{wallet}")
if user_pending > config.pending_limit.default_max_pending:
    reject("User pending limit exceeded")

global_pending = redis.get("global:pending:total")
if global_pending > config.pending_limit.global_max_pending:
    reject("Global pending limit exceeded")
```

**IOC/FOK 订单处理**:
| 类型 | 说明 | 处理逻辑 |
|------|------|----------|
| GTC (Good-Till-Cancel) | 一直有效直到取消 | 正常挂单，等待成交或用户取消 |
| IOC (Immediate-Or-Cancel) | 立即成交或取消 | 撮合后立即取消未成交部分，解冻剩余金额 |
| FOK (Fill-Or-Kill) | 全部成交或拒绝 | 无法完全成交时直接拒绝，返回 REJECTED 状态 |

**IOC/FOK 超时保护**:
- 撮合引擎处理 IOC/FOK 订单后，必须在 `ioc_fok_timeout` (默认 5s) 内返回结果
- 定时任务扫描 Redis Outbox 积压情况，超阈值触发告警
- 若撮合引擎无响应，由对账任务检测并处理悬挂订单

### 2.2 取消订单流程

> **设计原则**: 根据订单状态区分处理路径，Redis 解冻 + Kafka 通知

**取消场景分类** (基于 Outbox 状态机):
| Outbox 状态 | 处理方 | 流程 |
|-------------|--------|------|
| PENDING | Trading | Lua 原子: 标记 CANCELLED + 解冻余额 |
| PROCESSING | Trading | Lua 原子: 标记 CANCELLED + 解冻余额 (Relay 检查后跳过) |
| SENT | Matching 主导 | Kafka cancel-request → Matching → order-cancelled → Redis 解冻 |
| 不存在 | Matching 主导 | 同上 (已投递到 Kafka) |

**未投递订单取消流程** (Redis Lua 原子操作):
```
Lua 脚本原子操作:
1. 检查 Outbox 状态: HGET outbox:order:{order_id} status
   - 不存在或 SENT → 返回 ALREADY_SENT，走 Matching 取消流程
   - CANCELLED → 返回 ALREADY_CANCELLED
   - DEAD → 返回 ORDER_FAILED，无需取消

2. 标记 Outbox 为 CANCELLED:
   HSET outbox:order:{order_id} status=CANCELLED updated_at=now

3. 从索引队列移除 (无论 pending 还是 processing):
   LREM outbox:pending:{shard} 0 {order_id}
   LREM outbox:processing:{shard} 0 {order_id}

4. 解冻余额:
   available += frozen_amount
   frozen -= frozen_amount

5. 返回取消成功
```

**⚠️ PROCESSING 状态竞态处理**:
```
场景: 取消请求和 Relay 投递同时进行

时序 A (取消先完成):
1. 取消 Lua: 标记 CANCELLED，解冻余额
2. Relay: 取到 order_id，检查状态
3. Relay: 发现 CANCELLED，跳过投递，清理队列

时序 B (投递先完成):
1. Relay: 取到 order_id，投递 Kafka，标记 SENT
2. 取消 Lua: 检查状态，发现 SENT
3. 取消 Lua: 返回 ALREADY_SENT，走 Matching 取消流程

Relay 投递逻辑 (增加状态检查):
  order_id = BRPOPLPUSH pending processing
  status = HGET outbox:order:{order_id} status
  if status == CANCELLED:
    LREM processing 1 order_id  // 跳过，清理队列
    continue
  // 正常投递...
```

**关键点**:
- Lua 脚本原子执行：检查+标记+解冻
- **Nonce 不删除**: 取消订单不释放 nonce，保留 TTL 窗口内不可复用
- Outbox Hash 结构确保取消和投递的竞态安全
- 取消成功后由 DB Writer 异步落盘取消记录

**OPEN/PARTIAL 订单取消流程** (撮合引擎主导):

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      取消订单流程 (撮合引擎主导)                              │
│                                                                              │
│  User          eidos-api      eidos-trading       Kafka       eidos-matching │
│    │              │                 │               │               │        │
│    │  取消订单    │                 │               │               │        │
│    │─────────────>│                 │               │               │        │
│    │              │ CancelOrder     │               │               │        │
│    │              │────────────────>│               │               │        │
│    │              │                 │               │               │        │
│    │              │                 │ 验证签名+订单状态              │        │
│    │              │                 │ (不修改订单状态!)              │        │
│    │              │                 │               │               │        │
│    │              │                 │ Kafka ProduceSync             │        │
│    │              │                 │──────────────>│ cancel-requests       │
│    │              │<────────────────│ 返回"取消中"  │──────────────>│        │
│    │<─────────────│                 │               │               │        │
│    │              │                 │               │  从订单簿移除  │        │
│    │              │                 │               │<──────────────│        │
│    │              │                 │<──────────────│ order-cancelled       │
│    │              │                 │               │               │        │
│    │              │                 │ Redis Lua 解冻               │        │
│    │              │                 │ (余额真相在 Redis)            │        │
│    │              │                 │               │               │        │
│    │              │                 │ 异步: DB Writer 更新状态      │        │
└─────────────────────────────────────────────────────────────────────────────┘
```

**取消链路说明**:
- **Kafka ProduceSync**: 取消请求量远低于下单量，直接同步投递 Kafka，无需走 Redis Outbox
- **Redis Lua 解冻**: 收到 Matching 的 `order-cancelled` 事件后，调用 Redis Lua 原子解冻
- **DB Writer 异步**: 状态更新 (CANCELLED) 和流水记录由 DB Writer 消费 Kafka 异步落盘

**取消规则**:
- 只有 OPEN/PARTIAL 状态可取消 (PENDING 状态走 Redis Outbox 取消流程)
- 取消需验证 EIP-712 签名
- 解冻在 Redis 完成，DB 是异步物化

### 2.3 订单状态机

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           订单状态机                                         │
│                                                                              │
│  ┌─────────┐                                                                │
│  │ PENDING │  订单已创建，等待撮合引擎确认                                   │
│  │   (0)   │                                                                │
│  └────┬────┘                                                                │
│       │                                                                      │
│       ├──────────────────┬───────────────────┐                              │
│       │ Accepted         │ Rejected          │                              │
│       ▼                  ▼                   │                              │
│  ┌─────────┐        ┌──────────┐             │                              │
│  │  OPEN   │        │ REJECTED │             │                              │
│  │   (1)   │        │   (6)    │ 终态        │                              │
│  └────┬────┘        └──────────┘             │                              │
│       │                                       │                              │
│       │ 部分成交                              │                              │
│       ▼                                       │                              │
│  ┌─────────┐                                 │                              │
│  │ PARTIAL │  部分成交                        │                              │
│  │   (2)   │                                 │                              │
│  └────┬────┘                                 │                              │
│       │                                       │                              │
│       ├──────────────┬───────────────────────┤                              │
│       │ 全部成交     │ 用户取消    │ 过期    │                              │
│       ▼              ▼             ▼         │                              │
│  ┌─────────┐   ┌───────────┐  ┌─────────┐   │                              │
│  │ FILLED  │   │ CANCELLED │  │ EXPIRED │   │                              │
│  │   (3)   │   │    (4)    │  │   (5)   │   │                              │
│  └─────────┘   └───────────┘  └─────────┘   │                              │
│     终态           终态           终态                                       │
│                                                                              │
│  状态流转规则:                                                               │
│  PENDING → OPEN/REJECTED (撮合引擎确认/拒绝)                                │
│  PENDING → CANCELLED (用户取消，订单尚未进入撮合)                           │
│  OPEN → PARTIAL (部分成交)                                                  │
│  OPEN → FILLED (全部成交)                                                   │
│  OPEN → CANCELLED (用户取消)                                                │
│  OPEN → EXPIRED (订单过期)                                                  │
│  PARTIAL → FILLED (剩余全部成交)                                            │
│  PARTIAL → CANCELLED (用户取消剩余)                                         │
│  PARTIAL → EXPIRED (剩余过期)                                               │
└─────────────────────────────────────────────────────────────────────────────┘
```

**REJECTED 订单回滚处理** (Redis 解冻为准):
- 触发场景: 撮合引擎拒绝订单 (市场暂停、价格异常、配置版本不匹配等)
- 回滚逻辑 (Redis Lua 原子操作):
  ```
  1. 检查订单冻结记录存在 (Redis hash: order_freeze:{order_id})
  2. 解冻余额:
     available += frozen_amount
     frozen -= frozen_amount
  3. 删除订单冻结记录
  4. 返回解冻成功
  ```
- 异步落盘 (DB Writer 消费 order-updates):
  1. 更新订单状态 → REJECTED，记录 reject_reason
  2. 插入 transactions 流水 (UNFREEZE 类型)
- 失败处理:
  - Redis Lua 失败: 重试 3 次，仍失败触发 P1 告警人工介入
  - DB Writer 落盘失败: 不影响用户余额 (Redis 已解冻)，重试直到成功

**订单过期处理** (权威处理者分工):
| 订单状态 | 权威处理者 | 处理逻辑 |
|----------|------------|----------|
| PENDING | Trading (eidos-jobs) | 定时扫描 expiration < now 且 status=PENDING，直接标记 EXPIRED 并解冻 |
| OPEN/PARTIAL | Matching (主) + Jobs (兜底) | Matching 基于 expiration 主动过期并发 order-expired 事件；Jobs 作为兜底扫描 |

**Matching 过期处理** (主流程):
```
1. Matching 每秒扫描订单簿中 expiration < now 的订单
2. 从订单簿移除
3. 发送 order-expired 事件到 Kafka (order-cancelled topic，reason=EXPIRED)
4. Trading 收到事件后更新状态 → EXPIRED，解冻余额
```

**Jobs 过期兜底** (异常恢复):
```
1. 每分钟扫描 status IN (OPEN, PARTIAL) AND expiration < now - 60s
2. 若发现，触发 P2 告警 (可能 Matching 遗漏)
3. 向 Matching 查询订单状态
4. 若 Matching 确认已移除，Trading 更新终态
```

---

## 三、Clearing 模块

> **资金口径**: 遵循第二章声明，**Redis 是实时资金真相，DB 是异步物化**

### 3.1 成交清算流程 (Redis Lua + 异步落盘)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      成交清算流程 (Redis Lua + 异步落盘)                       │
│                                                                              │
│  eidos-matching             eidos-trading.clearing              DB Writer   │
│       │                            │                                │       │
│       │  成交消息 (trade-results)  │                                │       │
│       │───────────────────────────>│                                │       │
│       │                            │                                │       │
│       │        ┌───────────────────────────────────────┐            │       │
│       │        │  Redis Lua 原子清算                    │            │       │
│       │        │                                        │            │       │
│       │        │  1. 幂等检查: SETNX trade:{trade_id}   │            │       │
│       │        │  2. 验证手续费 (容差 0.1%)             │            │       │
│       │        │                                        │            │       │
│       │        │  3. Maker (卖方示例):                  │            │       │
│       │        │     - 解冻 BTC: frozen -= amount       │            │       │
│       │        │     - 扣减 BTC: (已解冻即扣减)         │            │       │
│       │        │     - 增加 USDC: pending_available +=  │            │       │
│       │        │                                        │            │       │
│       │        │  4. Taker (买方示例):                  │            │       │
│       │        │     - 解冻 USDC: frozen -= amount      │            │       │
│       │        │     - 扣减 USDC: (已解冻即扣减)        │            │       │
│       │        │     - 增加 BTC: pending_available +=   │            │       │
│       │        │                                        │            │       │
│       │        │  5. 手续费: fee_bucket:{market}:{token}:{bucket} += │       │
│       │        │  6. 更新订单冻结记录                   │            │       │
│       │        └───────────────────────────────────────┘            │       │
│       │                            │                                │       │
│       │                            │  Kafka (trade-results)         │       │
│       │                            │───────────────────────────────>│       │
│       │                            │                                │       │
│       │                            │        ┌───────────────────────┴─────┐ │
│       │                            │        │  DB Transaction (异步落盘)   │ │
│       │                            │        │  - 插入 trades 记录          │ │
│       │                            │        │  - 更新 orders 状态和成交量  │ │
│       │                            │        │  - 插入 transactions 流水    │ │
│       │                            │        └─────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
```

**清算链路说明**:
- **Redis Lua**: 实时完成余额变动 (解冻、扣减、增加)，保证原子性
- **Kafka**: 清算完成后发送 trade-results，用于 DB 落盘和通知
- **DB Writer**: 异步消费 Kafka，落盘 trades/orders/transactions 记录
- **4字段模型**: `settled_available`, `settled_frozen`, `pending_available`, `pending_frozen` 均在 Redis 维护

### 3.2 手续费验证与保护

| 检查项 | 规则 | 处理 |
|--------|------|------|
| 费率上限 | fee_rate <= 5% | 超限拒绝并告警 |
| 费用验证 | Trading 重新计算并比对 | 容差: max(0.1%, 0.01 USDC)，超限告警 |
| 费用归集 | 双方手续费入分桶账户 | pending_available (分桶账户，详见下方) |
| 自成交检查 | maker == taker | 拒绝成交，触发 P1 告警 |

**手续费分桶设计** (解决平台账户热点):

> **问题**: 所有成交手续费写入同一平台账户，高并发下成为数据库热点行

**解决方案**: 按 market + token + 随机桶 三级分桶，彻底消除热点

```
分桶策略:
├─ 第一级: market (BTC-USDC, ETH-USDC, ...)
├─ 第二级: token (USDC, BTC, ...)
└─ 第三级: 随机桶 (0-15，共 16 个)

写入时: bucket_id = hash(trade_id) % 16  // 或纯随机
```

**分桶表设计** (独立表，非 balances 表):
| 字段 | 类型 | 说明 |
|------|------|------|
| market | VARCHAR(20) | 交易对 |
| token | VARCHAR(20) | 手续费代币 |
| bucket_id | SMALLINT | 0-15 |
| amount | DECIMAL(36,18) | 累计金额 |
| PRIMARY KEY | (market, token, bucket_id) | |

**设计要点**:
| 项目 | 说明 |
|------|------|
| 分桶数量 | 每个 (market, token) 16 个桶 |
| 写入方式 | 成交时随机选桶，`UPDATE ... SET amount = amount + fee` |
| 无锁竞争 | 16 个桶分散写入，同一桶冲突概率 1/16 |
| 归集策略 | 定时任务 (每小时) 汇总所有桶到主平台账户 |

**手续费归集任务** (eidos-jobs):
```
1. 遍历 fee_buckets 表所有行
2. 事务内:
   - 读取并清零各桶: UPDATE fee_buckets SET amount = 0 WHERE amount > 0 RETURNING *
   - 汇总写入主平台账户 balances
3. 归集频率: 每小时执行
4. 原子操作: 清零和入账在同一事务，不丢不重
```

**性能提升**: 热门市场 (如 BTC-USDC) 原本单行热点 → 分散到 16 行，锁竞争降低 16 倍

**手续费验证容差计算**:
```
// 使用比例和绝对值的较大者，防止小额订单容差过宽
tolerance = max(expected_fee * 0.001, min_fee_tolerance)  // min_fee_tolerance 默认 0.01 USDC
if abs(actual_fee - expected_fee) > tolerance:
    reject_and_alert()
```

### 3.3 按冻结来源比例扣减逻辑

> 成交时需按 order_freezes 记录的冻结来源比例扣减，确保解冻和扣减的一致性

```
// 1. 计算本次成交需要扣减的金额
deduct_amount = trade_size * price  // 买单扣 quote，卖单扣 base

// 2. 计算冻结来源比例
total_frozen = remaining_settled + remaining_pending
settled_ratio = remaining_settled / total_frozen
pending_ratio = remaining_pending / total_frozen

// 3. 按比例扣减
settled_deduct = deduct_amount * settled_ratio
pending_deduct = deduct_amount * pending_ratio

// 4. 更新余额表
balances.settled_frozen -= settled_deduct
balances.pending_frozen -= pending_deduct

// 5. 更新 order_freezes 剩余冻结
order_freezes.remaining_settled -= settled_deduct
order_freezes.remaining_pending -= pending_deduct

// 6. 订单完全成交时，剩余冻结应为 0 (可能存在精度误差，容差 1e-18)
if order.remaining_size == 0:
    assert abs(remaining_settled + remaining_pending) < 1e-18
```

### 3.4 乱序成交处理

> **⚠️ 层次说明**: 3.4-3.5 节描述的 DB 锁策略仅用于 **DB Writer 异步落盘层**，不在实时交易路径上。
> - **实时资金操作**: 全部通过 Redis Lua 原子脚本完成（详见第二章）
> - **DB Writer 职责**: 消费 Kafka `balance-updates` 事件，将 Redis 状态异步物化到 PostgreSQL
> - **本节锁策略目的**: 保证 DB 层多行写入的一致性，以及乱序消费时的幂等性

- 使用订单级锁 `SELECT ... FOR UPDATE` 串行化处理
- 锁定顺序: 先按 order_id 排序锁定，避免死锁
- 根据 remaining_size 动态调整本次成交量
- 超额成交触发 P0 告警

### 3.5 并发控制策略

> **核心原则**: 成交清算涉及多行更新 (2订单 + 4-6余额行)，统一使用悲观锁 + 固定锁顺序避免死锁

**锁定资源与顺序**:
| 资源类型 | 锁类型 | 锁顺序 | 说明 |
|----------|--------|--------|------|
| 订单 (orders) | SELECT FOR UPDATE | 按 order_id ASC | maker/taker 两笔订单 |
| 余额 (balances) | SELECT FOR UPDATE | 按 (wallet, token) ASC | 涉及的所有余额行 |
| 手续费分桶 (fee_buckets) | SELECT FOR UPDATE | 最后锁定 | 随机选桶，16 桶分散热点 |

**成交清算锁定流程**:
```
BEGIN TRANSACTION;

// 1. 确定需要锁定的资源 (不加锁)
order_ids = sort([maker_order_id, taker_order_id])
balance_keys = sort([
    (maker_wallet, base_token),
    (maker_wallet, quote_token),
    (taker_wallet, base_token),
    (taker_wallet, quote_token),
])

// 2. 按固定顺序加锁 - 订单
FOR order_id IN order_ids:
    SELECT * FROM orders WHERE order_id = ? FOR UPDATE

// 3. 按固定顺序加锁 - 余额 (去重后)
FOR (wallet, token) IN unique(balance_keys):
    SELECT * FROM balances WHERE wallet_address = ? AND token = ? FOR UPDATE

// 4. 最后锁定手续费分桶 (随机选桶，16 桶分散热点)
bucket_id = hash(trade_id) % 16
SELECT * FROM fee_buckets WHERE market = ? AND token = ? AND bucket_id = ? FOR UPDATE
UPDATE fee_buckets SET amount = amount + fee WHERE ...

// 5. 执行业务逻辑 (更新订单、余额、插入流水)
...

COMMIT;
```

**其他场景锁策略**:
| 场景 | 策略 | 说明 |
|------|------|------|
| 订单创建 | 单余额行 FOR UPDATE | 只锁冻结代币的余额行 |
| 订单取消 | 订单 + 余额 FOR UPDATE | 先锁订单，再锁余额 |
| 充值入账 | 幂等检查 + 单余额行 FOR UPDATE | tx_hash 去重，锁单行 |
| 提现申请 | 单余额行 FOR UPDATE | 只锁提现代币的余额行 |
| 结算确认 | 批量余额 FOR UPDATE | 按 (wallet, token) 排序锁定 |

**注意事项**:
- 所有涉及多行更新的操作必须遵循固定锁顺序
- 不再使用余额表的乐观锁 (version 字段保留用于并发检测告警，非控制)
- 单行更新可直接 UPDATE，无需显式加锁

---

## 四、Account 模块

### 4.1 余额模型 (4字段增强模型)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      余额模型 (已结算/待结算分离)                             │
│                                                                              │
│  用户总资产 = 已结算可用 + 已结算冻结 + 待结算可用 + 待结算冻结               │
│                                                                              │
│  ┌───────────────────────────────────────────────────────────────────┐      │
│  │                          用户余额                                  │      │
│  │  │    已结算 (Settled)      │    │    待结算 (Pending)      │       │      │
│  │  │    链上已确认            │    │    链下成交待上链        │       │      │
│  │  ├─────────────────────────┤    ├─────────────────────────┤       │      │
│  │  │ settled_available       │    │ pending_available       │       │      │
│  │  │ (可交易 + 可提现)       │    │ (可交易，不可提现)      │       │      │
│  │  ├─────────────────────────┤    ├─────────────────────────┤       │      │
│  │  │ settled_frozen          │    │ pending_frozen          │       │      │
│  │  │ (挂单/提现中)           │    │ (挂单占用)              │       │      │
│  │  └─────────────────────────┘    └─────────────────────────┘       │      │
│  └───────────────────────────────────────────────────────────────────┘      │
│                                                                              │
│  可交易余额 = settled_available + pending_available                         │
│  可提现余额 = settled_available  (只有已结算才可提)                          │
└─────────────────────────────────────────────────────────────────────────────┘
```

**余额变动规则**:
| 操作 | 变动字段 | 说明 |
|------|----------|------|
| 充值入账 | settled_available += | 链上确认，直接进入已结算 |
| 订单冻结 | available → frozen | 优先冻结已结算，不足部分冻结待结算 |
| 订单取消 | frozen → available | 按冻结来源 (order_freezes) 精确解冻 |
| 成交获得 | pending_available += | 链下成交，进入待结算 |
| 成交扣减 | frozen -= | 按冻结来源比例扣减 |
| 结算确认 | pending → settled | 链上确认后转移 |
| 提现申请 | settled_available → settled_frozen | 只能提已结算 |
| 提现完成 | settled_frozen -= | 链上确认扣减 |
| 提现失败 | settled_frozen → settled_available | 回滚冻结 |

**订单冻结规则**:
```
// 买单: 冻结 quote token (如 USDC)
// 按 taker_fee 预估 (最坏情况)，实际可能是 maker_fee
buy_freeze_amount = price * size * (1 + taker_fee)

// 卖单: 冻结 base token (如 BTC)
sell_freeze_amount = size  // 手续费从成交所得 (quote) 扣取

// 通用冻结逻辑 (优先冻结已结算余额)
if settled_available >= freeze_amount:
    settled_available -= freeze_amount
    settled_frozen += freeze_amount
else:
    settled_frozen += settled_available
    pending_frozen += (freeze_amount - settled_available)
    pending_available -= (freeze_amount - settled_available)
    settled_available = 0
```

**手续费多冻结退还** (买单成为 Maker 时):
```
// 场景: 限价买单按 taker_fee 冻结，但实际作为 Maker 成交
// 多冻结金额 = (taker_fee - maker_fee) * trade_amount

// 在清算时处理:
actual_fee = trade_amount * maker_fee
frozen_fee = trade_amount * taker_fee  // 按比例计算本次冻结的手续费部分
refund = frozen_fee - actual_fee

// 退还到可用余额 (按冻结来源比例退还)
settled_refund = refund * settled_ratio
pending_refund = refund * pending_ratio
settled_frozen -= settled_refund
pending_frozen -= pending_refund
settled_available += settled_refund
pending_available += pending_refund

// 更新 order_freezes 剩余冻结
order_freezes.remaining_settled -= settled_refund
order_freezes.remaining_pending -= pending_refund
```

**订单完全成交后的剩余冻结处理**:
- 订单 FILLED 后，`order_freezes.remaining_*` 应为 0
- 若有精度误差残余 (< 1e-18)，全部退还到 `settled_available`
- 若残余 > 1e-18，触发 P2 告警检查

### 4.1.1 pending_total 维护规则

> **设计目的**: `pending_total` 是冗余字段，用于快速查询用户待结算总额，避免限额检查时计算

**维护原则**: 应用层每次变更 `pending_available` 或 `pending_frozen` 时，必须同步更新 `pending_total`

**变更场景与更新规则**:
| 场景 | pending_available 变动 | pending_frozen 变动 | pending_total 更新 |
|------|------------------------|---------------------|--------------------|
| 成交获得 | += trade_amount | - | += trade_amount |
| 订单冻结 (pending 部分) | -= freeze_pending | += freeze_pending | 不变 (内部转移) |
| 订单取消 (pending 部分) | += unfreeze_pending | -= unfreeze_pending | 不变 (内部转移) |
| 成交扣减 (pending 部分) | - | -= deduct_pending | -= deduct_pending |
| 结算确认 | -= settlement_amount | - | -= settlement_amount |

**一致性保证**:
```go
// 每次更新余额时，在同一事务内同步更新 pending_total
func updateBalance(tx *sql.Tx, wallet, token string, delta PendingDelta) error {
    _, err := tx.Exec(`
        UPDATE balances SET
            pending_available = pending_available + $1,
            pending_frozen = pending_frozen + $2,
            pending_total = pending_total + $1 + $2,  -- 同步更新
            updated_at = $3
        WHERE wallet_address = $4 AND token = $5
    `, delta.Available, delta.Frozen, now(), wallet, token)
    return err
}
```

**定时校验**: eidos-jobs 每小时校验 `pending_total = pending_available + pending_frozen`，不一致则触发 P1 告警

### 4.2 充值流程 (Redis 先行 + DB 异步)

> **特殊说明**: 充值是链上事件驱动，链上是资金真相。但为保持架构一致性，仍先更新 Redis，再异步落盘 DB。

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      充值流程 (Redis 先行 + DB 异步)                          │
│                                                                              │
│  链上              eidos-chain (indexer)         eidos-trading     DB Writer │
│    │                      │                            │              │      │
│    │  用户转账到合约      │                            │              │      │
│    │─────────────────────>│                            │              │      │
│    │                      │                            │              │      │
│    │                      │  监听 Deposit 事件         │              │      │
│    │                      │  (等待确认块数)            │              │      │
│    │                      │                            │              │      │
│    │                      │  发送 Kafka (deposits)     │              │      │
│    │                      │───────────────────────────>│              │      │
│    │                      │                            │              │      │
│    │                      │       ┌────────────────────────────┐      │      │
│    │                      │       │  Redis Lua 原子入账         │      │      │
│    │                      │       │  1. 幂等检查: SETNX         │      │      │
│    │                      │       │     deposit:{tx_hash}       │      │      │
│    │                      │       │  2. settled_available +=    │      │      │
│    │                      │       └────────────────────────────┘      │      │
│    │                      │                            │              │      │
│    │                      │                            │  Kafka       │      │
│    │                      │                            │─────────────>│      │
│    │                      │                            │              │      │
│    │                      │                   ┌────────────────────────┴────┐│
│    │                      │                   │  DB Transaction (异步落盘)  ││
│    │                      │                   │  - 插入 deposits 记录       ││
│    │                      │                   │  - 插入 transactions 流水   ││
│    │                      │                   └─────────────────────────────┘│
│    │                      │                            │              │      │
│    │                      │            余额更新完成，用户可交易/提现          │
└─────────────────────────────────────────────────────────────────────────────┘
```

**充值规则**:
- 充值直接进入 Redis `settled_available`（链上已确认）
- 使用 `tx_hash` 在 Redis 做幂等 (`SETNX deposit:{tx_hash}`)，防止重复入账
- 检查最小充值金额
- DB Writer 异步落盘，用于审计和对账

### 4.3 提现流程 (Redis 两阶段 + DB 异步)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      提现流程 (Redis 两阶段 + DB 异步)                        │
│                                                                              │
│  阶段零: 参数验证 (同步)                                                     │
│  ─────────────────                                                           │
│  0. 验证目标地址格式 (EIP-55 checksum)                                      │
│  0. 验证代币是否支持提现                                                     │
│  0. 验证金额范围 (min_withdraw, max_withdraw, daily_limit)                  │
│                                                                              │
│  阶段一: Redis 冻结                                                          │
│  ─────────────────                                                           │
│  1. 验证提现签名 (EIP-712)                                                  │
│  2. Redis Lua 原子操作:                                                     │
│     - 检查 settled_available >= amount (只能提已结算!)                      │
│     - settled_available -= amount, settled_frozen += amount                 │
│     - 幂等标记: SETNX withdraw:{withdraw_id}                                │
│  3. Kafka ProduceSync → withdrawals topic                                   │
│  4. DB Writer 异步落盘提现记录                                               │
│                                                                              │
│  阶段二: 链上确认/回滚 (Redis 操作)                                          │
│  ─────────────────                                                           │
│  成功: Redis Lua: settled_frozen -= amount                                  │
│  失败: Redis Lua: settled_frozen -= amount, settled_available += amount     │
│  DB Writer: 异步更新提现状态 (COMPLETED/FAILED)                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

**⚠️ 提现目标地址验证 (EIP-55 Checksum)**:

> **必须校验**: 防止用户输入错误地址导致资金永久丢失

```go
import (
    "github.com/ethereum/go-ethereum/common"
    "strings"
)

// ValidateWithdrawAddress 验证提现目标地址
func ValidateWithdrawAddress(address string) error {
    // 1. 基础格式检查
    if len(address) != 42 || !strings.HasPrefix(address, "0x") {
        return ErrInvalidAddressFormat
    }

    // 2. 解析地址 (检查是否为有效的 hex)
    addr := common.HexToAddress(address)
    if addr == (common.Address{}) && address != "0x0000000000000000000000000000000000000000" {
        return ErrInvalidAddressFormat
    }

    // 3. EIP-55 checksum 校验
    // 如果用户输入的地址包含大小写混合，必须通过 checksum 验证
    checksumAddr := addr.Hex() // go-ethereum 返回 EIP-55 checksum 格式
    if address != strings.ToLower(address) && address != checksumAddr {
        // 地址包含大写字母但 checksum 不正确
        return ErrInvalidAddressChecksum
    }

    // 4. 禁止提现到零地址
    if addr == (common.Address{}) {
        return ErrWithdrawToZeroAddress
    }

    // 5. 禁止提现到合约地址 (可选，需要链上查询)
    // if isContract(addr) { return ErrWithdrawToContract }

    return nil
}
```

**地址验证规则**:
| 检查项 | 规则 | 错误码 |
|--------|------|--------|
| 格式检查 | 42 字符，0x 前缀 | TRADING_INVALID_ADDRESS_FORMAT |
| Hex 有效性 | 仅包含 0-9, a-f, A-F | TRADING_INVALID_ADDRESS_FORMAT |
| EIP-55 Checksum | 混合大小写必须通过 checksum | TRADING_INVALID_ADDRESS_CHECKSUM |
| 零地址 | 禁止提现到 0x000...000 | TRADING_WITHDRAW_TO_ZERO_ADDRESS |
| 合约地址 | 可选禁止，防止用户误操作 | TRADING_WITHDRAW_TO_CONTRACT |

### 4.4 结算确认流程 (Redis pending → settled + DB 异步)

> 链下成交产生的余额为"待结算"，需链上批量结算确认后转为"已结算"

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                 结算确认流程 (Redis pending → settled + DB 异步)              │
│                                                                              │
│  eidos-chain                     eidos-trading              DB Writer       │
│       │                               │                         │           │
│       │  批量结算交易上链              │                         │           │
│       │  (聚合多笔成交)               │                         │           │
│       │                               │                         │           │
│       │  链上确认后                    │                         │           │
│       │  发送 Kafka (settlement-confirmed)                      │           │
│       │──────────────────────────────>│                         │           │
│       │                               │                         │           │
│       │       ┌───────────────────────────────────────┐         │           │
│       │       │  Redis Lua 原子操作                    │         │           │
│       │       │                                        │         │           │
│       │       │  1. 幂等检查: SETNX settlement:{id}    │         │           │
│       │       │                                        │         │           │
│       │       │  FOR EACH user balance change:         │         │           │
│       │       │    2. pending_available -= amount      │         │           │
│       │       │    3. settled_available += amount      │         │           │
│       │       └───────────────────────────────────────┘         │           │
│       │                               │                         │           │
│       │                               │  Kafka                  │           │
│       │                               │────────────────────────>│           │
│       │                               │                         │           │
│       │                      ┌────────────────────────────────────┴─────┐   │
│       │                      │  DB Transaction (异步落盘)               │   │
│       │                      │  - 更新 trades.settlement_status         │   │
│       │                      │  - 插入 transactions 流水                │   │
│       │                      │  - 更新 balances (DB 物化)               │   │
│       │                      └──────────────────────────────────────────┘   │
│       │                               │                         │           │
│       │                       待结算余额转为已结算，用户可提现                │
└─────────────────────────────────────────────────────────────────────────────┘
```

**结算规则**:
- 批量结算：多笔成交聚合为一次链上交易
- Redis 先行：`pending → settled` 转移在 Redis 完成
- DB 异步：DB Writer 落盘用于审计和对账
- 用户可提现余额增加

---

## 五、数据库设计

### 5.0 精度配置

**核心原则**: 存储用最大精度 (DECIMAL 36,18)，验证用业务精度，计算时向下截断

#### 5.0.1 代币配置表

```sql
CREATE TABLE eidos_trading_tokens (
    id                   BIGSERIAL PRIMARY KEY,        -- 自增主键
    symbol               VARCHAR(20) NOT NULL UNIQUE,  -- 代币符号，如 USDC、WBTC、ETH
    name                 VARCHAR(50) NOT NULL,         -- 代币全称，如 USD Coin
    contract_address     VARCHAR(42) NOT NULL,         -- 链上合约地址 (0x开头，42字符)
    chain_decimals       SMALLINT NOT NULL,            -- 链上精度位数 (USDC=6, WBTC=8, ETH=18)
    display_decimals     SMALLINT NOT NULL,            -- 前端显示精度位数
    min_deposit          DECIMAL(36, 18) NOT NULL,     -- 最小充值金额
    min_withdraw         DECIMAL(36, 18) NOT NULL,     -- 单笔最小提现金额
    max_withdraw         DECIMAL(36, 18),              -- 单笔最大提现金额，NULL表示不限
    daily_withdraw_limit DECIMAL(36, 18),              -- 单用户每日提现限额，NULL表示不限
    deposit_enabled      BOOLEAN NOT NULL DEFAULT TRUE,  -- 是否开启充值
    withdraw_enabled     BOOLEAN NOT NULL DEFAULT TRUE,  -- 是否开启提现
    status               SMALLINT NOT NULL DEFAULT 1,  -- 状态: 0=禁用, 1=启用
    created_by           VARCHAR(42) NOT NULL,         -- 创建者 (管理员钱包地址)
    updated_by           VARCHAR(42) NOT NULL,         -- 更新者 (管理员钱包地址)
    created_at           BIGINT NOT NULL,              -- 创建时间 (毫秒时间戳)
    updated_at           BIGINT NOT NULL               -- 更新时间 (毫秒时间戳)
);
```

#### 5.0.2 交易对配置表

```sql
CREATE TABLE eidos_trading_market_configs (
    id              BIGSERIAL PRIMARY KEY,           -- 自增主键
    symbol          VARCHAR(20) NOT NULL UNIQUE,     -- 交易对符号，如 BTC-USDC
    base_token      VARCHAR(10) NOT NULL,            -- 基础代币，如 BTC
    quote_token     VARCHAR(10) NOT NULL,            -- 计价代币，如 USDC
    price_decimals  SMALLINT NOT NULL,               -- 价格精度位数，用于前端显示
    size_decimals   SMALLINT NOT NULL,               -- 数量精度位数，用于前端显示
    tick_size       DECIMAL(36, 18) NOT NULL,        -- 价格最小变动单位，订单价格必须是其整数倍
    step_size       DECIMAL(36, 18) NOT NULL,        -- 数量最小变动单位，订单数量必须是其整数倍
    min_size        DECIMAL(36, 18) NOT NULL,        -- 单笔最小下单数量
    max_size        DECIMAL(36, 18),                 -- 单笔最大下单数量，NULL表示不限
    min_notional    DECIMAL(36, 18) NOT NULL,        -- 最小下单金额 (price * size)
    maker_fee       DECIMAL(10, 6) NOT NULL DEFAULT 0.001,  -- Maker 费率，0.001 = 0.1%
    taker_fee       DECIMAL(10, 6) NOT NULL DEFAULT 0.002,  -- Taker 费率，0.002 = 0.2%
    status          SMALLINT NOT NULL DEFAULT 1,     -- 状态: 0=禁用, 1=启用
    trading_enabled BOOLEAN NOT NULL DEFAULT TRUE,   -- 是否允许交易
    created_by      VARCHAR(42) NOT NULL,            -- 创建者 (管理员钱包地址)
    updated_by      VARCHAR(42) NOT NULL,            -- 更新者 (管理员钱包地址)
    created_at      BIGINT NOT NULL,                 -- 创建时间 (毫秒时间戳)
    updated_at      BIGINT NOT NULL                  -- 更新时间 (毫秒时间戳)
);
```

**交易对配置示例**:
| symbol | price_decimals | size_decimals | tick_size | step_size | min_size | min_notional |
|--------|----------------|---------------|-----------|-----------|----------|--------------|
| BTC-USDC | 2 | 6 | 0.01 | 0.000001 | 0.0001 | 10 |
| ETH-USDC | 2 | 5 | 0.01 | 0.00001 | 0.001 | 10 |
| ARB-USDC | 4 | 2 | 0.0001 | 0.01 | 1 | 10 |

#### 5.0.3 精度计算规则

| 场景 | 规则 | 原因 |
|------|------|------|
| 成交金额 | 向下截断到 quote 精度 | 买方少付，差额归平台 |
| 手续费 | 向下截断到 quote 精度 | 用户少付，保守收费 |
| 链上转账 | 截断到 chain_decimals | 链上不接受超精度 |

### 5.1 订单表

```sql
CREATE TABLE eidos_trading_orders (
    id                    BIGSERIAL PRIMARY KEY,           -- 自增主键
    order_id              VARCHAR(64) NOT NULL UNIQUE,     -- 订单唯一ID (UUID或雪花ID)
    maker                 VARCHAR(42) NOT NULL,            -- 下单用户钱包地址
    market                VARCHAR(20) NOT NULL,            -- 交易对，如 BTC-USDC
    side                  SMALLINT NOT NULL,               -- 买卖方向: 0=买入, 1=卖出
    order_type            SMALLINT NOT NULL,               -- 订单类型: 0=限价单, 1=市价单
    time_in_force         SMALLINT NOT NULL DEFAULT 0,     -- 有效期类型: 0=GTC(一直有效), 1=IOC(立即成交或取消), 2=FOK(全部成交或取消)
    price                 DECIMAL(36, 18) NOT NULL,        -- 委托价格
    size                  DECIMAL(36, 18) NOT NULL,        -- 委托数量 (基础代币数量)
    filled_size           DECIMAL(36, 18) NOT NULL DEFAULT 0,  -- 已成交数量
    remaining_size        DECIMAL(36, 18) NOT NULL,        -- 剩余未成交数量
    avg_fill_price        DECIMAL(36, 18),                 -- 平均成交价格，未成交时为NULL
    frozen_token          VARCHAR(20) NOT NULL,            -- 冻结的代币类型 (买单冻结quote，卖单冻结base)
    frozen_amount         DECIMAL(36, 18) NOT NULL,        -- 总冻结金额
    settled_frozen_amount DECIMAL(36, 18) NOT NULL DEFAULT 0,  -- 来自已结算余额的冻结金额
    pending_frozen_amount DECIMAL(36, 18) NOT NULL DEFAULT 0,  -- 来自待结算余额的冻结金额
    nonce                 BIGINT NOT NULL,                 -- 用户签名的nonce，防重放攻击
    expiration            BIGINT NOT NULL,                 -- 订单过期时间 (毫秒时间戳)
    signature             BYTEA NOT NULL,                  -- EIP-712签名 (65字节)
    config_version        BIGINT NOT NULL,                 -- 下单时的费率配置版本号 (用于撮合验证)
    status                SMALLINT NOT NULL DEFAULT 0,     -- 订单状态: 0=PENDING, 1=OPEN, 2=PARTIAL, 3=FILLED, 4=CANCELLED, 5=EXPIRED, 6=REJECTED
    cancel_reason         VARCHAR(100),                    -- 取消原因 (用户取消/系统取消)
    reject_reason         VARCHAR(100),                    -- 拒绝原因 (撮合引擎拒绝时填写)
    accepted_at           BIGINT,                          -- 撮合引擎接受时间
    first_fill_at         BIGINT,                          -- 首次成交时间
    last_fill_at          BIGINT,                          -- 最后成交时间
    cancelled_at          BIGINT,                          -- 取消时间
    created_at            BIGINT NOT NULL,                 -- 创建时间 (毫秒时间戳)
    updated_at            BIGINT NOT NULL,                 -- 更新时间 (毫秒时间戳)

    INDEX idx_orders_maker (maker),                        -- 用户订单查询
    INDEX idx_orders_market_status (market, status),       -- 市场+状态查询
    INDEX idx_orders_expiration (expiration) WHERE status IN (0, 1, 2)  -- 过期检查 (只索引活跃订单)
);
```

### 5.2 Nonce 表

```sql
CREATE TABLE eidos_trading_nonces (
    id             BIGSERIAL PRIMARY KEY,           -- 自增主键
    wallet_address VARCHAR(42) NOT NULL,            -- 用户钱包地址
    nonce          BIGINT NOT NULL,                 -- 用户使用的nonce值 (由用户指定，非自增)
    usage_type     VARCHAR(20) NOT NULL,            -- 用途类型: ORDER=下单, CANCEL=取消, WITHDRAW=提现
    ref_id         VARCHAR(64) NOT NULL,            -- 关联的业务ID (order_id/withdraw_id)
    used_at        BIGINT NOT NULL,                 -- 使用时间 (毫秒时间戳)

    UNIQUE (wallet_address, usage_type, nonce),     -- 同一用户同一用途的nonce不可重复
    INDEX idx_nonces_used_at (used_at)              -- 用于定期清理历史nonce
);
```

### 5.3 成交表

```sql
CREATE TABLE eidos_trading_trades (
    id                BIGSERIAL PRIMARY KEY,           -- 自增主键
    trade_id          VARCHAR(64) NOT NULL UNIQUE,     -- 成交唯一ID (撮合引擎生成)
    market            VARCHAR(20) NOT NULL,            -- 交易对，如 BTC-USDC
    maker_order_id    VARCHAR(64) NOT NULL,            -- Maker方订单ID (挂单方)
    taker_order_id    VARCHAR(64) NOT NULL,            -- Taker方订单ID (吃单方)
    maker             VARCHAR(42) NOT NULL,            -- Maker方钱包地址
    taker             VARCHAR(42) NOT NULL,            -- Taker方钱包地址
    side              SMALLINT NOT NULL,               -- Taker方向: 0=买入(Maker卖), 1=卖出(Maker买)
    price             DECIMAL(36, 18) NOT NULL,        -- 成交价格 (Maker的挂单价)
    size              DECIMAL(36, 18) NOT NULL,        -- 成交数量 (基础代币)
    quote_amount      DECIMAL(36, 18) NOT NULL,        -- 成交金额 (计价代币，price * size)
    maker_fee         DECIMAL(36, 18) NOT NULL,        -- Maker手续费 (计价代币)
    taker_fee         DECIMAL(36, 18) NOT NULL,        -- Taker手续费 (计价代币)
    config_version    BIGINT NOT NULL,                 -- 成交时的费率配置版本号 (用于结算验证和审计)
    traded_at         BIGINT NOT NULL,                 -- 撮合成交时间 (毫秒时间戳)
    settlement_status SMALLINT NOT NULL DEFAULT 0,     -- 结算状态: 0=待结算, 1=结算中, 2=已结算, 3=结算失败
    settlement_id     VARCHAR(64),                     -- 结算批次ID (链上结算时填写)
    settled_at        BIGINT,                          -- 结算完成时间 (毫秒时间戳)
    created_at        BIGINT NOT NULL,                 -- 记录创建时间 (毫秒时间戳)

    INDEX idx_trades_market (market),                  -- 按市场查询成交
    INDEX idx_trades_traded_at (traded_at),            -- 按时间查询成交
    INDEX idx_trades_maker (maker),                    -- 用户 (Maker) 成交历史
    INDEX idx_trades_taker (taker),                    -- 用户 (Taker) 成交历史
    INDEX idx_trades_maker_order (maker_order_id),     -- 订单成交明细查询
    INDEX idx_trades_taker_order (taker_order_id),     -- 订单成交明细查询
    INDEX idx_trades_settlement (settlement_status) WHERE settlement_status IN (0, 1)  -- 待结算/结算中查询
);
```

### 5.4 余额表

```sql
CREATE TABLE eidos_trading_balances (
    id                BIGSERIAL PRIMARY KEY,           -- 自增主键
    wallet_address    VARCHAR(42) NOT NULL,            -- 用户钱包地址
    token             VARCHAR(20) NOT NULL,            -- 代币符号，如 USDC、BTC
    settled_available DECIMAL(36, 18) NOT NULL DEFAULT 0,  -- 已结算可用余额 (可交易+可提现)
    settled_frozen    DECIMAL(36, 18) NOT NULL DEFAULT 0,  -- 已结算冻结余额 (挂单占用/提现中)
    pending_available DECIMAL(36, 18) NOT NULL DEFAULT 0,  -- 待结算可用余额 (可交易，不可提现)
    pending_frozen    DECIMAL(36, 18) NOT NULL DEFAULT 0,  -- 待结算冻结余额 (挂单占用)
    pending_total     DECIMAL(36, 18) NOT NULL DEFAULT 0,  -- 当前待结算总额 (pending_available + pending_frozen，用于限额控制)
    -- ⚠️ pending_total 维护规则: 每次变更 pending_available 或 pending_frozen 时，必须同步更新 pending_total
    -- pending_total = pending_available + pending_frozen (应用层保证，非 DB 计算列)
    version           BIGINT NOT NULL DEFAULT 0,       -- 版本号，每次更新+1 (用于并发检测告警，非锁控制)
    created_at        BIGINT NOT NULL,                 -- 创建时间 (毫秒时间戳)
    updated_at        BIGINT NOT NULL,                 -- 更新时间 (毫秒时间戳)

    UNIQUE (wallet_address, token),                    -- 每个用户每种代币一条记录
    CONSTRAINT chk_settled_available CHECK (settled_available >= 0),  -- 余额不能为负
    CONSTRAINT chk_settled_frozen CHECK (settled_frozen >= 0),
    CONSTRAINT chk_pending_available CHECK (pending_available >= 0),
    CONSTRAINT chk_pending_frozen CHECK (pending_frozen >= 0),
    CONSTRAINT chk_pending_total CHECK (pending_total >= 0)
);
```

### 5.5 其他表

```sql
-- 资金流水表 (记录所有余额变动)
CREATE TABLE eidos_trading_transactions (
    id             BIGSERIAL PRIMARY KEY,           -- 自增主键
    tx_id          VARCHAR(64) NOT NULL UNIQUE,     -- 流水唯一ID
    wallet_address VARCHAR(42) NOT NULL,            -- 用户钱包地址
    token          VARCHAR(20) NOT NULL,            -- 代币符号
    tx_type        VARCHAR(20) NOT NULL,            -- 流水类型: DEPOSIT=充值, WITHDRAW=提现, TRADE=成交, FEE=手续费, SETTLEMENT=结算, FREEZE=冻结, UNFREEZE=解冻
    amount         DECIMAL(36, 18) NOT NULL,        -- 变动金额 (正数增加，负数减少)
    balance_after  DECIMAL(36, 18) NOT NULL,        -- 变动后余额 (settled_available + pending_available)
    ref_id         VARCHAR(64),                     -- 关联业务ID (trade_id/deposit_id/withdraw_id)
    created_at     BIGINT NOT NULL,                 -- 创建时间 (毫秒时间戳)

    INDEX idx_transactions_wallet_token (wallet_address, token),  -- 用户流水查询
    INDEX idx_transactions_created_at (created_at)                -- 按时间查询
);

-- 充值表 (记录链上充值)
CREATE TABLE eidos_trading_deposits (
    id             BIGSERIAL PRIMARY KEY,           -- 自增主键
    deposit_id     VARCHAR(64) NOT NULL UNIQUE,     -- 充值唯一ID
    wallet_address VARCHAR(42) NOT NULL,            -- 用户钱包地址
    token          VARCHAR(20) NOT NULL,            -- 代币符号
    amount         DECIMAL(36, 18) NOT NULL,        -- 充值金额
    tx_hash        VARCHAR(66) NOT NULL UNIQUE,     -- 链上交易哈希 (幂等键，防重复入账)
    block_number   BIGINT NOT NULL,                 -- 链上区块号
    status         SMALLINT NOT NULL DEFAULT 0,     -- 状态: 0=已入账, 1=处理中 (预留)
    created_at     BIGINT NOT NULL,                 -- 创建时间 (毫秒时间戳)

    INDEX idx_deposits_wallet (wallet_address)      -- 用户充值记录查询
);

-- 提现表 (记录用户提现申请)
CREATE TABLE eidos_trading_withdrawals (
    id             BIGSERIAL PRIMARY KEY,           -- 自增主键
    withdraw_id    VARCHAR(64) NOT NULL UNIQUE,     -- 提现唯一ID
    wallet_address VARCHAR(42) NOT NULL,            -- 用户钱包地址 (发起方)
    token          VARCHAR(20) NOT NULL,            -- 代币符号
    amount         DECIMAL(36, 18) NOT NULL,        -- 提现金额
    fee            DECIMAL(36, 18) NOT NULL DEFAULT 0,  -- 提现手续费 (链上Gas费)
    to_address     VARCHAR(42) NOT NULL,            -- 目标地址 (接收方)
    nonce          BIGINT NOT NULL,                 -- 用户签名的nonce
    signature      BYTEA NOT NULL,                  -- EIP-712签名 (65字节)
    status         SMALLINT NOT NULL DEFAULT 0,     -- 状态: 0=待处理(已冻结), 1=已提交(tx已发), 2=已确认(链上成功), 3=失败(已回滚), 4=超时待查
    tx_hash        VARCHAR(66),                     -- 链上交易哈希 (提交后填写)
    fail_reason    VARCHAR(200),                    -- 失败原因 (链上失败/超时/余额不足等)
    submitted_at   BIGINT,                          -- 提交到链上的时间
    confirmed_at   BIGINT,                          -- 链上确认时间
    created_at     BIGINT NOT NULL,                 -- 创建时间 (毫秒时间戳)
    updated_at     BIGINT NOT NULL,                 -- 更新时间 (毫秒时间戳)

    INDEX idx_withdrawals_wallet (wallet_address),  -- 用户提现记录查询
    INDEX idx_withdrawals_status (status) WHERE status IN (0, 1)  -- 待处理提现查询 (部分索引)
);

-- Outbox 消息表 (DB 层 Outbox，用于非订单类事件的可靠投递)
-- ⚠️ 角色说明:
--   - 订单投递: 使用 Redis Outbox (eidos:trading:outbox:order:{order_id})，详见 2.3 节
--   - 本 DB 表用途: 余额变更事件、结算事件等需 DB 事务保证的场景
--   - 投递流程: DB Transaction 写入 → Relay 轮询 → Kafka
CREATE TABLE eidos_trading_outbox_messages (
    id             BIGSERIAL PRIMARY KEY,           -- 自增主键
    message_id     VARCHAR(64) NOT NULL UNIQUE,     -- 消息唯一ID
    topic          VARCHAR(100) NOT NULL,           -- Kafka topic名称
    partition_key  VARCHAR(100) NOT NULL,           -- Kafka分区键 (通常为order_id或wallet)
    payload        JSONB NOT NULL,                  -- 消息内容 (JSON格式)
    aggregate_type VARCHAR(50) NOT NULL,            -- 聚合根类型: ORDER, TRADE, BALANCE, WITHDRAW
    aggregate_id   VARCHAR(64) NOT NULL,            -- 聚合根ID (order_id/trade_id等)
    status         VARCHAR(20) NOT NULL DEFAULT 'pending',  -- 状态: pending=待发送, sent=已发送, failed=失败, cancelled=已取消(PENDING订单取消时标记)
    retry_count    INT NOT NULL DEFAULT 0,          -- 重试次数
    max_retries    INT NOT NULL DEFAULT 5,          -- 最大重试次数
    next_retry_at  BIGINT,                          -- 下次重试时间 (指数退避)
    last_error     VARCHAR(500),                    -- 最后一次错误信息
    created_at     BIGINT NOT NULL,                 -- 创建时间 (毫秒时间戳)
    sent_at        BIGINT,                          -- 发送成功时间 (毫秒时间戳)

    INDEX idx_outbox_pending (status, created_at) WHERE status = 'pending',  -- Relay 扫描待发送
    INDEX idx_outbox_retry (status, next_retry_at) WHERE status = 'failed'   -- 重试扫描
);

-- 订单冻结来源表 (记录每笔订单冻结的来源，便于成交/取消时精确解冻)
-- 生命周期: 订单创建时插入，订单完结(FILLED/CANCELLED/EXPIRED/REJECTED)后由定时任务清理
CREATE TABLE eidos_trading_order_freezes (
    id                BIGSERIAL PRIMARY KEY,           -- 自增主键
    order_id          VARCHAR(64) NOT NULL,            -- 订单ID
    wallet_address    VARCHAR(42) NOT NULL,            -- 用户钱包地址
    token             VARCHAR(20) NOT NULL,            -- 冻结的代币符号
    settled_frozen    DECIMAL(36, 18) NOT NULL DEFAULT 0,  -- 初始从已结算余额冻结的金额
    pending_frozen    DECIMAL(36, 18) NOT NULL DEFAULT 0,  -- 初始从待结算余额冻结的金额
    remaining_settled DECIMAL(36, 18) NOT NULL DEFAULT 0,  -- 剩余的已结算冻结金额 (成交后递减)
    remaining_pending DECIMAL(36, 18) NOT NULL DEFAULT 0,  -- 剩余的待结算冻结金额 (成交后递减)
    created_at        BIGINT NOT NULL,                 -- 创建时间 (毫秒时间戳)
    updated_at        BIGINT NOT NULL,                 -- 更新时间 (毫秒时间戳)

    UNIQUE (order_id),                                 -- 每个订单一条记录
    INDEX idx_order_freezes_wallet (wallet_address)    -- 用户冻结查询
);

-- 配置版本表 (确保 Trading 和 Matching 使用相同费率，支持配置回溯)
CREATE TABLE eidos_trading_config_versions (
    id           BIGSERIAL PRIMARY KEY,           -- 自增主键
    config_type  VARCHAR(50) NOT NULL,            -- 配置类型: MARKET_FEE=交易对费率, TOKEN=代币配置
    config_key   VARCHAR(100) NOT NULL,           -- 配置键: 交易对符号或代币符号
    config_value JSONB NOT NULL,                  -- 配置内容 (JSON格式，包含完整配置)
    version      BIGINT NOT NULL,                 -- 配置版本号 (递增)
    effective_at BIGINT NOT NULL,                 -- 生效时间 (毫秒时间戳)
    created_by   VARCHAR(42) NOT NULL,            -- 创建者 (管理员钱包地址)
    created_at   BIGINT NOT NULL,                 -- 创建时间 (毫秒时间戳)

    UNIQUE (config_type, config_key, version),    -- 同类型同键的版本唯一
    INDEX idx_config_versions_effective (config_type, config_key, effective_at)  -- 按生效时间查询
);
```

---

## 六、Redis 缓存设计

### 6.1 Key 命名规范

```
格式: eidos:trading:{业务域}:{标识符}

示例:
- eidos:trading:balance:{wallet}:{token}      余额 (Hash)
- eidos:trading:order:{order_id}              订单缓存
- eidos:trading:nonce:{wallet}:{usage}:{nonce} Nonce 标记
- eidos:trading:sig:{signature_hash}          签名验证缓存
- eidos:trading:config:market:{symbol}        交易对配置
- eidos:trading:limit:withdraw:{wallet}:{date} 每日提现累计
- eidos:trading:idempotent:trade:{trade_id}   成交幂等
- eidos:trading:outbox:order:{order_id}       Outbox 订单状态 (Hash)
- eidos:trading:outbox:pending:{shard}        Outbox 待投递队列 (List)
- eidos:trading:outbox:processing:{shard}     Outbox 投递中队列 (List)
- eidos:trading:order_freeze:{order_id}       订单冻结记录 (Hash)
- eidos:trading:fee_bucket:{market}:{token}:{bucket} 手续费分桶 (String)
```

### 6.2 核心数据结构 (资金真相)

> ⚠️ 以下结构是**资金操作的实时真相**，所有冻结/解冻/清算都在这些结构上原子执行

**余额结构** (Hash):
```
eidos:trading:balance:{wallet}:{token} = {
  "settled_available": "1000.000000",    // 已结算可用
  "settled_frozen": "100.000000",        // 已结算冻结
  "pending_available": "50.000000",      // 待结算可用
  "pending_frozen": "10.000000",         // 待结算冻结
  "version": 123                         // 版本号 (用于对账)
}
```

**订单冻结记录** (Hash):
```
eidos:trading:order_freeze:{order_id} = {
  "wallet": "0x...",
  "token": "USDC",
  "frozen_amount": "100.000000",         // 总冻结金额
  "settled_frozen": "80.000000",         // 来自已结算的冻结
  "pending_frozen": "20.000000",         // 来自待结算的冻结
  "remaining_settled": "80.000000",      // 剩余已结算冻结 (成交后递减)
  "remaining_pending": "20.000000",      // 剩余待结算冻结 (成交后递减)
  "created_at": 1704067200000
}
TTL: 订单终态后 24h 自动过期
```

**Outbox 订单记录** (Hash):
```
eidos:trading:outbox:order:{order_id} = {
  "status": "PENDING|PROCESSING|SENT|CANCELLED|DEAD",
  "order_json": "{...}",
  "shard": 0,
  "retry_count": 0,
  "created_at": 1704067200000,
  "updated_at": 1704067200000
}
TTL: SENT/CANCELLED 后 1h 自动过期
```

**Outbox 队列** (List):
```
eidos:trading:outbox:pending:{shard}     // 待投递队列，LPUSH 入队
eidos:trading:outbox:processing:{shard}  // 投递中队列，BRPOPLPUSH 转移
```

**手续费分桶** (String):
```
eidos:trading:fee_bucket:{market}:{token}:{bucket_id}
// 值: 累计金额，使用 INCRBYFLOAT 原子累加
// bucket_id: 0-15 (共 16 桶)
```

> **Redis/DB 关系说明**:
> - **实时路径**: 成交清算时 Redis Lua 执行 `INCRBYFLOAT fee_bucket:{market}:{token}:{bucket} += fee`
> - **定期归集**: 定时任务 (如每小时) 执行:
>   1. `GETSET fee_bucket:{market}:{token}:{bucket} 0` 原子读取并清零 Redis
>   2. 累加到 DB `fee_buckets` 表对应行
> - **DB 表用途**: 手续费归集账本，供财务对账、分润结算使用
> - **为何分桶**: 16 桶分散热点，避免单 key 成为瓶颈

**幂等标记** (String, TTL):
```
eidos:trading:deposit:{tx_hash}          // 充值幂等，TTL 7d
eidos:trading:withdraw:{withdraw_id}     // 提现幂等，TTL 7d
eidos:trading:settlement:{settlement_id} // 结算幂等，TTL 7d
eidos:trading:trade:{trade_id}           // 成交幂等，TTL 24h
```

### 6.3 缓存策略

| 缓存类型 | TTL | 一致性策略 | 用途 |
|----------|-----|------------|------|
| 余额缓存 | 5m | 写后失效 | 高频读取加速 |
| 订单缓存 | 1h | 终态删除 | 活跃订单查询 |
| 配置缓存 | 10m | 双层缓存 (L1 本地 + L2 Redis) | 交易对/代币配置 |
| 签名缓存 | 5m | - | 避免重复 ecrecover |
| 幂等缓存 | 24h | - | 防重复处理 |
| 限额缓存 | 25h | INCRBYFLOAT | 每日提现限额 |
| Nonce 缓存 | 7d | Lua 脚本更新 | 快速重放检测 |

### 6.4 缓存监控指标

- `trading_cache_hit_total{cache_type}` - 缓存命中数
- `trading_cache_miss_total{cache_type}` - 缓存未命中数
- `trading_cache_latency_seconds{cache_type, operation}` - 缓存操作延迟

---

## 七、错误码

```
签名相关:
  TRADING_INVALID_SIGNATURE     签名无效
  TRADING_SIGNER_MISMATCH       签名者不匹配
  TRADING_ORDER_EXPIRED         订单已过期
  TRADING_NONCE_ALREADY_USED    Nonce 已使用 (同一 wallet+usage_type 下重复)

余额相关:
  TRADING_INSUFFICIENT_BALANCE  余额不足

订单相关:
  TRADING_ORDER_NOT_FOUND       订单不存在
  TRADING_ORDER_NOT_CANCELLABLE 订单不可取消
  TRADING_ORDER_REJECTED        订单被撮合引擎拒绝
  TRADING_SELF_TRADE_REJECTED   自成交被拒绝
  TRADING_ORDER_ID_CONFLICT     订单ID已存在但参数不一致

精度相关:
  TRADING_INVALID_PRICE_PRECISION  价格精度不符合 tick_size
  TRADING_INVALID_SIZE_PRECISION   数量精度不符合 step_size
  TRADING_SIZE_TOO_SMALL           数量小于 min_size
  TRADING_SIZE_TOO_LARGE           数量大于 max_size
  TRADING_NOTIONAL_TOO_SMALL       金额小于 min_notional

市场相关:
  TRADING_MARKET_NOT_FOUND      市场不存在
  TRADING_MARKET_SUSPENDED      市场暂停

提现相关:
  TRADING_WITHDRAW_MIN_AMOUNT   低于最小提现额
  TRADING_WITHDRAW_DAILY_LIMIT  超过每日限额
  TRADING_WITHDRAW_DISABLED     提现功能已关闭

限额相关:
  TRADING_PENDING_LIMIT_EXCEEDED     用户待结算限额超限
  TRADING_GLOBAL_PENDING_EXCEEDED    全局待结算限额超限

配置相关:
  TRADING_CONFIG_VERSION_MISMATCH    配置版本不匹配
```

---

## 八、配置

```yaml
service:
  name: eidos-trading
  grpc_port: 50051

postgres:
  host: postgres
  port: 5432
  database: eidos_trading
  max_connections: 200

redis:
  cluster:
    nodes: [redis-1:6379, redis-2:6379, redis-3:6379]
  # ⚠️ 安全配置 (云组件默认加密，本地开发可关闭)
  security:
    enabled: true                     # 生产环境必须开启，本地开发可关闭
    tls:
      enabled: true                   # 是否启用 TLS 加密传输
      cert_file: "/etc/ssl/redis.crt" # TLS 证书 (云组件通常自动配置)
      key_file: "/etc/ssl/redis.key"  # TLS 私钥
      ca_file: "/etc/ssl/ca.crt"      # CA 证书
    auth:
      enabled: true                   # 是否启用密码认证
      password_env: "REDIS_PASSWORD"  # 密码从环境变量读取，禁止明文配置
  # 说明: 阿里云/AWS 等云 Redis 服务默认提供 TLS + 密码认证
  #       本地开发时可设置 security.enabled: false 跳过安全配置

kafka:
  brokers: [kafka-1:9092, kafka-2:9092, kafka-3:9092]
  consumer:
    group_id: eidos-trading
    topics: [order-cancelled, trade-results, deposits, settlement-confirmed, withdrawal-confirmed]
  producer:
    topics:
      orders: orders
      cancel_requests: cancel-requests
      balance_updates: balance-updates
      order_updates: order-updates
      settlements: settlements
      withdrawals: withdrawals
      config_updates: config-updates
  # Topic 命名说明: 本文档使用 kebab-case (如 order-cancelled)
  # 完整 Topic 列表见: docs/3-开发规范/00-协议总表.md

eip712:
  domain:
    name: "EidosExchange"
    version: "1"
    chain_id: 42161
    verifying_contract: "0x..."

platform:
  fee_account: "0x..."           # 主手续费账户地址 (归集目标)
  treasury_account: "0x..."      # 国库账户地址 (可选)
  fee_bucket:
    enabled: true                # 是否启用手续费分桶
    salt: "fee_bucket"           # 分桶地址生成盐值
    consolidation_interval: 1h   # 归集间隔
    min_consolidation: "100"     # 最小归集金额 (USDC)

risk:
  enabled: true
  grpc_addr: "eidos-risk:50055"
  timeout: 100ms

nonce:
  cache_ttl: 168h                       # Redis 缓存过期时间 (7 天)
  cleanup_retention: 168h               # DB 记录保留时间 (7 天后可被清理)

fee:
  max_rate: 0.05                        # 最大费率 5%
  tolerance_ratio: 0.001                # 验证容差比例 0.1%
  min_tolerance: "0.01"                 # 最小容差绝对值 (USDC)

limits:
  max_open_orders_per_user_per_market: 200
  min_order_value: "10"
  max_order_value: "1000000"
  pending_limit:                        # 待结算限额控制
    enabled: true
    default_max_pending: "100000"       # 单用户默认待结算上限 (USDC)
    global_max_pending: "10000000"      # 全局待结算上限
    check_interval: 1m                  # 检查间隔

timeout:
  ioc_fok: 5s                           # IOC/FOK 订单响应超时
  pending_order_alert: 30s              # PENDING 订单告警阈值
  withdrawal_confirm: 5m                # 提现确认超时

cache:
  balance: { ttl: 5m, enabled: true }
  order: { ttl: 1h, enabled: true }
  config: { local_ttl: 30s, redis_ttl: 10m, check_interval: 5s }  # L1本地+L2 Redis
  signature: { ttl: 5m, enabled: true }
  idempotency: { trade_ttl: 24h, message_ttl: 168h }

outbox:
  relay:
    enabled: true
    poll_interval: 100ms        # 扫描间隔
    batch_size: 100             # 每批处理数量
    retry_delays: [1s, 5s, 30s, 2m, 10m]  # 重试间隔
  cleanup:
    enabled: true
    retention: 168h             # 保留7天
    interval: 1h                # 清理间隔
```

---

## 九、监控与告警

### 9.1 核心指标

| 指标 | 类型 | 说明 |
|------|------|------|
| trading_order_created_total | Counter | 订单创建数 |
| trading_order_cancelled_total | Counter | 订单取消数 |
| trading_trade_processed_total | Counter | 成交处理数 |
| trading_balance_operation_total | Counter | 余额操作数 |
| trading_signature_verify_duration | Histogram | 签名验证耗时 |
| trading_clearing_duration | Histogram | 清算处理耗时 |
| trading_cache_hit_total | Counter | 缓存命中数 |
| trading_pending_balance_total | Gauge | 全局待结算余额 |
| trading_pending_balance_user | Gauge | 单用户待结算余额 (top N) |
| trading_outbox_queue_size | Gauge | Outbox 待发送消息数 |
| trading_outbox_send_duration | Histogram | Outbox 发送耗时 |
| trading_outbox_retry_total | Counter | Outbox 重试次数 |
| trading_settlement_pending_count | Gauge | 待结算成交数 |
| trading_withdrawal_pending_count | Gauge | 待处理提现数 |

### 9.2 告警级别

| 级别 | 响应时间 | 场景示例 |
|------|----------|----------|
| P0 | 立即 | 余额负数、清算失败、链上链下不一致 |
| P1 | 15分钟 | 订单积压、手续费误差大、Kafka 延迟 |
| P2 | 1小时 | 签名验证慢、缓存命中率低 |

### 9.3 告警场景

| 告警名 | 级别 | 阈值 |
|--------|------|------|
| BalanceNegative | P0 | 任何余额 < 0 |
| ClearingFailed | P0 | 清算失败 |
| BalanceReconciliationFailed | P0 | 链上链下差异 > 0.000001 |
| GlobalPendingLimitExceeded | P0 | 全局待结算超限 |
| OutboxDeadLetter | P0 | Outbox 消息进入死信 |
| OrderBacklog | P1 | Kafka lag > 1000 |
| FeeDiscrepancy | P1 | 手续费误差 > 0.1% |
| SelfTradeDetected | P1 | 检测到自成交 |
| UserPendingLimitExceeded | P1 | 单用户待结算超限 |
| OutboxQueueHigh | P1 | 待发送消息 > 1000 |
| SettlementPendingHigh | P1 | 待结算成交 > 10000 |
| WithdrawalPendingHigh | P1 | 待处理提现 > 100 |
| SignatureVerifySlow | P2 | p99 > 50ms |
| CacheHitRateLow | P2 | 命中率 < 80% |
| SettlementFailed | P0 | 结算失败 |

### 9.4 结算熔断与自动恢复

> **问题**: 链上结算连续失败时需要熔断保护，防止继续产生无法结算的成交

**熔断触发条件**:
| 条件 | 动作 |
|------|------|
| 连续 3 次结算失败 | 触发熔断，暂停新单入场 |
| 待结算成交 > 10000 笔 | 触发熔断，暂停新单入场 |
| 单笔结算超时 > 5 分钟 | 标记结算失败，计入连续失败计数 |

**自动恢复条件**:
| 条件 | 动作 |
|------|------|
| 成功结算 1 笔后 | 重置连续失败计数，但不自动解除熔断 |
| 成功结算 3 笔后 | 自动解除熔断，恢复新单入场 |
| 待结算成交 < 5000 笔 | 允许手动解除熔断 |
| 运维手动确认 | 强制解除熔断 (需审批) |

**熔断状态机**:
```
┌────────┐   连续3次失败   ┌─────────┐   成功3笔   ┌────────┐
│ NORMAL │───────────────>│ CIRCUIT │────────────>│ NORMAL │
└────────┘                │ BREAKER │              └────────┘
                          └────┬────┘
                               │ 运维确认解除
                               ▼
                          ┌────────┐
                          │ NORMAL │
                          └────────┘
```

### 9.5 余额查询数据源

> **明确**: Redis 是实时资金真相，DB 是异步物化

| 查询场景 | 数据源 | 说明 |
|----------|--------|------|
| 实时余额查询 (交易/下单) | Redis | 毫秒级实时，用于交易判断 |
| 用户余额展示 | Redis | 直接读取，保证用户看到最新余额 |
| 历史流水查询 | DB | 异步落盘，可能延迟数秒 |
| 对账/审计 | DB | 完整记录，用于财务审计 |
| 导出/报表 | DB | 批量查询，避免影响 Redis 性能 |

**查询接口设计**:
```go
// GetBalance 实时余额查询 (优先 Redis)
func (s *BalanceService) GetBalance(ctx context.Context, wallet, token string) (*Balance, error) {
    // 1. 从 Redis 读取实时余额
    balance, err := s.redisClient.GetBalance(ctx, wallet, token)
    if err == nil {
        return balance, nil
    }

    // 2. Redis 不可用时降级到 DB (只读，可能有延迟)
    if errors.Is(err, redis.Nil) || isRedisUnavailable(err) {
        log.Warn("Redis unavailable, fallback to DB", "wallet", wallet)
        return s.db.GetBalance(ctx, wallet, token)
    }

    return nil, err
}

// GetBalanceHistory 历史流水查询 (只读 DB)
func (s *BalanceService) GetBalanceHistory(ctx context.Context, wallet, token string, limit int) ([]*Transaction, error) {
    return s.db.GetTransactions(ctx, wallet, token, limit)
}
```

---

## 十、定时任务协作 (eidos-jobs)

| 任务 | 执行间隔 | 描述 |
|------|----------|------|
| 订单过期检查 | 1 分钟 | 检查并处理过期订单，解冻资金 |
| PENDING 订单超时检查 | 30 秒 | 检查 PENDING > 30s 的订单，触发告警并查询撮合引擎状态 |
| 提现超时检查 | 1 分钟 | 检查已提交但未确认的提现 (status=1)，超时标记为待查 (status=4) |
| Nonce 清理 | 1 小时 | 删除 7 天前的 nonce 记录 |
| Outbox 清理 | 1 小时 | 删除已发送/已取消的 outbox 消息 |
| 冻结记录清理 | 1 小时 | 删除已完结订单的 order_freezes 记录 |
| 手续费归集 | 1 小时 | 将分桶账户余额归集到主平台账户 |
| pending_total 校验 | 1 小时 | 校验 pending_total = pending_available + pending_frozen |
| 配置版本清理 | 每日 01:00 | 清理 90 天前的配置版本 (保留最近 100 个) |
| 交易归档 | 每日 02:00 | 归档 30 天前的成交记录 |
| 余额对账 | 每日 03:00 | 检查链上链下余额一致性 |

---

## 十一、配置版本同步

> **问题**: Trading 和 Matching 服务需使用相同费率配置

**解决方案**:
1. Admin 修改费率时，写入 `eidos_trading_config_versions` 表并通过 Kafka 广播
2. Trading 和 Matching 都订阅配置变更消息，本地缓存配置
3. 订单消息携带 `config_version` 字段
4. Matching 使用订单指定版本的费率计算手续费
5. Trading 清算时用相同版本重新计算并验证，容差 0.1%

**⚠️ config_version 生成规则 (重要)**:

> **安全原则**: `config_version` 由服务端生成，不信任客户端传入

```go
// 订单创建时，Trading 服务负责填充 config_version
func (s *OrderService) CreateOrder(ctx context.Context, req *CreateOrderRequest) (*Order, error) {
    // ❌ 错误: 信任客户端传入的 config_version
    // order.ConfigVersion = req.ConfigVersion

    // ✅ 正确: 服务端获取当前生效的配置版本
    marketConfig, err := s.configService.GetEffectiveConfig(req.Market)
    if err != nil {
        return nil, err
    }
    order.ConfigVersion = marketConfig.Version

    // ... 其余处理
}
```

| 项目 | 说明 |
|------|------|
| **生成时机** | Trading 处理 CreateOrder 时从本地缓存获取当前生效版本 |
| **来源** | 服务端 `config_versions` 表/缓存，非客户端参数 |
| **一致性** | Trading 和 Matching 订阅相同 Kafka topic，保证配置同步 |
| **容错** | 本地缓存未命中时从 DB 加载，仍不存在则拒绝下单 |

**配置同步 Kafka topic**: `config-updates`

**版本不匹配处理**:
| 场景 | 检测方 | 处理 |
|------|--------|------|
| 订单创建时本地无该版本 | Trading | 从 DB 加载版本，若不存在则拒绝 (TRADING_CONFIG_VERSION_MISMATCH) |
| 撮合时版本过期 | Matching | 继续使用订单版本处理，触发 P2 告警 |
| 清算时版本不存在 | Trading | 从 DB 加载历史版本，若加载失败则人工介入 |
| 手续费差异超容差 | Trading | 拒绝清算，触发 P1 告警，订单进入待人工核查 |

**配置版本保留策略**:
- 历史版本保留 90 天，支持回溯验证
- 定时任务清理过期版本 (保留至少最近 100 个版本)

---

## 十二、Kafka 消费策略

### 12.1 重试策略

| 阶段 | 次数 | 间隔 | 处理 |
|------|------|------|------|
| 立即重试 | 3 | 0 | 临时错误 |
| 延迟重试 | 5 | 1s, 5s, 30s, 2m, 10m | 可恢复错误 |
| 死信队列 | - | - | 超过重试次数 |

### 12.2 幂等性保障

1. 事务外快速检查 Redis 缓存
2. 事务内查询数据库确认
3. 处理业务逻辑
4. 事务提交后写缓存

---

## 十三、扩展规划

### 13.1 永续合约

**新增组件**:
- eidos-liquidator: 强平服务，监控仓位风险

**新增表**:
- eidos_trading_positions: 仓位表
- eidos_trading_funding_rates: 资金费率表
- eidos_trading_funding_settlements: 资金费结算表

### 13.2 预测市场

**核心机制**:
- 镜像订单: 买 YES = 卖 NO，原子执行
- 代币拆分: 1 USDC → 1 YES + 1 NO
- 代币合并: 1 YES + 1 NO → 1 USDC

**新增表**:
- eidos_trading_prediction_markets: 预测市场表
- eidos_trading_linked_orders: 关联订单表
- eidos_trading_token_operations: 代币操作表
