# Eidos 撮合引擎设计

> 服务名: eidos-matching
> 语言: Go

> **补充设计**: 关于快照原子性、最新价维护、分布式时间戳等内容，
> 请参阅 [00-设计补充-一致性与可靠性.md](./00-设计补充-一致性与可靠性.md)

---

## 一、服务职责

### 1.1 核心定位

Matching Engine (撮合引擎) 是交易所的核心中的核心，负责订单匹配和成交。参考 Binance、OKX、火币等主流交易所的撮合引擎设计，采用 **红黑树 + 双向链表** 的业界标准数据结构，实现 **价格优先、时间优先** 的撮合规则。

### 1.2 设计目标

| 指标 | Phase 1 目标 | Phase 2 目标 | 主流交易所参考 |
|------|-------------|-------------|---------------|
| **单引擎 TPS** | 100,000+ | 500,000+ | OKX/火币 10万+，Binance 100万+ |
| **撮合延迟 P50** | < 0.5ms | < 0.1ms | 毫秒级 |
| **撮合延迟 P99** | < 2ms | < 1ms | < 5ms |
| **订单簿深度** | 100万订单 | 500万订单 | 百万级 |
| **故障恢复时间** | < 10s | < 5s | 秒级 |

### 1.3 职责边界

| 职责 | 描述 | 属于本服务 |
|------|------|-----------|
| 订单簿管理 | 维护内存订单簿 | ✅ |
| 订单匹配 | 价格优先、时间优先撮合 | ✅ |
| 成交生成 | 生成成交记录 | ✅ |
| 订单簿快照 | 定期生成快照供恢复 | ✅ |
| 订单验证 | 签名验证、余额检查 | ❌ (eidos-trading) |
| 余额处理 | 冻结、划转、清算 | ❌ (eidos-trading) |
| 行情计算 | K线、Ticker | ❌ (eidos-market) |
| 风控检查 | 价格偏离、洗盘监控 | ❌ (eidos-risk) |

### 1.4 对外提供的能力

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Matching Engine 对外能力                                  │
│                                                                              │
│  核心特点: 无状态输入、确定性输出                                            │
│  ═══════════════════════════════════                                         │
│                                                                              │
│  输入 (Kafka 消费):                                                          │
│  ─────────────────                                                           │
│  - topic: orders           接收新订单                                        │
│  - topic: cancel-requests  接收取消请求                                      │
│                                                                              │
│  输出 (Kafka 生产):                                                          │
│  ─────────────────                                                           │
│  - topic: trade-results    成交结果 (给 eidos-trading, eidos-market, eidos-risk) │
│  - topic: order-cancelled  取消确认 (给 eidos-trading)                      │
│  - topic: orderbook-updates 订单簿增量更新 (给 eidos-market)                │
│                                                                              │
│  内部能力:                                                                   │
│  ───────────                                                                 │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐              │
│  │  AddOrder       │  │  CancelOrder    │  │  GetOrderBook   │              │
│  │  添加订单到簿   │  │  从簿中移除     │  │  获取订单簿快照 │              │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘              │
│                                                                              │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐              │
│  │  MatchOrder     │  │  Snapshot       │  │  Restore        │              │
│  │  执行撮合       │  │  生成快照       │  │  从快照恢复     │              │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘              │
│                                                                              │
│  注意: 撮合引擎不提供 gRPC 接口，纯事件驱动                                  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 二、详细设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       Matching Engine 内部架构                               │
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                      Kafka Consumer Group                           │     │
│  │                                                                     │     │
│  │  topics: orders, cancel-requests                                   │     │
│  │  partition: 按 market 分区，保证同交易对顺序                        │     │
│  └───────────────────────────────┬────────────────────────────────────┘     │
│                                  │                                          │
│                                  ▼                                          │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                      Router / Dispatcher                            │     │
│  │                                                                     │     │
│  │  根据 market 路由到对应的 MatchingEngine 实例                       │     │
│  │  每个交易对一个独立的引擎实例 (单线程)                              │     │
│  └───────────────────────────────┬────────────────────────────────────┘     │
│                                  │                                          │
│         ┌────────────────────────┼────────────────────────────────┐         │
│         │                        │                                │         │
│         ▼                        ▼                                ▼         │
│  ┌──────────────┐        ┌──────────────┐                ┌──────────────┐  │
│  │ BTC-USDC     │        │ ETH-USDC     │       ...      │ XXX-USDC     │  │
│  │ Engine       │        │ Engine       │                │ Engine       │  │
│  │              │        │              │                │              │  │
│  │ ┌──────────┐ │        │ ┌──────────┐ │                │ ┌──────────┐ │  │
│  │ │OrderBook │ │        │ │OrderBook │ │                │ │OrderBook │ │  │
│  │ │          │ │        │ │          │ │                │ │          │ │  │
│  │ │ Bids     │ │        │ │ Bids     │ │                │ │ Bids     │ │  │
│  │ │ (红黑树) │ │        │ │ (红黑树) │ │                │ │ (红黑树) │ │  │
│  │ │          │ │        │ │          │ │                │ │          │ │  │
│  │ │ Asks     │ │        │ │ Asks     │ │                │ │ Asks     │ │  │
│  │ │ (红黑树) │ │        │ │ (红黑树) │ │                │ │ (红黑树) │ │  │
│  │ └──────────┘ │        │ └──────────┘ │                │ └──────────┘ │  │
│  │              │        │              │                │              │  │
│  │ goroutine    │        │ goroutine    │                │ goroutine    │  │
│  │ (单线程)     │        │ (单线程)     │                │ (单线程)     │  │
│  └──────────────┘        └──────────────┘                └──────────────┘  │
│         │                        │                                │         │
│         └────────────────────────┴────────────────────────────────┘         │
│                                  │                                          │
│                                  ▼                                          │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                      Kafka Producer                                 │     │
│  │                                                                     │     │
│  │  topics: trade-results, order-cancelled, orderbook-updates         │     │
│  └────────────────────────────────────────────────────────────────────┘     │
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                      Snapshot Manager                               │     │
│  │                                                                     │     │
│  │  - 定期保存订单簿快照到 Redis                                       │     │
│  │  - 故障恢复时从快照 + Kafka 回放重建                                │     │
│  └────────────────────────────────────────────────────────────────────┘     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 订单簿数据结构 (业界标准方案)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    订单簿数据结构 (参考主流交易所)                           │
│                                                                              │
│  核心数据结构: 红黑树 + 双向链表                                             │
│  ════════════════════════════════                                            │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                                                                      │    │
│  │  Layer 1: 红黑树 (按价格索引)                                       │    │
│  │  ────────────────────────────                                        │    │
│  │                                                                      │    │
│  │  卖单树 (Asks)                       买单树 (Bids)                  │    │
│  │  价格升序排列                        价格降序排列                    │    │
│  │                                                                      │    │
│  │       [50100]                             [49900]                   │    │
│  │      /      \                            /      \                   │    │
│  │  [50050]   [50150]                  [49850]   [49950]              │    │
│  │    /  \                               /  \                          │    │
│  │ [50000] [50075]                   [49800] [49875]                  │    │
│  │    ↑                                  ↑                             │    │
│  │  bestAsk                           bestBid                          │    │
│  │  (最优卖价)                         (最优买价)                       │    │
│  │                                                                      │    │
│  │  Layer 2: 双向链表 (同价格按时间排序)                               │    │
│  │  ──────────────────────────────────────                              │    │
│  │                                                                      │    │
│  │  每个价格节点指向一个订单链表:                                       │    │
│  │                                                                      │    │
│  │  PriceLevel[50000] → Order1 ↔ Order2 ↔ Order3                       │    │
│  │                      (最早)           (最晚)                         │    │
│  │                                                                      │    │
│  │  时间优先: 新订单追加到链表尾部                                     │    │
│  │  撮合时: 从链表头部开始成交                                         │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.3 核心数据结构定义

```go
// 定点数精度: 使用 int64 表示，精度为 10^8
// 例如: 50000.12345678 表示为 5000012345678
const PricePrecision = 100000000  // 10^8

// 价格档位
type PriceLevel struct {
    Price      int64        // 价格 (定点数)
    TotalQty   int64        // 该价位总数量
    OrderCount int32        // 订单数量
    Head       *Order       // 订单链表头 (时间最早)
    Tail       *Order       // 订单链表尾 (时间最晚)
}

// 订单
type Order struct {
    ID         uint64       // 订单 ID
    OrderID    string       // 业务订单 ID (UUID)
    UserID     string       // 用户钱包地址
    Price      int64        // 价格 (定点数)
    OrigQty    int64        // 原始数量
    Quantity   int64        // 剩余数量
    Side       int8         // 0=买, 1=卖
    Type       int8         // 0=限价, 1=市价
    TIF        int8         // 0=GTC, 1=IOC, 2=FOK
    Timestamp  int64        // 下单时间 (纳秒)
    Prev       *Order       // 同价格前一个订单
    Next       *Order       // 同价格后一个订单
    Level      *PriceLevel  // 所属价格档位 (反向引用)
}

// 订单簿
type OrderBook struct {
    Symbol   string                    // 交易对
    Bids     *rbtree.Tree              // 买单红黑树 (价格降序)
    Asks     *rbtree.Tree              // 卖单红黑树 (价格升序)
    BestBid  *PriceLevel               // 最优买价缓存
    BestAsk  *PriceLevel               // 最优卖价缓存
    Orders   map[string]*Order         // orderID -> Order 快速查找

    // 统计信息
    BidCount  int64                    // 买单数量
    AskCount  int64                    // 卖单数量
    BidVolume int64                    // 买单总量
    AskVolume int64                    // 卖单总量
}

// 成交记录
type Trade struct {
    TradeID       string
    MakerOrderID  string
    TakerOrderID  string
    Maker         string    // 挂单方
    Taker         string    // 吃单方
    Price         int64
    Quantity      int64
    MakerFee      int64
    TakerFee      int64
    IsMakerBuyer  bool      // maker 是否是买方
    Timestamp     int64
}

// 对象池 (减少 GC 压力)
var orderPool = sync.Pool{
    New: func() interface{} {
        return &Order{}
    },
}

var priceLevelPool = sync.Pool{
    New: func() interface{} {
        return &PriceLevel{}
    },
}
```

### 2.4 撮合算法

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           撮合算法流程                                       │
│                                                                              │
│  撮合规则:                                                                   │
│  ═════════                                                                   │
│  1. 价格优先: 买单价高者优先成交，卖单价低者优先成交                         │
│  2. 时间优先: 同价格先到者优先成交                                           │
│  3. 成交价格: 按挂单方 (Maker) 价格成交                                      │
│                                                                              │
│  限价买单撮合流程:                                                           │
│  ─────────────────                                                           │
│                                                                              │
│  func (e *Engine) MatchLimitBuy(order *Order) []*Trade {                    │
│      var trades []*Trade                                                     │
│                                                                              │
│      // 遍历卖单簿，从最低价开始                                             │
│      for e.orderBook.BestAsk != nil {                                        │
│          bestAsk := e.orderBook.BestAsk                                      │
│                                                                              │
│          // 如果买价 < 最低卖价，无法成交                                    │
│          if order.Price < bestAsk.Price {                                    │
│              break                                                           │
│          }                                                                   │
│                                                                              │
│          // 遍历该价位的所有订单 (时间优先)                                  │
│          makerOrder := bestAsk.Head                                          │
│          for makerOrder != nil && order.Quantity > 0 {                       │
│              // 计算成交数量                                                 │
│              matchQty := min(order.Quantity, makerOrder.Quantity)            │
│                                                                              │
│              // 生成成交记录                                                 │
│              trade := e.createTrade(makerOrder, order, matchQty)             │
│              trades = append(trades, trade)                                  │
│                                                                              │
│              // 更新订单数量                                                 │
│              order.Quantity -= matchQty                                      │
│              makerOrder.Quantity -= matchQty                                 │
│                                                                              │
│              // 如果 maker 订单完全成交，从订单簿移除                        │
│              if makerOrder.Quantity == 0 {                                   │
│                  next := makerOrder.Next                                     │
│                  e.removeOrder(makerOrder)                                   │
│                  makerOrder = next                                           │
│              } else {                                                        │
│                  makerOrder = makerOrder.Next                                │
│              }                                                               │
│          }                                                                   │
│      }                                                                       │
│                                                                              │
│      // 如果还有剩余数量，根据 TIF 处理                                      │
│      if order.Quantity > 0 {                                                 │
│          switch order.TIF {                                                  │
│          case GTC:                                                           │
│              e.addOrder(order)  // 加入订单簿                                │
│          case IOC:                                                           │
│              // 剩余取消，不加入订单簿                                       │
│          case FOK:                                                           │
│              // FOK 在外层处理，这里不会到达                                 │
│          }                                                                   │
│      }                                                                       │
│                                                                              │
│      return trades                                                           │
│  }                                                                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.5 市价单处理

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          市价单处理逻辑                                      │
│                                                                              │
│  市价单特点:                                                                 │
│  ───────────                                                                 │
│  - 不指定价格，按当前最优价格成交                                            │
│  - 必须设置滑点保护，防止价格偏离过大                                        │
│  - 采用 IOC 模式，未成交部分自动取消                                         │
│                                                                              │
│  滑点保护计算:                                                               │
│  ──────────────                                                              │
│                                                                              │
│  市价买单:                                                                   │
│    保护价格 = 最新价 × (1 + 滑点比例)                                        │
│    例: 最新价 50000, 滑点 1%                                                 │
│    保护价格 = 50000 × 1.01 = 50500                                           │
│    只接受 <= 50500 的卖单                                                    │
│                                                                              │
│  市价卖单:                                                                   │
│    保护价格 = 最新价 × (1 - 滑点比例)                                        │
│    例: 最新价 50000, 滑点 1%                                                 │
│    保护价格 = 50000 × 0.99 = 49500                                           │
│    只接受 >= 49500 的买单                                                    │
│                                                                              │
│  代码实现:                                                                   │
│  ──────────                                                                  │
│                                                                              │
│  func (e *Engine) MatchMarketBuy(order *Order, slippage int64) []*Trade {   │
│      // 计算保护价格                                                         │
│      protectPrice := e.lastPrice * (PricePrecision + slippage) / PricePrecision│
│                                                                              │
│      var trades []*Trade                                                     │
│                                                                              │
│      for e.orderBook.BestAsk != nil && order.Quantity > 0 {                  │
│          bestAsk := e.orderBook.BestAsk                                      │
│                                                                              │
│          // 滑点保护检查                                                     │
│          if bestAsk.Price > protectPrice {                                   │
│              break  // 价格超过保护价，停止成交                              │
│          }                                                                   │
│                                                                              │
│          // ... 同限价单撮合逻辑 ...                                         │
│      }                                                                       │
│                                                                              │
│      // 市价单不加入订单簿，剩余部分取消                                     │
│      return trades                                                           │
│  }                                                                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.6 FOK 订单处理

```go
// FOK (Fill-Or-Kill) 订单处理
// 必须全部成交，否则全部取消

func (e *Engine) ProcessFOK(order *Order) ([]*Trade, bool) {
    // 1. 预检查：是否能全部成交
    canFill := e.canFillCompletely(order)
    if !canFill {
        return nil, false  // 无法全部成交，整单取消
    }

    // 2. 执行撮合
    trades := e.matchOrder(order)
    return trades, true
}

// 检查是否能完全成交
func (e *Engine) canFillCompletely(order *Order) bool {
    remainQty := order.Quantity

    if order.Side == SideBuy {
        // 遍历卖单簿
        for level := e.orderBook.BestAsk; level != nil; level = e.nextAskLevel(level) {
            if order.Type == OrderTypeLimit && level.Price > order.Price {
                break  // 价格不匹配
            }

            remainQty -= level.TotalQty
            if remainQty <= 0 {
                return true
            }
        }
    } else {
        // 遍历买单簿
        for level := e.orderBook.BestBid; level != nil; level = e.nextBidLevel(level) {
            if order.Type == OrderTypeLimit && level.Price < order.Price {
                break
            }

            remainQty -= level.TotalQty
            if remainQty <= 0 {
                return true
            }
        }
    }

    return false
}
```

### 2.7 高可用设计

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          高可用设计                                          │
│                                                                              │
│  1. 快照机制                                                                 │
│  ────────────                                                                │
│                                                                              │
│  定期快照 (每 30 秒):                                                        │
│  - 将订单簿完整状态序列化                                                    │
│  - 保存到 Redis，key: snapshot:{market}:{timestamp}                         │
│  - 保留最近 10 个快照                                                        │
│                                                                              │
│  快照内容:                                                                   │
│  {                                                                           │
│    "market": "BTC-USDC",                                                     │
│    "timestamp": 1704067200000,                                               │
│    "kafka_offset": 123456,        // Kafka 消费位点                          │
│    "bids": [                                                                 │
│      {"price": 49900, "orders": [...]},                                      │
│      {"price": 49850, "orders": [...]}                                       │
│    ],                                                                        │
│    "asks": [                                                                 │
│      {"price": 50000, "orders": [...]},                                      │
│      {"price": 50100, "orders": [...]}                                       │
│    ],                                                                        │
│    "last_price": 50000,                                                      │
│    "checksum": "abc123..."                                                   │
│  }                                                                           │
│                                                                              │
│  2. 故障恢复流程                                                             │
│  ─────────────────                                                           │
│                                                                              │
│  ┌───────────┐     ┌───────────┐     ┌───────────┐     ┌───────────┐       │
│  │ 加载快照  │ ──> │ 获取位点  │ ──> │ 回放消息  │ ──> │ 恢复完成  │       │
│  │ (Redis)   │     │ (Kafka)   │     │ (Kafka)   │     │ (服务就绪) │       │
│  └───────────┘     └───────────┘     └───────────┘     └───────────┘       │
│                                                                              │
│  恢复步骤:                                                                   │
│  a. 从 Redis 加载最新快照                                                    │
│  b. 获取快照时的 Kafka offset                                                │
│  c. 从该 offset 开始回放消息                                                 │
│  d. 重建完成后，开始正常消费                                                 │
│                                                                              │
│  3. 主备热切换                                                               │
│  ───────────────                                                             │
│                                                                              │
│  ┌──────────────┐                    ┌──────────────┐                       │
│  │   Primary    │  ───同步快照───>  │   Standby    │                       │
│  │   (活跃)     │                    │   (待命)     │                       │
│  └──────────────┘                    └──────────────┘                       │
│         │                                   │                                │
│         │  心跳检测 (每 100ms)              │                                │
│         │                                   │                                │
│         ▼                                   ▼                                │
│  ┌──────────────┐                    ┌──────────────┐                       │
│  │  ZooKeeper   │  ←─选举协调──>    │  ZooKeeper   │                       │
│  └──────────────┘                    └──────────────┘                       │
│                                                                              │
│  切换触发条件:                                                               │
│  - Primary 心跳超时 (>500ms)                                                 │
│  - Primary 主动下线                                                          │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 三、数据库设计

撮合引擎本身不直接操作数据库，所有数据存储在内存中。但需要以下辅助存储：

### 3.1 Redis 快照存储

```
# 快照 Key 设计
snapshot:{market}:latest          # 最新快照
snapshot:{market}:{timestamp}     # 历史快照

# 快照数据结构 (JSON)
{
    "market": "BTC-USDC",
    "timestamp": 1704067200000000000,  # 纳秒
    "kafka_offset": 123456,
    "sequence": 789012,                 # 操作序列号
    "bids": [
        {
            "price": "49900.00000000",
            "total_qty": "10.50000000",
            "orders": [
                {
                    "order_id": "uuid-1",
                    "user_id": "0x123...",
                    "quantity": "5.00000000",
                    "timestamp": 1704067100000000000
                },
                {
                    "order_id": "uuid-2",
                    "user_id": "0x456...",
                    "quantity": "5.50000000",
                    "timestamp": 1704067150000000000
                }
            ]
        }
    ],
    "asks": [...],
    "last_price": "50000.00000000",
    "checksum": "sha256:abc123..."
}
```

### 3.2 引擎状态表 (PostgreSQL，用于监控)

```sql
CREATE TABLE engine_status (
    id              BIGSERIAL PRIMARY KEY,
    market          VARCHAR(20) NOT NULL,
    node_id         VARCHAR(64) NOT NULL,
    role            VARCHAR(10) NOT NULL,         -- PRIMARY/STANDBY
    status          VARCHAR(20) NOT NULL,         -- RUNNING/RECOVERING/STOPPED

    -- 性能指标
    orders_processed BIGINT NOT NULL DEFAULT 0,
    trades_generated BIGINT NOT NULL DEFAULT 0,
    avg_latency_us   INT NOT NULL DEFAULT 0,      -- 平均延迟 (微秒)
    p99_latency_us   INT NOT NULL DEFAULT 0,

    -- 订单簿状态
    bid_count       INT NOT NULL DEFAULT 0,
    ask_count       INT NOT NULL DEFAULT 0,
    bid_volume      DECIMAL(36, 18) DEFAULT 0,
    ask_volume      DECIMAL(36, 18) DEFAULT 0,

    -- Kafka 消费位点
    kafka_offset    BIGINT NOT NULL DEFAULT 0,
    kafka_lag       INT NOT NULL DEFAULT 0,

    -- 心跳
    last_heartbeat  BIGINT NOT NULL,              -- 心跳时间 (毫秒级时间戳)

    -- 审计字段
    created_by      VARCHAR(42),
    created_at      BIGINT NOT NULL,
    updated_by      VARCHAR(42),
    updated_at      BIGINT NOT NULL,

    UNIQUE (market, node_id)
);
```

---

## 四、数据流转

### 4.1 订单处理数据流

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         订单处理数据流                                       │
│                                                                              │
│  Kafka                     Matching Engine                      Kafka       │
│    │                            │                                 │         │
│    │  topic: orders             │                                 │         │
│    │  {                         │                                 │         │
│    │    order_id: "xxx",        │                                 │         │
│    │    market: "BTC-USDC",     │                                 │         │
│    │    side: "BUY",            │                                 │         │
│    │    price: "50000",         │                                 │         │
│    │    size: "0.1",            │                                 │         │
│    │    tif: "GTC"              │                                 │         │
│    │  }                         │                                 │         │
│    │───────────────────────────>│                                 │         │
│    │                            │                                 │         │
│    │                            │  1. 解析订单                    │         │
│    │                            │                                 │         │
│    │                            │  2. 执行撮合                    │         │
│    │                            │  - 查找匹配的对手单             │         │
│    │                            │  - 计算成交数量                 │         │
│    │                            │  - 生成成交记录                 │         │
│    │                            │                                 │         │
│    │                            │  3. 更新订单簿                  │         │
│    │                            │  - 移除完全成交的订单           │         │
│    │                            │  - 更新部分成交的订单           │         │
│    │                            │  - 添加剩余挂单                 │         │
│    │                            │                                 │         │
│    │                            │  4. 发送成交结果  ──────────────>│         │
│    │                            │     topic: trade-results        │         │
│    │                            │     {                            │         │
│    │                            │       trade_id: "...",           │         │
│    │                            │       maker_order_id: "...",     │         │
│    │                            │       taker_order_id: "...",     │         │
│    │                            │       price: "50000",            │         │
│    │                            │       size: "0.1",               │         │
│    │                            │       maker_fee: "0.025",        │         │
│    │                            │       taker_fee: "0.05"          │         │
│    │                            │     }                            │         │
│    │                            │                                 │         │
│    │                            │  5. 发送订单簿更新 ─────────────>│         │
│    │                            │     topic: orderbook-updates     │         │
│    │                            │                                 │         │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 批量处理优化

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         批量处理优化                                         │
│                                                                              │
│  为提高吞吐量，从 Kafka 批量消费订单:                                        │
│  ═══════════════════════════════════                                         │
│                                                                              │
│  批量消费配置:                                                               │
│  - batch.size: 100                                                          │
│  - linger.ms: 5                                                             │
│  - 每批最多 100 个订单，或等待 5ms                                          │
│                                                                              │
│  处理流程:                                                                   │
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  1. 批量读取 Kafka 消息 (100条/批)                                   │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                             │                                               │
│                             ▼                                               │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  2. 按交易对分组                                                     │   │
│  │     BTC-USDC: [order1, order2, order5]                               │   │
│  │     ETH-USDC: [order3, order4]                                       │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                             │                                               │
│                             ▼                                               │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  3. 并行分发到各交易对引擎                                           │   │
│  │     (每个交易对内部串行处理，交易对之间并行)                         │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                             │                                               │
│                             ▼                                               │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  4. 收集所有成交结果                                                 │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                             │                                               │
│                             ▼                                               │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  5. 批量发送到 Kafka                                                 │   │
│  │     - trade-results (批量)                                           │   │
│  │     - orderbook-updates (批量)                                       │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                             │                                               │
│                             ▼                                               │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  6. 提交 Kafka offset                                                │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 五、Kafka 消息格式

### 5.1 输入消息

```protobuf
// 新订单消息 (topic: orders)
message OrderMessage {
    string order_id = 1;
    string maker = 2;
    string market = 3;
    string side = 4;              // BUY/SELL
    string order_type = 5;        // LIMIT/MARKET
    string time_in_force = 6;     // GTC/IOC/FOK
    string price = 7;             // 限价单必填
    string size = 8;
    string slippage = 9;          // 市价单必填
    int64 timestamp = 10;         // 纳秒
    int64 sequence = 11;          // 序列号 (用于回放)
}

// 取消订单消息 (topic: cancel-requests)
message CancelMessage {
    string order_id = 1;
    string maker = 2;
    string market = 3;
    int64 timestamp = 4;
    int64 sequence = 5;
}
```

### 5.2 输出消息

```protobuf
// 成交结果消息 (topic: trade-results)
message TradeResultMessage {
    string trade_id = 1;
    string maker_order_id = 2;
    string taker_order_id = 3;
    string maker = 4;
    string taker = 5;
    string market = 6;
    string side = 7;              // taker 的方向
    string price = 8;
    string size = 9;
    string quote_amount = 10;     // 成交金额
    string maker_fee = 11;
    string taker_fee = 12;
    bool maker_order_filled = 13; // maker 订单是否完全成交
    bool taker_order_filled = 14; // taker 订单是否完全成交
    int64 timestamp = 15;
    int64 sequence = 16;
}

// 取消确认消息 (topic: order-cancelled)
message CancelConfirmMessage {
    string order_id = 1;
    string market = 2;
    bool success = 3;
    string reason = 4;            // 失败原因
    string remaining_size = 5;    // 取消时剩余数量
    int64 timestamp = 6;
    int64 sequence = 7;
}

// 订单簿更新消息 (topic: orderbook-updates)
message OrderBookUpdateMessage {
    string market = 1;
    string update_type = 2;       // ADD/REMOVE/UPDATE
    string side = 3;              // BUY/SELL
    string price = 4;
    string size = 5;              // 该价位新的总量 (0 表示删除)
    int64 timestamp = 6;
    int64 sequence = 7;
}
```

---

## 六、性能优化

### 6.1 优化策略

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         性能优化策略                                         │
│                                                                              │
│  1. 内存优化                                                                 │
│  ────────────                                                                │
│  - 使用 sync.Pool 复用 Order 和 PriceLevel 对象                             │
│  - 预分配切片容量，减少扩容                                                  │
│  - 使用定点数 (int64) 代替浮点数                                            │
│                                                                              │
│  2. 数据结构优化                                                             │
│  ─────────────────                                                           │
│  - 红黑树保证 O(log n) 插入/删除                                            │
│  - 缓存 BestBid/BestAsk 实现 O(1) 最优价查询                               │
│  - orderID -> Order 哈希表实现 O(1) 订单查找                               │
│                                                                              │
│  3. 并发优化                                                                 │
│  ────────────                                                                │
│  - 每个交易对独立 goroutine，无锁竞争                                       │
│  - 使用 channel 通信，避免共享内存                                          │
│  - 批量处理减少 channel 通信次数                                            │
│                                                                              │
│  4. GC 优化                                                                  │
│  ───────────                                                                 │
│  - GOGC=100 (默认值，可根据实际调整)                                        │
│  - 对象池复用，减少内存分配                                                  │
│  - 避免在热路径上创建临时对象                                               │
│                                                                              │
│  5. 网络优化                                                                 │
│  ────────────                                                                │
│  - Kafka 批量消费和生产                                                      │
│  - 压缩消息 (lz4)                                                           │
│  - 异步发送，不等待 ACK (at-least-once)                                     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.2 基准测试参考

```go
// 基准测试示例
func BenchmarkMatchOrder(b *testing.B) {
    engine := NewEngine("BTC-USDC")

    // 预填充订单簿
    for i := 0; i < 10000; i++ {
        engine.AddOrder(&Order{
            ID:       uint64(i),
            Side:     SideSell,
            Price:    50000 + int64(i%100),
            Quantity: 100000000,  // 1 BTC
        })
    }

    b.ResetTimer()

    for i := 0; i < b.N; i++ {
        order := orderPool.Get().(*Order)
        order.ID = uint64(i + 10000)
        order.Side = SideBuy
        order.Price = 50050
        order.Quantity = 10000000  // 0.1 BTC
        order.Type = OrderTypeLimit
        order.TIF = TIFTypeGTC

        engine.Match(order)

        orderPool.Put(order)
    }
}

// 预期结果:
// BenchmarkMatchOrder-8   500000   2000 ns/op   0 B/op   0 allocs/op
// 单线程 TPS: 500,000+
```

---

## 七、配置项

```yaml
# eidos-matching 配置
service:
  name: eidos-matching
  node_id: "engine-1"

# 市场配置
markets:
  - symbol: BTC-USDC
    price_decimals: 8
    size_decimals: 8
    min_size: "0.0001"
    tick_size: "0.01"           # 最小价格变动
    maker_fee_rate: "0.0005"    # 0.05%
    taker_fee_rate: "0.001"     # 0.1%
  - symbol: ETH-USDC
    price_decimals: 8
    size_decimals: 8
    min_size: "0.001"
    tick_size: "0.01"
    maker_fee_rate: "0.0005"
    taker_fee_rate: "0.001"

# Kafka 配置
kafka:
  brokers:
    - kafka-1:9092
    - kafka-2:9092
    - kafka-3:9092
  consumer:
    group_id: eidos-matching
    topics:
      - orders
      - cancel-requests
    batch_size: 100
    linger_ms: 5
  producer:
    compression: lz4
    batch_size: 1000
    linger_ms: 1

# Redis 配置 (快照存储)
redis:
  cluster:
    nodes:
      - redis-1:6379
      - redis-2:6379
      - redis-3:6379

# 快照配置
snapshot:
  interval: 30s               # 快照间隔
  max_count: 10               # 保留快照数量

# 高可用配置
ha:
  enabled: true
  zookeeper:
    servers:
      - zk-1:2181
      - zk-2:2181
      - zk-3:2181
    session_timeout: 5s
  heartbeat_interval: 100ms
  failover_timeout: 500ms

# 性能配置
performance:
  gogc: 100
  gomaxprocs: 0               # 0 表示使用所有 CPU
```

---

## 八、安全机制

### 8.1 并发安全设计

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          并发安全设计                                        │
│                                                                              │
│  核心原则: 单线程 per 市场 + 消息队列解耦                                   │
│  ═══════════════════════════════════════                                     │
│                                                                              │
│  1. 市场级别隔离                                                             │
│  ────────────────                                                            │
│  - 每个交易对一个独立 goroutine                                              │
│  - goroutine 内部串行处理，无需加锁                                          │
│  - 不同交易对完全独立，并行执行                                              │
│                                                                              │
│  2. Kafka 分区保证顺序                                                       │
│  ──────────────────────                                                      │
│  - partition_key = market (交易对)                                           │
│  - 同一 market 的消息进入同一分区                                            │
│  - Kafka 保证分区内消息 FIFO 顺序                                            │
│                                                                              │
│  3. 无共享状态                                                               │
│  ───────────────                                                             │
│  - 每个 Engine 独立维护自己的 OrderBook                                      │
│  - 通过 channel 通信，避免共享内存                                           │
│  - Router 只做路由分发，不持有状态                                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 8.2 幂等性处理

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          幂等性设计                                          │
│                                                                              │
│  问题: 网络重试或故障恢复时，同一订单可能被重复处理                          │
│                                                                              │
│  解决方案: 订单ID去重 + 序列号检查                                           │
│  ═══════════════════════════════════                                         │
│                                                                              │
│  1. 订单ID去重                                                               │
│  ───────────────                                                             │
│  type OrderBook struct {                                                     │
│      Orders map[string]*Order  // orderID -> Order                           │
│  }                                                                           │
│                                                                              │
│  func (e *Engine) AddOrder(order *Order) error {                            │
│      if _, exists := e.orderBook.Orders[order.OrderID]; exists {            │
│          return ErrDuplicateOrder  // 幂等: 已存在则跳过                     │
│      }                                                                       │
│      // ... 正常处理                                                         │
│  }                                                                           │
│                                                                              │
│  2. 消息序列号检查                                                           │
│  ──────────────────                                                          │
│  type Engine struct {                                                        │
│      lastSequence int64  // 上次处理的序列号                                 │
│  }                                                                           │
│                                                                              │
│  func (e *Engine) ProcessMessage(msg *Message) error {                      │
│      if msg.Sequence <= e.lastSequence {                                    │
│          return nil  // 幂等: 旧消息跳过                                     │
│      }                                                                       │
│      e.lastSequence = msg.Sequence                                          │
│      // ... 正常处理                                                         │
│  }                                                                           │
│                                                                              │
│  3. 快照包含序列号                                                           │
│  ──────────────────                                                          │
│  快照内容包含 sequence 字段，恢复后从该序列号继续                            │
│  避免重复处理已快照的消息                                                    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 8.3 订单顺序保证

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          订单顺序保证                                        │
│                                                                              │
│  时间优先规则的实现:                                                         │
│  ═══════════════════                                                         │
│                                                                              │
│  1. 订单时间戳                                                               │
│  ───────────────                                                             │
│  - 使用纳秒级时间戳 (int64)                                                  │
│  - 由 eidos-trading 统一分配，保证单调递增                                   │
│  - 撮合引擎按时间戳排序，不依赖消息到达顺序                                  │
│                                                                              │
│  2. 单调递增时间戳生成                                                       │
│  ─────────────────────                                                       │
│  type TimestampGenerator struct {                                            │
│      mu        sync.Mutex                                                    │
│      lastTime  int64                                                         │
│  }                                                                           │
│                                                                              │
│  func (g *TimestampGenerator) Next() int64 {                                │
│      g.mu.Lock()                                                             │
│      defer g.mu.Unlock()                                                     │
│                                                                              │
│      now := time.Now().UnixNano()                                            │
│      if now <= g.lastTime {                                                  │
│          now = g.lastTime + 1  // 保证单调递增                               │
│      }                                                                       │
│      g.lastTime = now                                                        │
│      return now                                                              │
│  }                                                                           │
│                                                                              │
│  3. 同价格订单排序                                                           │
│  ──────────────────                                                          │
│  PriceLevel 使用双向链表，按时间戳顺序追加                                   │
│  新订单 → 链表尾部                                                           │
│  撮合时 → 从链表头部开始                                                     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 8.4 故障恢复一致性

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        故障恢复一致性保证                                    │
│                                                                              │
│  恢复流程:                                                                   │
│  ═════════                                                                   │
│                                                                              │
│  1. 快照校验                                                                 │
│  ────────────                                                                │
│  - 每个快照包含 SHA256 checksum                                              │
│  - 加载时验证 checksum，损坏则使用上一个快照                                 │
│                                                                              │
│  func (m *SnapshotManager) Load(market string) (*Snapshot, error) {         │
│      // 尝试加载最新快照                                                     │
│      for i := 0; i < 10; i++ {                                              │
│          snapshot := m.loadSnapshot(market, i)                               │
│          if m.verifyChecksum(snapshot) {                                     │
│              return snapshot, nil                                            │
│          }                                                                   │
│          log.Warn("snapshot checksum mismatch, trying older")               │
│      }                                                                       │
│      return nil, ErrNoValidSnapshot                                          │
│  }                                                                           │
│                                                                              │
│  2. 恢复后验证                                                               │
│  ───────────────                                                             │
│  - 恢复完成后，计算订单簿 checksum                                           │
│  - 与备节点对比，确保状态一致                                                │
│                                                                              │
│  3. Kafka 消费位点管理                                                       │
│  ─────────────────────                                                       │
│  - 手动提交 offset (不使用自动提交)                                          │
│  - 批量处理完成 + 快照保存后才提交                                           │
│  - 保证"至少一次"语义 + 幂等性 = 精确一次                                    │
│                                                                              │
│  func (c *Consumer) ProcessBatch(messages []*Message) error {               │
│      // 1. 处理消息                                                          │
│      for _, msg := range messages {                                          │
│          if err := c.engine.Process(msg); err != nil {                      │
│              return err                                                      │
│          }                                                                   │
│      }                                                                       │
│                                                                              │
│      // 2. 保存快照 (可选，定期)                                             │
│      if c.shouldSnapshot() {                                                 │
│          c.saveSnapshot(messages[len(messages)-1].Offset)                    │
│      }                                                                       │
│                                                                              │
│      // 3. 提交 offset                                                       │
│      return c.commitOffset(messages[len(messages)-1].Offset)                │
│  }                                                                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 8.5 主备同步安全

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          主备同步安全                                        │
│                                                                              │
│  问题: 主备切换时如何保证状态一致?                                           │
│                                                                              │
│  解决方案: 同步消费 + 延迟切换                                               │
│  ═══════════════════════════════                                             │
│                                                                              │
│  1. 备节点同步消费                                                           │
│  ──────────────────                                                          │
│  - 主备同时消费同一个 Kafka topic                                            │
│  - 备节点处理消息但不发送输出                                                │
│  - 备节点状态与主节点完全一致                                                │
│                                                                              │
│  2. 切换前校验                                                               │
│  ───────────────                                                             │
│  - 切换前比对主备订单簿 checksum                                             │
│  - 不一致则从快照重建备节点                                                  │
│                                                                              │
│  3. 切换流程                                                                 │
│  ────────────                                                                │
│  a. 主节点停止消费 (或检测到故障)                                            │
│  b. 备节点等待处理完当前消息队列 (最大等待时间 100ms)                        │
│  c. 备节点获取 ZooKeeper 锁，成为新主节点                                    │
│  d. 新主节点开始发送输出消息                                                 │
│                                                                              │
│  4. 脑裂防护                                                                 │
│  ────────────                                                                │
│  - 使用 ZooKeeper 分布式锁                                                   │
│  - 每条输出消息包含 epoch 编号                                               │
│  - 下游服务只接受最新 epoch 的消息                                           │
│                                                                              │
│  type OutputMessage struct {                                                 │
│      Epoch     int64   // 主节点任期编号                                     │
│      Sequence  int64   // 消息序列号                                         │
│      // ... 其他字段                                                         │
│  }                                                                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 九、监控指标

```go
// Prometheus 指标
var (
    // 订单处理
    ordersProcessed = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "matching_orders_processed_total",
            Help: "Total orders processed",
        },
        []string{"market", "side", "order_type"},
    )

    // 成交
    tradesGenerated = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "matching_trades_generated_total",
            Help: "Total trades generated",
        },
        []string{"market"},
    )

    tradesVolume = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "matching_trades_volume_total",
            Help: "Total trading volume",
        },
        []string{"market"},
    )

    // 延迟
    matchLatency = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "matching_latency_microseconds",
            Help:    "Matching latency in microseconds",
            Buckets: []float64{10, 50, 100, 500, 1000, 5000, 10000},
        },
        []string{"market"},
    )

    // 订单簿状态
    orderbookDepth = prometheus.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "matching_orderbook_depth",
            Help: "Order book depth",
        },
        []string{"market", "side"},
    )

    orderbookSpread = prometheus.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "matching_orderbook_spread",
            Help: "Order book spread (best ask - best bid)",
        },
        []string{"market"},
    )

    // Kafka 消费延迟
    kafkaLag = prometheus.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "matching_kafka_consumer_lag",
            Help: "Kafka consumer lag",
        },
        []string{"market", "partition"},
    )
)
```
