# Eidos 风控服务设计

> 服务名: eidos-risk
> 语言: Go
>
> **重要**: 本文档包含服务降级策略、性能优化、审核流程等关键设计，请完整阅读。

---

## 一、服务概述

### 1.1 核心定位

eidos-risk 是交易风控服务，负责交易前校验和交易后监控，确保交易安全合规。

**设计原则**:
- 同步校验保证实时拦截
- 异步监控降低性能影响
- 规则可配置支持动态调整
- 独立部署便于后续演进

### 1.2 职责边界

| 职责 | 描述 | 属于本服务 |
|------|------|-----------|
| 价格偏离检查 | 检查订单价格是否偏离市场价过大 | ✅ |
| 单笔限额检查 | 检查单笔交易金额是否超限 | ✅ |
| 频率限制 | 检查用户下单频率是否异常 | ✅ |
| 自成交检测 | 检测是否与自己的订单成交 | ✅ |
| 异常交易告警 | 监控异常交易行为 | ✅ |
| 洗盘行为识别 | 识别可疑的洗盘操作 | ✅ |
| 大额提现审核 | 审核大额提现请求 | ✅ |
| 黑名单管理 | 管理风险地址黑名单 | ✅ |
| 订单撮合 | 订单匹配 | ❌ (eidos-matching) |
| 余额管理 | 用户余额增减 | ❌ (eidos-trading) |

### 1.3 对外能力

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       eidos-risk 对外能力                                    │
│                                                                              │
│  gRPC 接口 (同步调用):                                                       │
│  ═════════════════════                                                       │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐              │
│  │  CheckOrder     │  │ CheckWithdraw   │  │  GetRiskStatus  │              │
│  │  订单风控校验    │  │  提现风控校验    │  │  查询风险状态    │              │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘              │
│  ┌─────────────────┐  ┌─────────────────┐                                   │
│  │  AddToBlacklist │  │ RemoveFromBlack │                                   │
│  │  添加黑名单      │  │  移除黑名单      │                                   │
│  └─────────────────┘  └─────────────────┘                                   │
│                                                                              │
│  Kafka 消费 (异步监控):                                                      │
│  ───────────────────                                                         │
│  - topic: trade-results    (成交结果，异步监控)                              │
│  - topic: order-updates    (订单状态，异步监控)                              │
│                                                                              │
│  Kafka 生产:                                                                 │
│  ───────────                                                                 │
│  - topic: risk-alerts      (风控告警事件)                                    │
│                                                                              │
│  调用关系:                                                                   │
│  ───────────                                                                 │
│  - 被 eidos-trading 同步调用 (下单前、提现前)                                │
│  - 被 eidos-admin 调用 (黑名单管理、规则配置)                                │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 二、同步风控校验

### 2.1 订单风控流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          订单风控校验流程                                     │
│                                                                              │
│  eidos-trading              eidos-risk                   Redis/DB           │
│       │                         │                            │              │
│       │  1. CheckOrder          │                            │              │
│       │  {                      │                            │              │
│       │    market: "BTC-USDC",  │                            │              │
│       │    maker: "0x...",      │                            │              │
│       │    side: "buy",         │                            │              │
│       │    price: 50000,        │                            │              │
│       │    size: 0.1            │                            │              │
│       │  }                      │                            │              │
│       │────────────────────────>│                            │              │
│       │                         │                            │              │
│       │                         │  2. 黑名单检查             │              │
│       │                         │────────────────────────────>│              │
│       │                         │<────────────────────────────│              │
│       │                         │                            │              │
│       │                         │  3. 价格偏离检查            │              │
│       │                         │     (对比最近成交价)        │              │
│       │                         │────────────────────────────>│              │
│       │                         │<────────────────────────────│              │
│       │                         │                            │              │
│       │                         │  4. 单笔限额检查            │              │
│       │                         │                            │              │
│       │                         │  5. 频率限制检查            │              │
│       │                         │     (滑动窗口)              │              │
│       │                         │────────────────────────────>│              │
│       │                         │<────────────────────────────│              │
│       │                         │                            │              │
│       │                         │  6. 自成交风险检查          │              │
│       │                         │     (查询用户挂单)          │              │
│       │                         │────────────────────────────>│              │
│       │                         │<────────────────────────────│              │
│       │                         │                            │              │
│       │  7. 返回结果            │                            │              │
│       │  {                      │                            │              │
│       │    allowed: true/false, │                            │              │
│       │    reason: "...",       │                            │              │
│       │    risk_level: "low"    │                            │              │
│       │  }                      │                            │              │
│       │<────────────────────────│                            │              │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.1.1 服务降级策略

> **警告**: 简单的 `fail_open: true`（超时放行）存在安全风险。恶意用户可通过制造风控服务压力来绕过检查。

**分级降级策略**:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          风控服务降级策略                                     │
│                                                                              │
│  降级级别:                                                                   │
│  ──────────                                                                  │
│  Level 0 (正常): 所有检查正常执行                                            │
│  Level 1 (轻度降级): 跳过非关键检查 (如洗盘检测)                             │
│  Level 2 (中度降级): 只执行黑名单和基础限额检查                              │
│  Level 3 (重度降级): 只执行黑名单检查                                        │
│  Level 4 (熔断): 拒绝所有请求 (fail_close)                                  │
│                                                                              │
│  降级触发条件:                                                               │
│  ──────────────                                                              │
│  - 超时率 > 10% (1分钟内) → Level 1                                         │
│  - 超时率 > 30% → Level 2                                                   │
│  - 超时率 > 50% → Level 3                                                   │
│  - 错误率 > 80% 或 Redis/DB 完全不可用 → Level 4                            │
│                                                                              │
│  恢复策略:                                                                   │
│  ──────────                                                                  │
│  - 每 30 秒尝试恢复一个级别                                                 │
│  - 恢复时先用 10% 流量探测                                                  │
│  - 探测成功后逐步提升流量比例                                               │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

```go
// 降级控制器
type DegradationController struct {
    currentLevel atomic.Int32
    metrics      *DegradationMetrics
    mu           sync.RWMutex
}

type DegradationMetrics struct {
    totalRequests   atomic.Int64
    timeoutRequests atomic.Int64
    errorRequests   atomic.Int64
    windowStart     atomic.Int64
}

// 根据当前降级级别决定执行哪些检查
func (c *DegradationController) GetActiveChecks() []CheckType {
    level := c.currentLevel.Load()

    switch level {
    case 0: // 正常
        return []CheckType{
            CheckBlacklist,
            CheckPriceDeviation,
            CheckRateLimit,
            CheckOrderLimit,
            CheckSelfTrade,
            CheckWashTrade, // 非关键
        }
    case 1: // 轻度降级
        return []CheckType{
            CheckBlacklist,
            CheckPriceDeviation,
            CheckRateLimit,
            CheckOrderLimit,
            CheckSelfTrade,
        }
    case 2: // 中度降级
        return []CheckType{
            CheckBlacklist,
            CheckOrderLimit,
        }
    case 3: // 重度降级
        return []CheckType{
            CheckBlacklist,
        }
    case 4: // 熔断
        return nil // 拒绝所有
    default:
        return nil
    }
}

// 风控检查入口
func (s *RiskService) CheckOrder(ctx context.Context, req *CheckOrderRequest) (*CheckOrderResponse, error) {
    // 获取当前应执行的检查
    activeChecks := s.degradation.GetActiveChecks()

    if activeChecks == nil {
        // 熔断状态，拒绝请求但记录日志
        s.metrics.circuitBreakerRejects.Inc()
        return &CheckOrderResponse{
            Allowed:   false,
            Reason:    "服务暂时不可用，请稍后重试",
            RiskLevel: "high",
        }, nil
    }

    // 记录降级状态用于审计
    if len(activeChecks) < 6 {
        log.Warnf("risk check degraded: level=%d, order=%s",
            s.degradation.currentLevel.Load(), req.OrderId)
    }

    // 执行激活的检查
    for _, check := range activeChecks {
        result, err := s.executeCheck(ctx, check, req)
        if err != nil {
            s.degradation.recordError()
            continue // 单个检查失败不阻塞，继续其他检查
        }
        if !result.Allowed {
            return result, nil
        }
    }

    return &CheckOrderResponse{Allowed: true, RiskLevel: "low"}, nil
}

// 周期性更新降级级别
func (c *DegradationController) updateLevel() {
    metrics := c.metrics.snapshot()

    timeoutRate := float64(metrics.TimeoutCount) / float64(metrics.TotalCount)
    errorRate := float64(metrics.ErrorCount) / float64(metrics.TotalCount)

    var targetLevel int32
    switch {
    case errorRate > 0.8:
        targetLevel = 4 // 熔断
    case timeoutRate > 0.5:
        targetLevel = 3
    case timeoutRate > 0.3:
        targetLevel = 2
    case timeoutRate > 0.1:
        targetLevel = 1
    default:
        // 尝试恢复
        current := c.currentLevel.Load()
        if current > 0 {
            targetLevel = current - 1
        }
    }

    if targetLevel != c.currentLevel.Load() {
        log.Warnf("degradation level changed: %d -> %d", c.currentLevel.Load(), targetLevel)
        c.currentLevel.Store(targetLevel)
    }
}
```

**降级时的补偿措施**:

| 降级级别 | 补偿措施 |
|---------|---------|
| Level 1-3 | 异步补检: 将跳过的检查推入队列，后台补充检查 |
| Level 1-3 | 告警通知: 立即通知运维团队 |
| Level 1-3 | 限流收紧: 适当降低请求频率限制 |
| Level 4 | 自动恢复尝试: 每 30 秒探测后端服务健康 |

### 2.2 风控规则详解

#### 2.2.1 价格偏离检查

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          价格偏离检查规则                                     │
│                                                                              │
│  目的: 防止价格操纵和错误订单                                                 │
│                                                                              │
│  计算方式:                                                                   │
│  ──────────                                                                  │
│  deviation = |order_price - reference_price| / reference_price * 100%       │
│                                                                              │
│  参考价格来源 (按优先级选择):                                                │
│  1. 最近成交价 (last_trade_price) - 10分钟内有成交                          │
│  2. 中间价 (best_bid + best_ask) / 2 - 买卖盘都存在                         │
│  3. 外部指数价格 (index_price) - 来自 eidos-market 聚合的外部价格           │
│  4. 无参考价格 - 跳过价格偏离检查，记录日志                                  │
│                                                                              │
│  阈值配置:                                                                   │
│  ──────────                                                                  │
│  price_deviation:                                                            │
│    warning: 5%       # 记录日志                                             │
│    reject: 10%       # 拒绝订单                                             │
│    market_order: 3%  # 市价单更严格                                         │
│                                                                              │
│  示例:                                                                       │
│  ──────                                                                      │
│  BTC-USDC 最近成交价: 50000                                                  │
│  用户下单价格: 55000 (偏离 10%)                                              │
│  结果: 拒绝 (超过 reject 阈值)                                              │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 2.2.2 频率限制检查

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          频率限制检查规则                                     │
│                                                                              │
│  目的: 防止 DDoS 攻击和滥用                                                  │
│                                                                              │
│  实现方式: Redis 滑动窗口                                                    │
│  ────────────────────────                                                    │
│  Key: rate_limit:{wallet}:{action}                                          │
│  Value: ZSET (timestamp -> request_id)                                      │
│                                                                              │
│  限制配置:                                                                   │
│  ──────────                                                                  │
│  rate_limits:                                                                │
│    create_order:                                                             │
│      per_second: 10        # 每秒最多 10 笔                                  │
│      per_minute: 200       # 每分钟最多 200 笔                               │
│    cancel_order:                                                             │
│      per_second: 20        # 取消频率可以更高                                │
│      per_minute: 500                                                         │
│    withdraw:                                                                 │
│      per_hour: 10          # 提现频率限制                                    │
│      per_day: 50                                                             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

> **性能问题**: 上述多次 Redis 调用不是原子操作，在高并发下可能出现竞态条件，且网络开销大。

**Lua 脚本优化 (原子操作)**:

```go
// 滑动窗口限流 Lua 脚本 - 单次 Redis 调用完成所有操作
var rateLimitScript = redis.NewScript(`
    local key = KEYS[1]
    local now = tonumber(ARGV[1])
    local window = tonumber(ARGV[2])
    local limit = tonumber(ARGV[3])
    local request_id = ARGV[4]

    local window_start = now - window

    -- 原子操作: 清理过期 + 计数 + 添加
    redis.call('ZREMRANGEBYSCORE', key, '-inf', window_start)
    local count = redis.call('ZCARD', key)

    if count >= limit then
        return 0  -- 超限
    end

    redis.call('ZADD', key, now, request_id)
    redis.call('PEXPIRE', key, window * 2)  -- TTL = 2倍窗口时间

    return 1  -- 通过
`)

func (s *RiskService) CheckRateLimit(ctx context.Context, wallet, action string) (bool, error) {
    key := fmt.Sprintf("rate_limit:%s:%s", wallet, action)
    now := time.Now().UnixMilli()
    requestId := uuid.New().String()

    config := s.getRateLimitConfig(action)

    // 单次 Redis 调用
    result, err := rateLimitScript.Run(ctx, s.redis, []string{key},
        now,
        config.WindowMs,
        config.Limit,
        requestId,
    ).Int()

    if err != nil {
        return false, err
    }

    return result == 1, nil
}

// 多窗口限流 (秒/分钟/小时)
func (s *RiskService) CheckMultiWindowRateLimit(ctx context.Context, wallet, action string) (bool, error) {
    configs := s.getMultiWindowConfig(action)

    // 并发检查多个窗口
    results := make(chan bool, len(configs))
    for _, cfg := range configs {
        go func(c RateLimitConfig) {
            key := fmt.Sprintf("rate_limit:%s:%s:%s", wallet, action, c.Window)
            result, _ := rateLimitScript.Run(ctx, s.redis, []string{key},
                time.Now().UnixMilli(), c.WindowMs, c.Limit, uuid.New().String()).Int()
            results <- result == 1
        }(cfg)
    }

    // 任一窗口超限则拒绝
    for range configs {
        if !<-results {
            return false, nil
        }
    }
    return true, nil
}
```

#### 2.2.3 单笔限额检查

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          单笔限额检查规则                                     │
│                                                                              │
│  目的: 限制单笔交易规模，降低风险敞口                                         │
│                                                                              │
│  限额配置:                                                                   │
│  ──────────                                                                  │
│  order_limits:                                                               │
│    default:                                                                  │
│      min_value: "10"           # 最小 10 USDC                               │
│      max_value: "100000"       # 最大 10万 USDC                             │
│    per_market:                                                               │
│      BTC-USDC:                                                               │
│        min_size: "0.0001"      # 最小 0.0001 BTC                            │
│        max_size: "10"          # 最大 10 BTC                                │
│      ETH-USDC:                                                               │
│        min_size: "0.01"        # 最小 0.01 ETH                              │
│        max_size: "100"         # 最大 100 ETH                               │
│                                                                              │
│  提现限额:                                                                   │
│  ──────────                                                                  │
│  withdraw_limits:                                                            │
│    single_max: "50000"         # 单笔最大 5万 USDC                          │
│    daily_max: "500000"         # 每日最大 50万 USDC                         │
│    large_threshold: "10000"    # 超过此金额需要额外审核                      │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 2.2.5 大额提现审核流程

> **问题**: `need_review` 字段返回后，需要完整的审核工作流。

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          大额提现审核流程                                     │
│                                                                              │
│  用户请求           风控服务           审核系统           链上服务            │
│     │                 │                 │                 │                 │
│     │ 1. 提现请求     │                 │                 │                 │
│     │────────────────>│                 │                 │                 │
│     │                 │                 │                 │                 │
│     │                 │ 2. 检查金额     │                 │                 │
│     │                 │    > 10000?     │                 │                 │
│     │                 │                 │                 │                 │
│     │ 3. 返回         │                 │                 │                 │
│     │    need_review  │                 │                 │                 │
│     │<────────────────│                 │                 │                 │
│     │                 │                 │                 │                 │
│     │                 │ 4. 创建审核任务 │                 │                 │
│     │                 │────────────────>│                 │                 │
│     │                 │                 │                 │                 │
│     │                 │                 │ 5. 审核员处理   │                 │
│     │                 │                 │    ├─通过       │                 │
│     │                 │                 │    ├─拒绝       │                 │
│     │                 │                 │    └─需更多信息 │                 │
│     │                 │                 │                 │                 │
│     │                 │ 6. 审核结果     │                 │                 │
│     │                 │<────────────────│                 │                 │
│     │                 │                 │                 │                 │
│     │                 │ 7. 通过则触发   │                 │                 │
│     │                 │    链上提现     │────────────────>│                 │
│     │                 │                 │                 │                 │
│     │ 8. 提现结果通知 │                 │                 │                 │
│     │<────────────────────────────────────────────────────│                 │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

**审核任务表**:

```sql
CREATE TABLE withdrawal_reviews (
    id              BIGSERIAL PRIMARY KEY,
    review_id       VARCHAR(64) NOT NULL UNIQUE,

    -- 提现信息
    withdrawal_id   VARCHAR(64) NOT NULL UNIQUE,
    wallet_address  VARCHAR(42) NOT NULL,
    token           VARCHAR(42) NOT NULL,
    amount          DECIMAL(36, 18) NOT NULL,
    to_address      VARCHAR(42) NOT NULL,

    -- 风险评估
    risk_score      INT NOT NULL,                 -- 0-100
    risk_factors    JSONB NOT NULL,               -- 风险因素列表
    auto_decision   VARCHAR(20),                  -- 系统建议: approve/reject/manual

    -- 审核状态
    status          VARCHAR(20) NOT NULL DEFAULT 'pending',  -- pending/approved/rejected/expired
    reviewer        VARCHAR(42),
    review_comment  VARCHAR(500),
    reviewed_at     BIGINT,

    -- SLA
    created_at      BIGINT NOT NULL,
    expires_at      BIGINT NOT NULL,              -- 审核超时时间 (如 24h)

    INDEX idx_reviews_status (status),
    INDEX idx_reviews_wallet (wallet_address),
    INDEX idx_reviews_expires (expires_at)
);
```

**审核实现**:

```go
// 创建审核任务
func (s *RiskService) CreateWithdrawalReview(ctx context.Context, withdraw *WithdrawRequest) (*WithdrawalReview, error) {
    // 1. 计算风险评分
    riskScore, riskFactors := s.assessWithdrawalRisk(ctx, withdraw)

    // 2. 确定系统建议
    autoDecision := s.getAutoDecision(riskScore)

    // 3. 创建审核任务
    review := &WithdrawalReview{
        ReviewID:      uuid.New().String(),
        WithdrawalID:  withdraw.ID,
        WalletAddress: withdraw.Wallet,
        Token:         withdraw.Token,
        Amount:        withdraw.Amount,
        ToAddress:     withdraw.ToAddress,
        RiskScore:     riskScore,
        RiskFactors:   riskFactors,
        AutoDecision:  autoDecision,
        Status:        "pending",
        CreatedAt:     time.Now().Unix(),
        ExpiresAt:     time.Now().Add(24 * time.Hour).Unix(),
    }

    if err := s.repo.CreateWithdrawalReview(ctx, review); err != nil {
        return nil, err
    }

    // 4. 通知审核员
    s.notifyReviewers(ctx, review)

    return review, nil
}

// 风险评估
func (s *RiskService) assessWithdrawalRisk(ctx context.Context, w *WithdrawRequest) (int, []RiskFactor) {
    var score int
    var factors []RiskFactor

    // 金额因素
    if w.Amount.GreaterThan(decimal.NewFromInt(50000)) {
        score += 30
        factors = append(factors, RiskFactor{Type: "large_amount", Score: 30})
    }

    // 账户年龄因素
    accountAge := s.getAccountAge(ctx, w.Wallet)
    if accountAge < 7*24*time.Hour {
        score += 25
        factors = append(factors, RiskFactor{Type: "new_account", Score: 25})
    }

    // 目标地址因素
    if s.isNewDestination(ctx, w.Wallet, w.ToAddress) {
        score += 15
        factors = append(factors, RiskFactor{Type: "new_destination", Score: 15})
    }

    // 最近活动因素
    recentWithdrawals := s.getRecentWithdrawals(ctx, w.Wallet, 24*time.Hour)
    if len(recentWithdrawals) > 5 {
        score += 20
        factors = append(factors, RiskFactor{Type: "frequent_withdrawals", Score: 20})
    }

    return score, factors
}

// 处理审核结果
func (s *RiskService) HandleReviewDecision(ctx context.Context, reviewID string, decision ReviewDecision) error {
    review, err := s.repo.GetWithdrawalReview(ctx, reviewID)
    if err != nil {
        return err
    }

    if review.Status != "pending" {
        return ErrReviewAlreadyProcessed
    }

    // 更新审核状态
    review.Status = decision.Status
    review.Reviewer = decision.Reviewer
    review.ReviewComment = decision.Comment
    review.ReviewedAt = time.Now().Unix()

    if err := s.repo.UpdateWithdrawalReview(ctx, review); err != nil {
        return err
    }

    // 如果通过，触发链上提现
    if decision.Status == "approved" {
        return s.chainClient.ExecuteWithdrawal(ctx, review.WithdrawalID)
    }

    // 如果拒绝，通知用户
    if decision.Status == "rejected" {
        s.notifyWithdrawalRejected(ctx, review, decision.Comment)
    }

    return nil
}

// 审核超时处理 (定时任务)
func (s *RiskService) HandleExpiredReviews(ctx context.Context) error {
    expiredReviews, err := s.repo.FindExpiredReviews(ctx, time.Now().Unix())
    if err != nil {
        return err
    }

    for _, review := range expiredReviews {
        // 低风险自动通过，高风险自动拒绝
        var status string
        if review.RiskScore < 30 {
            status = "approved"
            s.chainClient.ExecuteWithdrawal(ctx, review.WithdrawalID)
        } else {
            status = "rejected"
            s.notifyWithdrawalRejected(ctx, review, "审核超时自动拒绝")
        }

        review.Status = status
        review.ReviewComment = "auto: timeout"
        review.ReviewedAt = time.Now().Unix()
        s.repo.UpdateWithdrawalReview(ctx, review)
    }

    return nil
}
```

#### 2.2.4 自成交检查

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          自成交检查规则                                       │
│                                                                              │
│  目的: 防止用户自买自卖操纵市场                                               │
│                                                                              │
│  检查逻辑:                                                                   │
│  ──────────                                                                  │
│  1. 查询用户在该市场的所有挂单                                               │
│  2. 检查新订单是否可能与现有挂单成交                                         │
│  3. 如果可能自成交，拒绝新订单                                               │
│                                                                              │
│  代码示例:                                                                   │
│  ──────────                                                                  │
│  func (s *RiskService) CheckSelfTrade(order *Order) bool {                  │
│      // 查询用户现有挂单                                                     │
│      openOrders := s.getOpenOrders(order.Maker, order.Market)               │
│                                                                              │
│      for _, existingOrder := range openOrders {                             │
│          // 检查方向相反                                                     │
│          if existingOrder.Side == order.Side {                              │
│              continue                                                        │
│          }                                                                   │
│                                                                              │
│          // 检查价格是否会匹配                                               │
│          if order.Side == Buy && order.Price >= existingOrder.Price {       │
│              return false  // 买单价格 >= 卖单价格，会成交                   │
│          }                                                                   │
│          if order.Side == Sell && order.Price <= existingOrder.Price {      │
│              return false  // 卖单价格 <= 买单价格，会成交                   │
│          }                                                                   │
│      }                                                                       │
│                                                                              │
│      return true                                                             │
│  }                                                                           │
│                                                                              │
│  配置选项:                                                                   │
│  ──────────                                                                  │
│  self_trade:                                                                 │
│    mode: "reject"          # reject=拒绝, cancel_oldest=取消旧单            │
│    enabled: true                                                             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

> **性能问题**: 每次检查都查询用户所有挂单，对于持有大量挂单的用户（如做市商），查询开销很大。

**优化方案: 价格区间缓存**

```go
// 缓存用户在每个市场的订单价格区间
// Key: self_trade:range:{market}:{wallet}
// Value: { buy_max: "50100", sell_min: "49900" }
type OrderPriceRange struct {
    BuyMax  *decimal.Decimal `json:"buy_max"`   // 最高买价
    SellMin *decimal.Decimal `json:"sell_min"`  // 最低卖价
}

// 快速自成交检查 - O(1) 复杂度
func (s *RiskService) CheckSelfTradeFast(ctx context.Context, order *Order) (bool, error) {
    // 1. 从缓存获取用户的价格区间
    rangeKey := fmt.Sprintf("self_trade:range:%s:%s", order.Market, order.Maker)
    rangeData, err := s.redis.Get(ctx, rangeKey).Result()

    if err == redis.Nil {
        // 缓存未命中，回退到传统检查
        return s.checkSelfTradeSlow(ctx, order)
    }

    var priceRange OrderPriceRange
    if err := json.Unmarshal([]byte(rangeData), &priceRange); err != nil {
        return s.checkSelfTradeSlow(ctx, order)
    }

    // 2. 快速判断是否可能自成交
    if order.Side == Buy {
        // 买单价格 >= 最低卖价 → 可能自成交
        if priceRange.SellMin != nil && order.Price.GreaterThanOrEqual(*priceRange.SellMin) {
            return false, nil // 拒绝
        }
    } else {
        // 卖单价格 <= 最高买价 → 可能自成交
        if priceRange.BuyMax != nil && order.Price.LessThanOrEqual(*priceRange.BuyMax) {
            return false, nil // 拒绝
        }
    }

    return true, nil
}

// 价格区间缓存更新 (由 matching-engine 通过 Kafka 事件触发)
func (s *RiskService) UpdateOrderPriceRange(ctx context.Context, event *OrderEvent) error {
    rangeKey := fmt.Sprintf("self_trade:range:%s:%s", event.Market, event.Maker)

    // 使用 Lua 脚本原子更新
    return s.updatePriceRangeScript.Run(ctx, s.redis, []string{rangeKey},
        event.Side, event.Price, event.Action).Err()
}

var updatePriceRangeScript = redis.NewScript(`
    local key = KEYS[1]
    local side = ARGV[1]
    local price = tonumber(ARGV[2])
    local action = ARGV[3]  -- "add" or "remove"

    local data = redis.call('GET', key)
    local range = data and cjson.decode(data) or {}

    if action == "add" then
        if side == "buy" then
            if not range.buy_max or price > range.buy_max then
                range.buy_max = price
            end
        else
            if not range.sell_min or price < range.sell_min then
                range.sell_min = price
            end
        end
    elseif action == "remove" then
        -- 移除时需要重新计算，设置 dirty 标记
        range.dirty = true
    end

    redis.call('SET', key, cjson.encode(range))
    redis.call('EXPIRE', key, 86400)  -- 1天过期
    return 1
`)
```

**缓存失效策略**:
- 订单成交/取消时更新缓存
- 缓存标记为 dirty 时，下次检查回退到慢路径并重建缓存
- 缓存 TTL 1 天，过期后自动重建

---

## 三、异步风控监控

### 3.1 成交后监控

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          成交后异步监控                                       │
│                                                                              │
│  Kafka                    eidos-risk                     告警系统            │
│    │                          │                             │               │
│    │ trade-results            │                             │               │
│    │ {                        │                             │               │
│    │   trade_id: "...",       │                             │               │
│    │   maker: "0x...",        │                             │               │
│    │   taker: "0x...",        │                             │               │
│    │   price: 50000,          │                             │               │
│    │   size: 0.1              │                             │               │
│    │ }                        │                             │               │
│    │──────────────────────────>                             │               │
│    │                          │                             │               │
│    │                          │  1. 异常价格检测            │               │
│    │                          │     (对比历史成交)          │               │
│    │                          │                             │               │
│    │                          │  2. 洗盘行为检测            │               │
│    │                          │     (相同 maker/taker 频繁)  │               │
│    │                          │                             │               │
│    │                          │  3. 大单异动检测            │               │
│    │                          │     (超过日均 10 倍)        │               │
│    │                          │                             │               │
│    │                          │  4. 关联账户检测            │               │
│    │                          │     (地址关联分析)          │               │
│    │                          │                             │               │
│    │                          │  5. 发现异常则告警          │               │
│    │                          │─────────────────────────────>│               │
│    │                          │     Kafka: risk-alerts      │               │
│    │                          │                             │               │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 异常检测规则

| 检测项 | 触发条件 | 告警级别 | 处理方式 |
|--------|----------|----------|----------|
| 价格异动 | 5 分钟内涨跌幅 > 5% | 警告 | 记录日志 |
| 洗盘嫌疑 | 同账户 1 小时内 > 50 笔自成交 | 严重 | 暂停账户 |
| 大单异动 | 单笔 > 日均交易量 10 倍 | 警告 | 人工审核 |
| 高频交易 | 1 分钟内 > 1000 笔 | 严重 | 限制频率 |
| 关联交易 | 2 个关联地址频繁互成交 | 严重 | 人工审核 |

### 3.3 异常处理完整流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          异常检测后处理流程                                   │
│                                                                              │
│  异常检测                 自动处理                 人工处理                   │
│     │                       │                       │                       │
│     ▼                       ▼                       ▼                       │
│  ┌──────────┐          ┌──────────┐          ┌──────────┐                  │
│  │ 检测到   │          │ 自动执行 │          │ 人工审核 │                  │
│  │ 异常事件 │ ──────► │ 处置措施 │ ──────► │ (严重级) │                  │
│  └────┬─────┘          └────┬─────┘          └────┬─────┘                  │
│       │                     │                     │                        │
│       ▼                     ▼                     ▼                        │
│  ┌──────────┐          ┌──────────┐          ┌──────────┐                  │
│  │ 写入     │          │ 发送告警 │          │ 审核决策 │                  │
│  │ risk_    │          │ (Kafka)  │          │          │                  │
│  │ events表 │          └──────────┘          │ ├─确认   │                  │
│  └──────────┘               │                │ ├─误报   │                  │
│                             ▼                │ └─升级   │                  │
│                        ┌──────────┐          └────┬─────┘                  │
│                        │ 通知渠道 │               │                        │
│                        │          │               ▼                        │
│                        │ Slack/   │          ┌──────────┐                  │
│                        │ PagerDuty│          │ 执行处置 │                  │
│                        └──────────┘          │ (黑名单/ │                  │
│                                              │  限制等) │                  │
│                                              └──────────┘                  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

**自动处置规则**:

| 异常类型 | 自动处置 | 需人工确认 |
|---------|---------|-----------|
| 洗盘嫌疑 (50笔/h) | 暂停交易 24h | 是 (24h 内确认，否则自动解除) |
| 高频异常 (1000笔/min) | 限流降级 (10笔/s → 1笔/s) | 否 |
| 价格异动 (5%/5min) | 记录日志 | 否 |
| 大单异动 (10x) | 人工审核队列 | 是 |
| 关联交易 | 人工审核队列 | 是 |

**处置实现**:

```go
// 异常处置执行器
func (s *RiskService) HandleAnomaly(ctx context.Context, event *AnomalyEvent) error {
    // 1. 写入事件记录
    if err := s.repo.CreateRiskEvent(ctx, event.ToRiskEvent()); err != nil {
        return err
    }

    // 2. 根据异常类型执行自动处置
    action := s.getAutoAction(event.Type, event.Level)
    if action != nil {
        if err := s.executeAction(ctx, action, event); err != nil {
            log.Errorf("auto action failed: %v", err)
            // 自动处置失败时升级为人工处理
            event.Level = LevelCritical
        }
    }

    // 3. 发送告警
    alert := &Alert{
        Type:    event.Type,
        Level:   event.Level,
        Wallet:  event.Wallet,
        Message: s.formatAlertMessage(event),
        Action:  action,
    }

    s.kafka.Produce(ctx, "risk-alerts", alert)

    // 4. 严重级别需要人工确认
    if event.Level >= LevelSevere {
        s.createReviewTask(ctx, event)
    }

    return nil
}

// 自动处置动作
func (s *RiskService) executeAction(ctx context.Context, action *AutoAction, event *AnomalyEvent) error {
    switch action.Type {
    case ActionSuspendTrade:
        // 暂停交易：添加临时黑名单
        return s.repo.AddToBlacklist(ctx, &Blacklist{
            WalletAddress:  event.Wallet,
            ListType:       "trade",
            Reason:         fmt.Sprintf("auto: %s", event.Type),
            Source:         "auto",
            EffectiveFrom:  time.Now().Unix(),
            EffectiveUntil: proto.Int64(time.Now().Add(action.Duration).Unix()),
        })

    case ActionRateLimitDegrade:
        // 限流降级
        return s.degradeRateLimit(ctx, event.Wallet, action.NewLimit)

    case ActionQueueForReview:
        // 加入审核队列
        return s.createReviewTask(ctx, event)

    default:
        return nil
    }
}
```

---

## 四、黑名单管理

### 4.1 黑名单类型

| 类型 | 说明 | 影响范围 |
|------|------|----------|
| 交易黑名单 | 禁止下单 | 下单接口 |
| 提现黑名单 | 禁止提现 | 提现接口 |
| 全面黑名单 | 禁止所有操作 | 所有接口 |

### 4.2 黑名单来源

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          黑名单来源                                          │
│                                                                              │
│  1. 手动添加 (管理后台)                                                      │
│     - 运营人员手动标记风险地址                                               │
│     - 需要审批流程                                                           │
│                                                                              │
│  2. 自动触发 (风控规则)                                                      │
│     - 洗盘行为检测触发                                                       │
│     - 频繁违规触发                                                           │
│     - 自动加入需要人工确认                                                   │
│                                                                              │
│  3. 外部数据 (合规要求)                                                      │
│     - OFAC 制裁名单                                                          │
│     - 已知风险地址列表                                                       │
│     - 定期同步更新                                                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 五、数据库设计

### 5.1 风控规则表 (risk_rules)

```sql
CREATE TABLE risk_rules (
    id              BIGSERIAL PRIMARY KEY,
    rule_id         VARCHAR(64) NOT NULL UNIQUE,

    -- 规则信息
    rule_type       VARCHAR(50) NOT NULL,         -- price_deviation, rate_limit, etc.
    market          VARCHAR(20),                  -- NULL 表示全局规则
    description     VARCHAR(500),

    -- 规则配置 (JSON)
    config          JSONB NOT NULL,

    -- 状态
    enabled         BOOLEAN NOT NULL DEFAULT true,

    -- 审计字段
    created_by      VARCHAR(42),
    created_at      BIGINT NOT NULL,
    updated_by      VARCHAR(42),
    updated_at      BIGINT NOT NULL,

    INDEX idx_rules_type (rule_type),
    INDEX idx_rules_market (market)
);
```

#### 5.1.1 规则版本管理

> **问题**: 规则变更时需要追踪历史版本，支持回滚，并确保规则变更的原子性。

```sql
-- 规则版本表 (记录每次规则变更)
CREATE TABLE risk_rule_versions (
    id              BIGSERIAL PRIMARY KEY,
    rule_id         VARCHAR(64) NOT NULL,
    version         INT NOT NULL,

    -- 规则快照
    config_snapshot JSONB NOT NULL,
    enabled         BOOLEAN NOT NULL,

    -- 变更信息
    change_type     VARCHAR(20) NOT NULL,     -- 'create', 'update', 'disable', 'enable'
    change_reason   VARCHAR(500),
    changed_by      VARCHAR(42) NOT NULL,
    changed_at      BIGINT NOT NULL,

    -- 生效时间 (支持预约生效)
    effective_at    BIGINT NOT NULL,

    INDEX idx_rule_versions_rule_id (rule_id),
    INDEX idx_rule_versions_effective (effective_at),
    UNIQUE (rule_id, version)
);
```

**规则变更流程**:

```go
// 规则变更服务
func (s *RuleService) UpdateRule(ctx context.Context, req *UpdateRuleRequest) error {
    return s.db.Transaction(func(tx *gorm.DB) error {
        // 1. 获取当前规则
        currentRule, err := s.repo.GetRuleByID(tx, req.RuleID)
        if err != nil {
            return err
        }

        // 2. 创建新版本记录
        newVersion := currentRule.Version + 1
        versionRecord := &RiskRuleVersion{
            RuleID:         req.RuleID,
            Version:        newVersion,
            ConfigSnapshot: req.NewConfig,
            Enabled:        req.Enabled,
            ChangeType:     "update",
            ChangeReason:   req.Reason,
            ChangedBy:      req.Operator,
            ChangedAt:      time.Now().Unix(),
            EffectiveAt:    req.EffectiveAt,
        }
        if err := s.repo.CreateRuleVersion(tx, versionRecord); err != nil {
            return err
        }

        // 3. 如果立即生效，更新主表
        if req.EffectiveAt <= time.Now().Unix() {
            currentRule.Config = req.NewConfig
            currentRule.Enabled = req.Enabled
            currentRule.Version = newVersion
            currentRule.UpdatedBy = req.Operator
            currentRule.UpdatedAt = time.Now().Unix()
            if err := s.repo.UpdateRule(tx, currentRule); err != nil {
                return err
            }

            // 4. 通知风控服务重新加载规则
            s.notifyRuleReload(ctx, req.RuleID)
        }

        return nil
    })
}

// 规则回滚
func (s *RuleService) RollbackRule(ctx context.Context, ruleID string, targetVersion int) error {
    // 获取目标版本的快照
    versionRecord, err := s.repo.GetRuleVersion(ctx, ruleID, targetVersion)
    if err != nil {
        return err
    }

    // 创建回滚请求
    return s.UpdateRule(ctx, &UpdateRuleRequest{
        RuleID:      ruleID,
        NewConfig:   versionRecord.ConfigSnapshot,
        Enabled:     versionRecord.Enabled,
        Reason:      fmt.Sprintf("rollback to version %d", targetVersion),
        Operator:    "system",
        EffectiveAt: time.Now().Unix(),
    })
}
```

**预约生效机制**:

```go
// 定时任务: 检查并应用预约生效的规则
func (s *RuleService) ApplyScheduledRules(ctx context.Context) error {
    now := time.Now().Unix()

    // 查找需要生效的规则版本
    pendingVersions, err := s.repo.FindPendingVersions(ctx, now)
    if err != nil {
        return err
    }

    for _, v := range pendingVersions {
        if err := s.applyVersion(ctx, v); err != nil {
            log.Errorf("apply scheduled rule failed: rule=%s version=%d err=%v",
                v.RuleID, v.Version, err)
            continue
        }
        log.Infof("scheduled rule applied: rule=%s version=%d", v.RuleID, v.Version)
    }

    return nil
}
```

### 5.2 风控事件表 (risk_events)

```sql
CREATE TABLE risk_events (
    id              BIGSERIAL PRIMARY KEY,
    event_id        VARCHAR(64) NOT NULL UNIQUE,

    -- 事件信息
    event_type      VARCHAR(50) NOT NULL,         -- order_rejected, alert_triggered, etc.
    risk_level      VARCHAR(20) NOT NULL,         -- low, medium, high, critical
    wallet_address  VARCHAR(42) NOT NULL,

    -- 关联信息
    ref_type        VARCHAR(20),                  -- order, trade, withdraw
    ref_id          VARCHAR(64),

    -- 事件详情 (JSON)
    details         JSONB NOT NULL,

    -- 处理状态
    status          VARCHAR(20) NOT NULL DEFAULT 'pending',  -- pending, resolved, ignored
    resolved_by     VARCHAR(42),
    resolved_at     BIGINT,
    resolution      VARCHAR(500),

    -- 审计字段
    created_at      BIGINT NOT NULL,

    INDEX idx_events_wallet (wallet_address),
    INDEX idx_events_type (event_type),
    INDEX idx_events_level (risk_level),
    INDEX idx_events_status (status),
    INDEX idx_events_created (created_at)
);
```

### 5.3 黑名单表 (blacklist)

```sql
CREATE TABLE blacklist (
    id              BIGSERIAL PRIMARY KEY,

    -- 地址信息
    wallet_address  VARCHAR(42) NOT NULL UNIQUE,

    -- 黑名单类型
    list_type       VARCHAR(20) NOT NULL,         -- trade, withdraw, full

    -- 原因
    reason          VARCHAR(500) NOT NULL,
    source          VARCHAR(50) NOT NULL,         -- manual, auto, external

    -- 有效期
    effective_from  BIGINT NOT NULL,
    effective_until BIGINT,                       -- NULL 表示永久

    -- 状态
    status          VARCHAR(20) NOT NULL DEFAULT 'active',  -- active, removed

    -- 审计字段
    created_by      VARCHAR(42),
    created_at      BIGINT NOT NULL,
    updated_by      VARCHAR(42),
    updated_at      BIGINT NOT NULL,

    INDEX idx_blacklist_status (status),
    INDEX idx_blacklist_type (list_type)
);
```

### 5.4 风控审计日志表 (risk_audit_logs)

```sql
CREATE TABLE risk_audit_logs (
    id              BIGSERIAL PRIMARY KEY,

    -- 操作信息
    action          VARCHAR(50) NOT NULL,         -- check_order, add_blacklist, etc.
    wallet_address  VARCHAR(42),

    -- 请求详情
    request         JSONB NOT NULL,

    -- 结果
    result          VARCHAR(20) NOT NULL,         -- allowed, rejected, error
    reason          VARCHAR(500),
    duration_ms     INT NOT NULL,

    -- 审计字段
    created_at      BIGINT NOT NULL,

    INDEX idx_audit_action (action),
    INDEX idx_audit_wallet (wallet_address),
    INDEX idx_audit_result (result),
    INDEX idx_audit_created (created_at)
);
```

---

## 六、错误码

```go
const (
    // 订单风控
    ErrCodePriceDeviation      = "RISK_PRICE_DEVIATION"
    ErrCodeRateLimitExceeded   = "RISK_RATE_LIMIT_EXCEEDED"
    ErrCodeOrderAmountTooSmall = "RISK_ORDER_AMOUNT_TOO_SMALL"
    ErrCodeOrderAmountTooLarge = "RISK_ORDER_AMOUNT_TOO_LARGE"
    ErrCodeSelfTradeRisk       = "RISK_SELF_TRADE"

    // 提现风控
    ErrCodeWithdrawAmountLimit = "RISK_WITHDRAW_AMOUNT_LIMIT"
    ErrCodeWithdrawDailyLimit  = "RISK_WITHDRAW_DAILY_LIMIT"
    ErrCodeWithdrawNeedReview  = "RISK_WITHDRAW_NEED_REVIEW"

    // 黑名单
    ErrCodeBlacklisted         = "RISK_BLACKLISTED"
    ErrCodeTradeBlacklisted    = "RISK_TRADE_BLACKLISTED"
    ErrCodeWithdrawBlacklisted = "RISK_WITHDRAW_BLACKLISTED"

    // 系统错误
    ErrCodeRiskServiceTimeout  = "RISK_SERVICE_TIMEOUT"
    ErrCodeRiskServiceError    = "RISK_SERVICE_ERROR"
)
```

---

## 七、配置

```yaml
service:
  name: eidos-risk
  grpc_port: 50055
  http_port: 8080

# 数据库
postgres:
  host: postgres
  port: 5432
  database: eidos_risk
  max_connections: 50

# Redis
redis:
  cluster:
    nodes:
      - redis-1:6379
      - redis-2:6379
      - redis-3:6379

# Kafka
kafka:
  brokers:
    - kafka-1:9092
    - kafka-2:9092
    - kafka-3:9092
  consumer:
    group_id: eidos-risk
    topics:
      - trade-results
      - order-updates
  producer:
    topics:
      risk_alerts: risk-alerts

# 同步调用配置
sync_check:
  timeout: 100ms              # 单次检查超时
  # 降级策略 (替代简单的 fail_open)
  degradation:
    enabled: true
    level_1_threshold: 0.10   # 超时率 > 10% 进入 Level 1
    level_2_threshold: 0.30   # 超时率 > 30% 进入 Level 2
    level_3_threshold: 0.50   # 超时率 > 50% 进入 Level 3
    level_4_threshold: 0.80   # 错误率 > 80% 熔断
    recovery_interval: 30s    # 恢复检测间隔
    window_size: 60s          # 统计窗口大小

# 风控规则
rules:
  # 价格偏离
  price_deviation:
    warning_threshold: 0.05   # 5%
    reject_threshold: 0.10    # 10%
    market_order_threshold: 0.03  # 市价单 3%

  # 频率限制
  rate_limits:
    create_order:
      per_second: 10
      per_minute: 200
    cancel_order:
      per_second: 20
      per_minute: 500
    withdraw:
      per_hour: 10
      per_day: 50

  # 订单限额
  order_limits:
    min_value: "10"           # USDC
    max_value: "100000"       # USDC

  # 提现限额
  withdraw_limits:
    single_max: "50000"       # 单笔上限
    daily_max: "500000"       # 每日上限
    large_threshold: "10000"  # 大额审核阈值

  # 自成交
  self_trade:
    enabled: true
    mode: "reject"            # reject, cancel_oldest

# 异步监控
async_monitor:
  wash_trade:
    enabled: true
    threshold: 50             # 1 小时内自成交次数
  large_trade:
    enabled: true
    multiplier: 10            # 日均 N 倍
  price_spike:
    enabled: true
    threshold: 0.05           # 5 分钟涨跌幅
    window: 5m

# 黑名单
blacklist:
  external_sync:
    enabled: false            # 外部黑名单同步
    source_url: ""
    sync_interval: 24h
```

---

## 八、监控指标

```go
var (
    // 同步检查
    riskCheckTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "risk_check_total",
            Help: "Total risk checks",
        },
        []string{"check_type", "result"},
    )

    riskCheckDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "risk_check_duration_seconds",
            Help:    "Risk check duration",
            Buckets: []float64{0.001, 0.005, 0.01, 0.05, 0.1},
        },
        []string{"check_type"},
    )

    riskRejectTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "risk_reject_total",
            Help: "Total rejections by reason",
        },
        []string{"reason"},
    )

    // 异步监控
    riskAlertsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "risk_alerts_total",
            Help: "Total risk alerts",
        },
        []string{"alert_type", "level"},
    )

    // 黑名单
    blacklistSize = prometheus.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "risk_blacklist_size",
            Help: "Current blacklist size",
        },
        []string{"list_type"},
    )

    // 服务健康
    riskServiceErrors = prometheus.NewCounter(
        prometheus.CounterOpts{
            Name: "risk_service_errors_total",
            Help: "Total service errors",
        },
    )

    riskServiceTimeouts = prometheus.NewCounter(
        prometheus.CounterOpts{
            Name: "risk_service_timeouts_total",
            Help: "Total service timeouts",
        },
    )
)
```

---

## 九、gRPC 接口定义

```protobuf
syntax = "proto3";

package eidos.risk.v1;

service RiskService {
    // 订单风控检查
    rpc CheckOrder(CheckOrderRequest) returns (CheckOrderResponse);

    // 提现风控检查
    rpc CheckWithdraw(CheckWithdrawRequest) returns (CheckWithdrawResponse);

    // 查询风险状态
    rpc GetRiskStatus(GetRiskStatusRequest) returns (GetRiskStatusResponse);

    // 黑名单管理
    rpc AddToBlacklist(AddToBlacklistRequest) returns (AddToBlacklistResponse);
    rpc RemoveFromBlacklist(RemoveFromBlacklistRequest) returns (RemoveFromBlacklistResponse);
    rpc CheckBlacklist(CheckBlacklistRequest) returns (CheckBlacklistResponse);
}

message CheckOrderRequest {
    string market = 1;
    string maker = 2;
    string side = 3;           // buy, sell
    string order_type = 4;     // limit, market
    string price = 5;
    string size = 6;
}

message CheckOrderResponse {
    bool allowed = 1;
    string reason = 2;
    string risk_level = 3;     // low, medium, high
    repeated string warnings = 4;
}

message CheckWithdrawRequest {
    string wallet = 1;
    string token = 2;
    string amount = 3;
    string to_address = 4;
}

message CheckWithdrawResponse {
    bool allowed = 1;
    bool need_review = 2;      // 需要人工审核
    string reason = 3;
    string risk_level = 4;
}

message GetRiskStatusRequest {
    string wallet = 1;
}

message GetRiskStatusResponse {
    bool is_blacklisted = 1;
    string blacklist_type = 2;
    string risk_level = 3;
    int32 pending_alerts = 4;
    repeated RiskAlert recent_alerts = 5;
}

message RiskAlert {
    string alert_id = 1;
    string alert_type = 2;
    string level = 3;
    string message = 4;
    int64 created_at = 5;
}
```

---

