# Eidos 行情服务设计

> 服务名: eidos-market
> 语言: Go

---

## 一、服务职责

### 1.1 核心定位

Market Data Service (行情服务) 负责聚合和分发所有行情数据，包括 K线、Ticker、订单簿深度、成交流等。参考 Binance、OKX 等主流交易所的行情系统设计。

### 1.2 职责边界

| 职责 | 描述 | 属于本服务 |
|------|------|-----------|
| K线聚合 | 实时聚合各周期 K线 | ✅ |
| Ticker 计算 | 24h 统计数据 | ✅ |
| 订单簿快照 | 维护和分发订单簿深度 | ✅ |
| 成交流 | 分发实时成交记录 | ✅ |
| 深度聚合 | 按不同精度聚合深度 | ✅ |
| 数据推送 | 通过 Redis Pub/Sub 推送给 WebSocket | ✅ |
| 历史数据 | K线历史存储和查询 | ✅ |

### 1.3 对外提供的能力

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     Market Data Service 对外能力                             │
│                                                                              │
│  gRPC 接口 (给 eidos-api):                                                   │
│  ───────────────────────────                                                 │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐              │
│  │  GetKlines      │  │  GetTicker      │  │  GetTickers     │              │
│  │  查询K线数据    │  │  查询单个Ticker │  │  查询所有Ticker │              │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘              │
│                                                                              │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐              │
│  │  GetOrderBook   │  │  GetTrades      │  │  GetMarkets     │              │
│  │  查询订单簿深度 │  │  查询最近成交   │  │  查询交易对列表 │              │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘              │
│                                                                              │
│  Kafka 消费:                                                                 │
│  ───────────                                                                 │
│  - topic: trade-results      成交数据 (用于 K线、Ticker)                    │
│  - topic: orderbook-updates  订单簿增量更新                                  │
│                                                                              │
│  Redis Pub/Sub 发布 (给 WebSocket 推送):                                     │
│  ───────────────────────────────────────                                     │
│  (命名规范详见 00-协议总表.md)                                            │
│  - channel: eidos:kline:{market}:{interval}   K线更新                       │
│  - channel: eidos:ticker:{market}             Ticker 更新                   │
│  - channel: eidos:depth:{market}:{level}      深度更新                      │
│  - channel: eidos:trades:{market}             成交流                        │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 二、详细设计

### 2.1 模块架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      Market Data Service 内部架构                            │
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                        Kafka Consumer                               │     │
│  │  topics: trade-results, orderbook-updates                          │     │
│  └───────────────────────────────┬────────────────────────────────────┘     │
│                                  │                                          │
│                                  ▼                                          │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                        Event Processor                              │     │
│  │                                                                     │     │
│  │  根据事件类型分发到不同的处理器                                     │     │
│  └───────────────────────────────┬────────────────────────────────────┘     │
│                                  │                                          │
│         ┌────────────────────────┼────────────────────────────────┐         │
│         │                        │                                │         │
│         ▼                        ▼                                ▼         │
│  ┌──────────────┐        ┌──────────────┐                ┌──────────────┐  │
│  │ KlineAggr    │        │ TickerCalc   │                │ OrderBookMgr │  │
│  │  K线聚合器   │        │  Ticker计算  │                │  订单簿管理  │  │
│  │              │        │              │                │              │  │
│  │ - 1m         │        │ - 24h统计    │                │ - 深度快照   │  │
│  │ - 5m         │        │ - 涨跌幅     │                │ - 增量更新   │  │
│  │ - 15m        │        │ - 成交量     │                │ - 精度聚合   │  │
│  │ - 1h         │        │ - 最高最低   │                │              │  │
│  │ - 4h         │        │              │                │              │  │
│  │ - 1d         │        │              │                │              │  │
│  │ - 1w         │        │              │                │              │  │
│  └──────────────┘        └──────────────┘                └──────────────┘  │
│         │                        │                                │         │
│         └────────────────────────┴────────────────────────────────┘         │
│                                  │                                          │
│                                  ▼                                          │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                        gRPC Server                                  │     │
│  │  - GetKlines  - GetTicker  - GetOrderBook  - GetTrades            │     │
│  └────────────────────────────────────────────────────────────────────┘     │
│                                  │                                          │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                      Redis Pub/Sub Publisher                        │     │
│  │                                                                     │     │
│  │  实时推送行情更新到各个 channel                                     │     │
│  └────────────────────────────────────────────────────────────────────┘     │
│                                  │                                          │
│                                  ▼                                          │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                       Storage Layer                                 │     │
│  │                                                                     │     │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐              │     │
│  │  │ Redis        │  │ TimescaleDB  │  │ PostgreSQL   │              │     │
│  │  │ (实时缓存)   │  │ (K线历史)    │  │ (交易对配置) │              │     │
│  │  └──────────────┘  └──────────────┘  └──────────────┘              │     │
│  └────────────────────────────────────────────────────────────────────┘     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 K线聚合设计

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           K线聚合设计                                        │
│                                                                              │
│  K线周期:                                                                    │
│  ═════════                                                                   │
│  1m (1分钟), 5m, 15m, 30m, 1h (1小时), 4h, 1d (1天), 1w (1周)               │
│                                                                              │
│  K线数据结构:                                                                │
│  ──────────────                                                              │
│  {                                                                           │
│    "open_time": 1704067200000,    // 开盘时间 (毫秒时间戳)                  │
│    "open": "50000.00",            // 开盘价                                 │
│    "high": "50500.00",            // 最高价                                 │
│    "low": "49800.00",             // 最低价                                 │
│    "close": "50200.00",           // 收盘价                                 │
│    "volume": "123.456",           // 成交量 (base token)                    │
│    "quote_volume": "6172800.00",  // 成交额 (quote token)                   │
│    "trades": 1234,                // 成交笔数                               │
│    "close_time": 1704067259999    // 收盘时间                               │
│  }                                                                           │
│                                                                              │
│  聚合流程:                                                                   │
│  ──────────                                                                  │
│                                                                              │
│  成交事件                                                                    │
│      │                                                                       │
│      ▼                                                                       │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  1. 更新 1m K线 (内存)                                               │   │
│  │                                                                      │   │
│  │  kline := getCurrentKline(market, "1m")                              │   │
│  │  if trade.Price > kline.High { kline.High = trade.Price }            │   │
│  │  if trade.Price < kline.Low { kline.Low = trade.Price }              │   │
│  │  kline.Close = trade.Price                                           │   │
│  │  kline.Volume += trade.Size                                          │   │
│  │  kline.QuoteVolume += trade.Size * trade.Price                       │   │
│  │  kline.Trades++                                                      │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│      │                                                                       │
│      ▼                                                                       │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  2. 发布 K线更新 (Redis Pub/Sub)                                     │   │
│  │                                                                      │   │
│  │  channel: eidos:kline:BTC-USDC:1m                                    │   │
│  │  message: {"o":"50000","h":"50500","l":"49800","c":"50200",...}      │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│      │                                                                       │
│      ▼                                                                       │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  3. 每分钟切换 K线                                                   │   │
│  │                                                                      │   │
│  │  - 保存当前 1m K线到 TimescaleDB                                     │   │
│  │  - 创建新的 1m K线 (Open = 上一根 Close)                             │   │
│  │  - 检查是否需要更新 5m, 15m, ... 等大周期                           │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  大周期 K线聚合:                                                             │
│  ─────────────────                                                           │
│  5m K线 = 聚合最近 5 根 1m K线                                              │
│  15m K线 = 聚合最近 3 根 5m K线                                             │
│  1h K线 = 聚合最近 4 根 15m K线                                             │
│  ...                                                                         │
│                                                                              │
│  聚合规则:                                                                   │
│  Open = 第一根的 Open                                                        │
│  High = 所有的 Max(High)                                                     │
│  Low = 所有的 Min(Low)                                                       │
│  Close = 最后一根的 Close                                                    │
│  Volume = Sum(Volume)                                                        │
│  QuoteVolume = Sum(QuoteVolume)                                              │
│  Trades = Sum(Trades)                                                        │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.3 Ticker 计算

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          Ticker 计算设计                                     │
│                                                                              │
│  Ticker 数据结构 (参考 Binance):                                             │
│  ═══════════════════════════════                                             │
│  {                                                                           │
│    "symbol": "BTC-USDC",                                                     │
│    "last_price": "50200.00",       // 最新价                                │
│    "price_change": "200.00",       // 24h 价格变动                          │
│    "price_change_percent": "0.40", // 24h 涨跌幅                            │
│    "high_price": "50800.00",       // 24h 最高价                            │
│    "low_price": "49200.00",        // 24h 最低价                            │
│    "volume": "12345.67",           // 24h 成交量 (BTC)                      │
│    "quote_volume": "617283950.00", // 24h 成交额 (USDC)                     │
│    "open_price": "50000.00",       // 24h 开盘价                            │
│    "trades": 98765,                // 24h 成交笔数                          │
│    "best_bid": "50190.00",         // 最优买价                              │
│    "best_ask": "50210.00",         // 最优卖价                              │
│    "timestamp": 1704067200000      // 时间戳                                │
│  }                                                                           │
│                                                                              │
│  计算方式:                                                                   │
│  ──────────                                                                  │
│                                                                              │
│  方式一: 滑动窗口 (精确但内存占用大)                                         │
│  ─────────────────────────────────                                           │
│  - 保存最近 24h 的所有成交                                                   │
│  - 每次计算时遍历计算                                                        │
│  - 内存占用: 成交量 × 单条大小                                              │
│                                                                              │
│  方式二: 1分钟桶聚合 (推荐)                                                  │
│  ────────────────────────────                                                │
│  - 每分钟生成一个统计桶                                                      │
│  - 保存最近 1440 个桶 (24h × 60min)                                         │
│  - 计算 Ticker 时聚合所有桶                                                  │
│                                                                              │
│  1分钟桶结构:                                                                │
│  {                                                                           │
│    "minute": 1704067200,           // 分钟时间戳                            │
│    "open": "50000.00",                                                       │
│    "high": "50050.00",                                                       │
│    "low": "49980.00",                                                        │
│    "close": "50020.00",                                                      │
│    "volume": "12.34",                                                        │
│    "quote_volume": "617000.00",                                              │
│    "trades": 150                                                             │
│  }                                                                           │
│                                                                              │
│  Ticker 计算伪代码:                                                          │
│  ────────────────────                                                        │
│                                                                              │
│  func CalculateTicker(market string) *Ticker {                               │
│      buckets := getLast24hBuckets(market)  // 获取最近 1440 个桶            │
│                                                                              │
│      ticker := &Ticker{                                                      │
│          Symbol:    market,                                                  │
│          OpenPrice: buckets[0].Open,       // 24h 前的开盘价                │
│          LastPrice: buckets[len-1].Close,  // 最新价                        │
│      }                                                                       │
│                                                                              │
│      for _, b := range buckets {                                             │
│          if b.High > ticker.HighPrice { ticker.HighPrice = b.High }          │
│          if b.Low < ticker.LowPrice { ticker.LowPrice = b.Low }              │
│          ticker.Volume += b.Volume                                           │
│          ticker.QuoteVolume += b.QuoteVolume                                 │
│          ticker.Trades += b.Trades                                           │
│      }                                                                       │
│                                                                              │
│      ticker.PriceChange = ticker.LastPrice - ticker.OpenPrice                │
│      ticker.PriceChangePercent = ticker.PriceChange / ticker.OpenPrice * 100 │
│                                                                              │
│      return ticker                                                           │
│  }                                                                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.4 订单簿深度管理

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        订单簿深度管理                                        │
│                                                                              │
│  深度级别:                                                                   │
│  ═════════                                                                   │
│  - depth:5    前 5 档                                                        │
│  - depth:10   前 10 档                                                       │
│  - depth:20   前 20 档 (默认)                                               │
│  - depth:50   前 50 档                                                       │
│  - depth:100  前 100 档                                                      │
│                                                                              │
│  深度数据结构:                                                               │
│  ──────────────                                                              │
│  {                                                                           │
│    "last_update_id": 123456789,    // 更新序列号                            │
│    "bids": [                        // 买单 (价格降序)                       │
│      ["49990.00", "1.5"],          // [价格, 数量]                          │
│      ["49980.00", "2.3"],                                                    │
│      ["49970.00", "5.0"]                                                     │
│    ],                                                                        │
│    "asks": [                        // 卖单 (价格升序)                       │
│      ["50010.00", "0.8"],                                                    │
│      ["50020.00", "1.2"],                                                    │
│      ["50030.00", "3.5"]                                                     │
│    ]                                                                         │
│  }                                                                           │
│                                                                              │
│  深度聚合 (按精度):                                                          │
│  ─────────────────                                                           │
│                                                                              │
│  原始深度:                          聚合后 (精度=10):                        │
│  49991.23  1.0                      49990   5.5 (合并 49990-49999)          │
│  49995.67  2.5                      49980   3.2 (合并 49980-49989)          │
│  49998.00  2.0                                                               │
│  49982.50  1.7                                                               │
│  49985.00  1.5                                                               │
│                                                                              │
│  聚合算法:                                                                   │
│  ──────────                                                                  │
│  aggregatedPrice = floor(price / precision) * precision                      │
│  例: floor(49991.23 / 10) * 10 = 49990                                      │
│                                                                              │
│  增量更新:                                                                   │
│  ──────────                                                                  │
│  从 eidos-matching 接收增量更新:                                             │
│  {                                                                           │
│    "update_type": "UPDATE",         // ADD/REMOVE/UPDATE                    │
│    "side": "BUY",                                                            │
│    "price": "49990.00",                                                      │
│    "size": "5.5"                    // 新的该价位总量, 0 表示删除           │
│  }                                                                           │
│                                                                              │
│  更新流程:                                                                   │
│  ──────────                                                                  │
│  1. 更新内存中的订单簿快照                                                   │
│  2. 发布增量更新到 Redis Pub/Sub                                             │
│  3. 定期生成全量快照 (每 100ms)                                              │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 三、数据库设计

### 3.1 K线表 (TimescaleDB - 时序数据库)

```sql
-- 创建 TimescaleDB 扩展
CREATE EXTENSION IF NOT EXISTS timescaledb;

-- K线表 (所有周期共用一张表)
CREATE TABLE klines (
    time            TIMESTAMPTZ NOT NULL,         -- 开盘时间
    market          VARCHAR(20) NOT NULL,         -- 交易对
    interval        VARCHAR(5) NOT NULL,          -- 周期 (1m, 5m, 15m, 1h, 4h, 1d, 1w)

    -- OHLCV 数据
    open            DECIMAL(36, 18) NOT NULL,
    high            DECIMAL(36, 18) NOT NULL,
    low             DECIMAL(36, 18) NOT NULL,
    close           DECIMAL(36, 18) NOT NULL,
    volume          DECIMAL(36, 18) NOT NULL,     -- 成交量 (base)
    quote_volume    DECIMAL(36, 18) NOT NULL,     -- 成交额 (quote)
    trades          INT NOT NULL,                 -- 成交笔数

    PRIMARY KEY (market, interval, time)
);

-- 创建 Hypertable (TimescaleDB 核心功能)
SELECT create_hypertable('klines', 'time',
    chunk_time_interval => INTERVAL '1 day'
);

-- 创建索引
CREATE INDEX idx_klines_market_interval ON klines (market, interval, time DESC);

-- 数据保留策略
-- 1m K线保留 7 天
-- 5m K线保留 30 天
-- 15m+ 周期永久保留
SELECT add_retention_policy('klines',
    INTERVAL '7 days',
    if_not_exists => TRUE
);

-- 压缩策略 (7天后压缩)
ALTER TABLE klines SET (
    timescaledb.compress,
    timescaledb.compress_segmentby = 'market, interval'
);

SELECT add_compression_policy('klines', INTERVAL '7 days');

-- 大周期 K线 Continuous Aggregate (可选优化)
CREATE MATERIALIZED VIEW klines_5m
WITH (timescaledb.continuous) AS
SELECT
    market,
    '5m'::VARCHAR AS interval,
    time_bucket('5 minutes', time) AS time,
    first(open, time) AS open,
    max(high) AS high,
    min(low) AS low,
    last(close, time) AS close,
    sum(volume) AS volume,
    sum(quote_volume) AS quote_volume,
    sum(trades) AS trades
FROM klines
WHERE interval = '1m'
GROUP BY market, time_bucket('5 minutes', time);

-- 刷新策略: 每 5 分钟自动刷新
SELECT add_continuous_aggregate_policy('klines_5m',
    start_offset => INTERVAL '1 hour',
    end_offset => INTERVAL '5 minutes',
    schedule_interval => INTERVAL '5 minutes'
);
```

> **K线刷新策略说明**:
> - **1m K线**: 实时写入 (每笔成交触发更新 Redis 缓存，每分钟持久化到 DB)
> - **5m/15m/... 大周期**: 方式一 - 服务端内存聚合后写入；方式二 - 使用 TimescaleDB Continuous Aggregate 自动刷新
> - **刷新延迟**: start_offset=1h 表示刷新 1 小时前的数据，end_offset=5m 表示最近 5 分钟的数据暂不刷新 (仍在变化中)

### 3.2 交易对配置表 (PostgreSQL)

```sql
CREATE TABLE markets (
    id              SERIAL PRIMARY KEY,
    symbol          VARCHAR(20) NOT NULL UNIQUE,  -- BTC-USDC
    base_token      VARCHAR(10) NOT NULL,         -- BTC
    quote_token     VARCHAR(10) NOT NULL,         -- USDC

    -- 精度配置
    price_decimals  SMALLINT NOT NULL DEFAULT 2,
    size_decimals   SMALLINT NOT NULL DEFAULT 6,
    min_size        DECIMAL(36, 18) NOT NULL,
    max_size        DECIMAL(36, 18),
    min_notional    DECIMAL(36, 18) NOT NULL,     -- 最小成交额
    tick_size       DECIMAL(36, 18) NOT NULL,     -- 最小价格变动

    -- 费率
    maker_fee       DECIMAL(10, 6) NOT NULL DEFAULT 0.001,
    taker_fee       DECIMAL(10, 6) NOT NULL DEFAULT 0.001,

    -- 状态
    status          SMALLINT NOT NULL DEFAULT 1,  -- 1=活跃, 2=暂停, 3=下线
    trading_enabled BOOLEAN NOT NULL DEFAULT TRUE,

    -- 审计字段
    created_by      VARCHAR(42),
    created_at      BIGINT NOT NULL,
    updated_by      VARCHAR(42),
    updated_at      BIGINT NOT NULL
);

-- 插入初始交易对
INSERT INTO markets (symbol, base_token, quote_token, price_decimals, size_decimals,
                     min_size, min_notional, tick_size, maker_fee, taker_fee)
VALUES
    ('BTC-USDC', 'BTC', 'USDC', 2, 6, 0.0001, 10, 0.01, 0.0005, 0.001),
    ('ETH-USDC', 'ETH', 'USDC', 2, 6, 0.001, 10, 0.01, 0.0005, 0.001);
```

### 3.3 Redis 缓存结构

> **命名规范**: 所有 Redis Key 使用 `eidos:` 前缀，与 Pub/Sub Channel 保持一致

```
# Ticker 缓存
eidos:ticker:{market}
Value: {
    "symbol": "BTC-USDC",
    "last_price": "50200.00",
    "price_change": "200.00",
    "price_change_percent": "0.40",
    ...
}
TTL: 不过期 (实时更新)

# 订单簿快照
eidos:orderbook:{market}
Value: {
    "last_update_id": 123456789,
    "bids": [...],
    "asks": [...]
}
TTL: 不过期 (实时更新)

# 最近成交
eidos:trades:{market}
Type: List (最新的在头部)
Max Length: 100
Value: [
    {"id":"...", "price":"50200", "size":"0.1", "side":"BUY", "time":...},
    ...
]

# 1分钟桶 (用于 Ticker 计算)
eidos:ticker_bucket:{market}:{minute}
Value: {
    "open": "50000",
    "high": "50050",
    "low": "49980",
    "close": "50020",
    "volume": "12.34",
    "trades": 150
}
TTL: 25 小时 (保留 24h + 1h 缓冲)

# 当前 K线
eidos:kline:{market}:{interval}
Value: {
    "open_time": 1704067200000,
    "open": "50000",
    "high": "50500",
    "low": "49800",
    "close": "50200",
    "volume": "123.456",
    "trades": 1234
}
TTL: 不过期 (实时更新)
```

---

## 四、数据流转

### 4.1 成交事件处理流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        成交事件处理流程                                      │
│                                                                              │
│  Kafka (trade-results)          Market Data Service                         │
│         │                              │                                    │
│         │  TradeResult                 │                                    │
│         │  {                           │                                    │
│         │    trade_id: "...",          │                                    │
│         │    market: "BTC-USDC",       │                                    │
│         │    price: "50200",           │                                    │
│         │    size: "0.1",              │                                    │
│         │    side: "BUY",              │                                    │
│         │    timestamp: ...            │                                    │
│         │  }                           │                                    │
│         │─────────────────────────────>│                                    │
│         │                              │                                    │
│         │                              │  1. 更新 1m K线                    │
│         │                              │     kline.High = max(High, price)  │
│         │                              │     kline.Low = min(Low, price)    │
│         │                              │     kline.Close = price            │
│         │                              │     kline.Volume += size           │
│         │                              │                                    │
│         │                              │  2. 更新 1分钟桶                   │
│         │                              │     bucket.Close = price           │
│         │                              │     bucket.Volume += size          │
│         │                              │     bucket.Trades++                │
│         │                              │                                    │
│         │                              │  3. 更新 Ticker                    │
│         │                              │     ticker.LastPrice = price       │
│         │                              │     ticker.Volume += size          │
│         │                              │     (增量更新)                     │
│         │                              │                                    │
│         │                              │  4. 添加到最近成交列表             │
│         │                              │     LPUSH trades:BTC-USDC          │
│         │                              │     LTRIM trades:BTC-USDC 0 99     │
│         │                              │                                    │
│         │                              │  5. 发布更新事件                   │
│         │                              │     ─────────────────────────>     │
│         │                              │     Redis Pub/Sub:                 │
│         │                              │     - kline:BTC-USDC:1m            │
│         │                              │     - ticker:BTC-USDC              │
│         │                              │     - trades:BTC-USDC              │
│         │                              │                                    │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 订单簿更新流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       订单簿更新流程                                         │
│                                                                              │
│  Kafka (orderbook-updates)      Market Data Service          Redis Pub/Sub  │
│         │                              │                          │         │
│         │  OrderBookUpdate             │                          │         │
│         │  {                           │                          │         │
│         │    market: "BTC-USDC",       │                          │         │
│         │    update_type: "UPDATE",    │                          │         │
│         │    side: "BUY",              │                          │         │
│         │    price: "49990",           │                          │         │
│         │    size: "5.5",              │                          │         │
│         │    sequence: 123456          │                          │         │
│         │  }                           │                          │         │
│         │─────────────────────────────>│                          │         │
│         │                              │                          │         │
│         │                              │  1. 检查序列号           │         │
│         │                              │     防止乱序更新         │         │
│         │                              │                          │         │
│         │                              │  2. 更新内存订单簿       │         │
│         │                              │     if size == 0:        │         │
│         │                              │       删除该价位         │         │
│         │                              │     else:                │         │
│         │                              │       更新/添加价位      │         │
│         │                              │                          │         │
│         │                              │  3. 更新 Redis 缓存      │         │
│         │                              │     SET eidos:orderbook:{market}   │
│         │                              │                          │         │
│         │                              │  4. 更新 Ticker 的盘口   │         │
│         │                              │     ticker.BestBid       │         │
│         │                              │     ticker.BestAsk       │         │
│         │                              │                          │         │
│         │                              │  5. 发布增量更新 ────────>│         │
│         │                              │     channel: eidos:depth:BTC-USDC:20
│         │                              │     {                              │
│         │                              │       "type": "UPDATE",            │
│         │                              │       "side": "BUY",               │
│         │                              │       "price": "49990",            │
│         │                              │       "size": "5.5"                │
│         │                              │     }                              │
│         │                              │                          │         │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 五、Proto 设计

### 5.1 market_data_service.proto

```protobuf
syntax = "proto3";

package marketdata;

option go_package = "github.com/eidos-exchange/proto/marketdata";

import "google/protobuf/timestamp.proto";

// 行情数据服务
service MarketDataService {
    // K线查询
    rpc GetKlines(GetKlinesRequest) returns (GetKlinesResponse);

    // Ticker 查询
    rpc GetTicker(GetTickerRequest) returns (GetTickerResponse);
    rpc GetTickers(GetTickersRequest) returns (GetTickersResponse);

    // 订单簿查询
    rpc GetOrderBook(GetOrderBookRequest) returns (GetOrderBookResponse);

    // 最近成交
    rpc GetTrades(GetTradesRequest) returns (GetTradesResponse);

    // 交易对查询
    rpc GetMarkets(GetMarketsRequest) returns (GetMarketsResponse);
    rpc GetMarket(GetMarketRequest) returns (GetMarketResponse);
}

// ============ 枚举定义 ============

enum KlineInterval {
    KLINE_INTERVAL_UNSPECIFIED = 0;
    KLINE_INTERVAL_1M = 1;
    KLINE_INTERVAL_5M = 2;
    KLINE_INTERVAL_15M = 3;
    KLINE_INTERVAL_30M = 4;
    KLINE_INTERVAL_1H = 5;
    KLINE_INTERVAL_4H = 6;
    KLINE_INTERVAL_1D = 7;
    KLINE_INTERVAL_1W = 8;
}

enum MarketStatus {
    MARKET_STATUS_UNSPECIFIED = 0;
    MARKET_STATUS_ACTIVE = 1;
    MARKET_STATUS_SUSPENDED = 2;
    MARKET_STATUS_DELISTED = 3;
}

// ============ 消息定义 ============

message Kline {
    int64 open_time = 1;          // 开盘时间 (毫秒)
    string open = 2;
    string high = 3;
    string low = 4;
    string close = 5;
    string volume = 6;            // 成交量 (base)
    string quote_volume = 7;      // 成交额 (quote)
    int32 trades = 8;             // 成交笔数
    int64 close_time = 9;         // 收盘时间 (毫秒)
}

message Ticker {
    string symbol = 1;
    string last_price = 2;
    string price_change = 3;
    string price_change_percent = 4;
    string high_price = 5;
    string low_price = 6;
    string volume = 7;
    string quote_volume = 8;
    string open_price = 9;
    int32 trades = 10;
    string best_bid = 11;
    string best_ask = 12;
    int64 timestamp = 13;
}

message OrderBookLevel {
    string price = 1;
    string size = 2;
}

message OrderBook {
    string symbol = 1;
    int64 last_update_id = 2;
    repeated OrderBookLevel bids = 3;
    repeated OrderBookLevel asks = 4;
    int64 timestamp = 5;
}

message Trade {
    string trade_id = 1;
    string price = 2;
    string size = 3;
    string side = 4;              // BUY/SELL
    int64 timestamp = 5;
}

message Market {
    string symbol = 1;
    string base_token = 2;
    string quote_token = 3;
    int32 price_decimals = 4;
    int32 size_decimals = 5;
    string min_size = 6;
    string max_size = 7;
    string min_notional = 8;
    string tick_size = 9;
    string maker_fee = 10;
    string taker_fee = 11;
    MarketStatus status = 12;
}

// ============ 请求/响应定义 ============

message GetKlinesRequest {
    string symbol = 1;
    KlineInterval interval = 2;
    int64 start_time = 3;         // 可选，毫秒时间戳
    int64 end_time = 4;           // 可选
    int32 limit = 5;              // 默认 500，最大 1000
}

message GetKlinesResponse {
    repeated Kline klines = 1;
}

message GetTickerRequest {
    string symbol = 1;
}

message GetTickerResponse {
    Ticker ticker = 1;
}

message GetTickersRequest {
    // 空表示查询所有
}

message GetTickersResponse {
    repeated Ticker tickers = 1;
}

message GetOrderBookRequest {
    string symbol = 1;
    int32 limit = 2;              // 5, 10, 20, 50, 100
}

message GetOrderBookResponse {
    OrderBook order_book = 1;
}

message GetTradesRequest {
    string symbol = 1;
    int32 limit = 2;              // 默认 100，最大 1000
}

message GetTradesResponse {
    repeated Trade trades = 1;
}

message GetMarketsRequest {
    MarketStatus status = 1;      // 可选，筛选状态
}

message GetMarketsResponse {
    repeated Market markets = 1;
}

message GetMarketRequest {
    string symbol = 1;
}

message GetMarketResponse {
    Market market = 1;
}
```

---

## 六、配置项

```yaml
# eidos-market 配置
service:
  name: eidos-market
  port: 50055

# Kafka 配置
kafka:
  brokers:
    - kafka-1:9092
    - kafka-2:9092
    - kafka-3:9092
  consumer:
    group_id: eidos-market
    topics:
      - trade-results
      - orderbook-updates

# Redis 配置
redis:
  cluster:
    nodes:
      - redis-1:6379
      - redis-2:6379
      - redis-3:6379

# TimescaleDB 配置
timescaledb:
  host: timescaledb
  port: 5432
  database: eidos_market_data

# PostgreSQL 配置 (交易对配置)
postgres:
  host: postgres
  port: 5432
  database: eidos_markets

# K线配置
klines:
  intervals:
    - 1m
    - 5m
    - 15m
    - 30m
    - 1h
    - 4h
    - 1d
    - 1w
  retention:
    1m: 7d                        # 1分钟线保留 7 天
    5m: 30d                       # 5分钟线保留 30 天
    15m: 90d                      # 15分钟线保留 90 天
    others: forever               # 其他永久保留

# 订单簿配置
orderbook:
  levels:
    - 5
    - 10
    - 20
    - 50
    - 100
  snapshot_interval: 100ms        # 全量快照间隔

# Ticker 配置
ticker:
  update_interval: 100ms          # 推送间隔
  bucket_count: 1440              # 1分钟桶数量 (24h)
```

---

## 七、监控指标

```go
// Prometheus 指标
var (
    // K线更新
    klineUpdates = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "market_data_kline_updates_total",
            Help: "Total kline updates",
        },
        []string{"market", "interval"},
    )

    // Ticker 更新
    tickerUpdates = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "market_data_ticker_updates_total",
            Help: "Total ticker updates",
        },
        []string{"market"},
    )

    // 订单簿更新
    orderbookUpdates = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "market_data_orderbook_updates_total",
            Help: "Total orderbook updates",
        },
        []string{"market"},
    )

    // 成交处理
    tradesProcessed = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "market_data_trades_processed_total",
            Help: "Total trades processed",
        },
        []string{"market"},
    )

    // Pub/Sub 发布延迟
    pubsubLatency = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "market_data_pubsub_latency_milliseconds",
            Help:    "Pub/Sub publish latency",
            Buckets: []float64{1, 5, 10, 50, 100, 500},
        },
        []string{"channel_type"},
    )

    // gRPC 查询延迟
    grpcLatency = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "market_data_grpc_latency_milliseconds",
            Help:    "gRPC request latency",
            Buckets: []float64{1, 5, 10, 50, 100, 500},
        },
        []string{"method"},
    )

    // 数据恢复指标
    recoveryDuration = prometheus.NewHistogram(
        prometheus.HistogramOpts{
            Name:    "market_data_recovery_duration_seconds",
            Help:    "Data recovery duration on startup",
            Buckets: []float64{1, 5, 10, 30, 60, 120},
        },
    )

    // 订单簿同步指标
    orderbookSyncTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "market_data_orderbook_sync_total",
            Help: "Total orderbook full sync requests",
        },
        []string{"market", "reason"},
    )
)
```

---

## 八、容灾恢复机制

### 8.1 恢复架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        容灾恢复机制                                          │
│                                                                              │
│  服务启动恢复流程:                                                           │
│  ═══════════════════                                                         │
│                                                                              │
│  ┌───────────┐     ┌───────────┐     ┌───────────┐     ┌───────────┐       │
│  │ 1.加载检查点│ ──> │ 2.恢复K线 │ ──> │ 3.同步订单簿│ ──> │ 4.正常消费 │       │
│  │   (Redis)  │     │(TimescaleDB)│     │ (Matching) │     │  (Kafka)  │       │
│  └───────────┘     └───────────┘     └───────────┘     └───────────┘       │
│                                                                              │
│  阶段详解:                                                                   │
│  ──────────                                                                  │
│  阶段1: 加载检查点                                                           │
│    - 从 Redis 读取最后处理的 Kafka offset                                    │
│    - 读取各交易对的最后 K线时间戳                                            │
│                                                                              │
│  阶段2: 恢复 K线数据                                                         │
│    - 从 TimescaleDB 加载最近 2 小时的 1m K线                                 │
│    - 重建内存中的 K线聚合器状态                                              │
│    - 计算大周期 K线的未完成部分                                              │
│                                                                              │
│  阶段3: 同步订单簿                                                           │
│    - 从 eidos-matching 获取全量订单簿快照                                    │
│    - 初始化内存订单簿                                                        │
│                                                                              │
│  阶段4: 正常消费                                                             │
│    - 从检查点 offset 开始消费 Kafka                                          │
│    - 处理成交和订单簿更新                                                    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 8.2 检查点机制

```go
// 检查点结构
type Checkpoint struct {
    Market         string `json:"market"`
    KafkaOffset    int64  `json:"kafka_offset"`
    LastKlineTime  int64  `json:"last_kline_time"`  // 最后 K线开盘时间
    LastTradeID    string `json:"last_trade_id"`
    UpdatedAt      int64  `json:"updated_at"`
}

// Redis Key
// eidos:market:checkpoint:{market}

// 检查点保存策略
const (
    CheckpointInterval = 10 * time.Second  // 每 10 秒保存
    CheckpointOnBatch  = 100               // 每处理 100 条消息保存
)

// 保存检查点
func (s *MarketService) SaveCheckpoint(market string, offset int64, lastKline *Kline) error {
    checkpoint := &Checkpoint{
        Market:        market,
        KafkaOffset:   offset,
        LastKlineTime: lastKline.OpenTime,
        UpdatedAt:     time.Now().UnixMilli(),
    }

    data, _ := json.Marshal(checkpoint)
    key := fmt.Sprintf("eidos:market:checkpoint:%s", market)

    return s.redis.Set(ctx, key, data, 24*time.Hour).Err()
}

// 启动恢复
func (s *MarketService) RecoverOnStartup(market string) error {
    // 1. 加载检查点
    checkpoint, err := s.loadCheckpoint(market)
    if err != nil {
        log.Warn("No checkpoint found, starting fresh", "market", market)
        return s.startFresh(market)
    }

    // 2. 从 TimescaleDB 恢复 K线
    klines, err := s.loadKlinesFromDB(market, checkpoint.LastKlineTime)
    if err != nil {
        return fmt.Errorf("failed to load klines: %w", err)
    }
    s.rebuildKlineAggregator(market, klines)

    // 3. 从 Matching 获取订单簿快照
    orderbook, err := s.fetchOrderBookSnapshot(market)
    if err != nil {
        return fmt.Errorf("failed to fetch orderbook: %w", err)
    }
    s.initOrderBook(market, orderbook)

    // 4. 从检查点开始消费 Kafka
    s.startConsumerFromOffset(market, checkpoint.KafkaOffset)

    return nil
}
```

### 8.3 K线数据恢复

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        K线数据恢复流程                                        │
│                                                                              │
│  场景: 服务宕机 30 分钟后重启                                                 │
│                                                                              │
│  时间线:                                                                     │
│  ────────                                                                    │
│  10:00 - 服务正常运行, 最后检查点                                            │
│  10:00 - 10:30 服务宕机                                                      │
│  10:30 - 服务重启                                                            │
│                                                                              │
│  恢复步骤:                                                                   │
│  ──────────                                                                  │
│  1. 从 TimescaleDB 加载 09:00 - 10:30 的 1m K线                              │
│                                                                              │
│  2. 重建 K线聚合器:                                                          │
│     - 当前 1m K线 = 10:30 的未完成 K线                                       │
│     - 5m K线需要重新计算 (10:25, 10:30 两根)                                 │
│     - 15m/1h 等大周期同理                                                    │
│                                                                              │
│  3. 从 Kafka 回放 10:00 - 10:30 的成交:                                      │
│     - 检查成交时间，跳过已有 K线覆盖的时段                                   │
│     - 只处理最后一根未完成 K线的成交                                         │
│                                                                              │
│  4. 恢复完成，开始正常处理新成交                                             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

```go
// K线恢复实现
func (s *MarketService) rebuildKlineAggregator(market string, klines []*Kline) {
    aggregator := s.getAggregator(market)

    // 按时间排序
    sort.Slice(klines, func(i, j int) bool {
        return klines[i].OpenTime < klines[j].OpenTime
    })

    // 找到最后完成的 K线
    now := time.Now().UnixMilli()
    currentMinute := now - (now % 60000)  // 当前分钟开始

    for _, kline := range klines {
        if kline.OpenTime == currentMinute {
            // 未完成的当前 K线，作为基础继续聚合
            aggregator.SetCurrentKline(kline)
        } else {
            // 已完成的 K线，用于计算大周期
            aggregator.AddCompletedKline(kline)
        }
    }

    // 重新计算大周期 K线
    aggregator.RebuildLargerIntervals()
}
```

### 8.4 Ticker 恢复

```go
// Ticker 恢复 (重建 24 小时统计)
func (s *MarketService) recoverTicker(market string) error {
    // 1. 从 Redis 加载最近 1440 个 1 分钟桶
    buckets, err := s.loadTickerBuckets(market, 1440)
    if err != nil {
        // 如果 Redis 数据丢失，从 TimescaleDB 重建
        buckets, err = s.rebuildTickerBucketsFromDB(market)
        if err != nil {
            return err
        }
    }

    // 2. 重建 Ticker 计算器
    calculator := s.getTickerCalculator(market)
    calculator.LoadBuckets(buckets)

    // 3. 计算当前 Ticker
    ticker := calculator.Calculate()

    // 4. 更新 Redis 缓存
    s.updateTickerCache(market, ticker)

    return nil
}

// 从 TimescaleDB 重建 Ticker 桶
func (s *MarketService) rebuildTickerBucketsFromDB(market string) ([]*TickerBucket, error) {
    // 查询最近 24 小时的 1m K线
    query := `
        SELECT
            time_bucket('1 minute', time) AS minute,
            first(open, time) AS open,
            max(high) AS high,
            min(low) AS low,
            last(close, time) AS close,
            sum(volume) AS volume,
            sum(quote_volume) AS quote_volume,
            sum(trades) AS trades
        FROM klines
        WHERE market = $1
          AND interval = '1m'
          AND time >= NOW() - INTERVAL '24 hours'
        GROUP BY minute
        ORDER BY minute
    `

    rows, err := s.db.Query(query, market)
    // ... 处理结果
}
```

---

## 九、订单簿同步增强

### 9.1 增量更新可靠性

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        订单簿同步增强方案                                     │
│                                                                              │
│  问题: 增量更新可能丢失或乱序                                                 │
│                                                                              │
│  解决方案:                                                                   │
│  ══════════                                                                  │
│                                                                              │
│  1. 序列号检查                                                               │
│  ─────────────                                                               │
│  每条增量更新携带 sequence 序列号                                            │
│  Market Service 检查序列号连续性                                             │
│  如果检测到缺口 → 触发全量同步                                               │
│                                                                              │
│  2. 定期全量同步                                                             │
│  ─────────────                                                               │
│  每 60 秒从 eidos-matching 拉取全量快照                                      │
│  校验本地订单簿与快照的一致性                                                │
│  不一致时用快照替换本地数据                                                  │
│                                                                              │
│  3. 校验和检查                                                               │
│  ─────────────                                                               │
│  每条增量更新携带累计校验和                                                  │
│  本地计算校验和进行比对                                                      │
│  不一致时触发全量同步                                                        │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 9.2 序列号处理

```go
// 订单簿更新消息 (增强版)
type OrderBookUpdate struct {
    Market     string `json:"market"`
    Sequence   int64  `json:"sequence"`      // 序列号
    UpdateType string `json:"update_type"`   // ADD/REMOVE/UPDATE
    Side       string `json:"side"`
    Price      string `json:"price"`
    Size       string `json:"size"`
    Checksum   string `json:"checksum"`      // 累计校验和
    Timestamp  int64  `json:"timestamp"`
}

// 序列号检查器
type SequenceChecker struct {
    market       string
    lastSequence int64
    mu           sync.RWMutex
}

func (c *SequenceChecker) Check(seq int64) (bool, int64) {
    c.mu.Lock()
    defer c.mu.Unlock()

    expected := c.lastSequence + 1

    if seq == expected {
        c.lastSequence = seq
        return true, 0
    }

    if seq > expected {
        // 检测到缺口
        gap := seq - expected
        log.Warn("Sequence gap detected",
            "market", c.market,
            "expected", expected,
            "received", seq,
            "gap", gap)
        return false, gap
    }

    // seq < expected: 重复消息，忽略
    return true, 0
}

// 处理订单簿更新
func (s *MarketService) handleOrderBookUpdate(update *OrderBookUpdate) error {
    checker := s.getSequenceChecker(update.Market)

    ok, gap := checker.Check(update.Sequence)
    if !ok {
        // 检测到序列缺口，触发全量同步
        s.metrics.orderbookSyncTotal.WithLabelValues(update.Market, "sequence_gap").Inc()
        return s.triggerFullSync(update.Market)
    }

    // 应用增量更新
    if err := s.applyOrderBookUpdate(update); err != nil {
        return err
    }

    // 验证校验和
    if !s.verifyChecksum(update.Market, update.Checksum) {
        s.metrics.orderbookSyncTotal.WithLabelValues(update.Market, "checksum_mismatch").Inc()
        return s.triggerFullSync(update.Market)
    }

    return nil
}
```

### 9.3 全量同步机制

```go
// 全量同步触发条件
const (
    FullSyncInterval    = 60 * time.Second   // 定期同步间隔
    MaxSequenceGap      = 10                  // 允许的最大序列缺口
    ChecksumMismatchMax = 3                   // 连续校验失败次数
)

// 全量同步服务
type OrderBookSyncer struct {
    matchingClient MatchingServiceClient
    localBooks     map[string]*OrderBook
    lastSyncTime   map[string]time.Time
    mu             sync.RWMutex
}

// 定期同步任务
func (s *OrderBookSyncer) StartPeriodicSync(ctx context.Context) {
    ticker := time.NewTicker(FullSyncInterval)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            for market := range s.localBooks {
                go s.syncMarket(market)
            }
        }
    }
}

// 同步单个市场
func (s *OrderBookSyncer) syncMarket(market string) error {
    // 1. 从撮合引擎获取快照
    resp, err := s.matchingClient.GetOrderBookSnapshot(ctx, &GetSnapshotRequest{
        Market: market,
        Depth:  100,  // 获取前 100 档
    })
    if err != nil {
        return fmt.Errorf("failed to get snapshot: %w", err)
    }

    // 2. 比对本地数据
    localBook := s.getLocalBook(market)
    if s.isConsistent(localBook, resp.OrderBook) {
        log.Debug("Orderbook consistent", "market", market)
        return nil
    }

    // 3. 不一致，替换本地数据
    log.Warn("Orderbook inconsistent, replacing", "market", market)
    s.replaceLocalBook(market, resp.OrderBook)

    // 4. 更新 Redis 缓存
    s.updateRedisCache(market, resp.OrderBook)

    // 5. 重置序列号
    s.resetSequence(market, resp.LastSequence)

    return nil
}

// 一致性检查
func (s *OrderBookSyncer) isConsistent(local, remote *OrderBook) bool {
    // 检查最优买卖价
    if local.BestBid != remote.BestBid || local.BestAsk != remote.BestAsk {
        return false
    }

    // 检查前 10 档深度
    for i := 0; i < 10 && i < len(local.Bids); i++ {
        if local.Bids[i].Price != remote.Bids[i].Price ||
           local.Bids[i].Size != remote.Bids[i].Size {
            return false
        }
    }
    for i := 0; i < 10 && i < len(local.Asks); i++ {
        if local.Asks[i].Price != remote.Asks[i].Price ||
           local.Asks[i].Size != remote.Asks[i].Size {
            return false
        }
    }

    return true
}
```

### 9.4 订单簿校验和算法

```go
// 校验和计算 (CRC32)
// 格式: 将买卖档位按 "price:size" 拼接后计算 CRC32
func CalculateOrderBookChecksum(book *OrderBook) string {
    var builder strings.Builder

    // 买单 (前 25 档)
    for i := 0; i < 25 && i < len(book.Bids); i++ {
        builder.WriteString(book.Bids[i].Price)
        builder.WriteString(":")
        builder.WriteString(book.Bids[i].Size)
        builder.WriteString("|")
    }

    // 卖单 (前 25 档)
    for i := 0; i < 25 && i < len(book.Asks); i++ {
        builder.WriteString(book.Asks[i].Price)
        builder.WriteString(":")
        builder.WriteString(book.Asks[i].Size)
        builder.WriteString("|")
    }

    checksum := crc32.ChecksumIEEE([]byte(builder.String()))
    return fmt.Sprintf("%08x", checksum)
}
```

---

## 十、历史查询分页设计

### 10.1 Proto 定义增强

```protobuf
// 分页请求
message PaginationRequest {
    int32 limit = 1;              // 每页条数，默认 100，最大 1000
    string cursor = 2;            // 游标 (上一页最后一条的 ID/时间戳)
}

// 分页响应
message PaginationResponse {
    string next_cursor = 1;       // 下一页游标
    bool has_more = 2;            // 是否有更多数据
    int32 total = 3;              // 总条数 (可选，仅首页返回)
}

// 增强的成交查询请求
message GetTradesRequest {
    string symbol = 1;
    int32 limit = 2;              // 默认 100，最大 1000

    // 分页方式 (二选一)
    oneof pagination {
        string cursor = 3;        // 游标分页 (推荐)
        int64 from_id = 4;        // ID 分页
    }

    // 时间范围筛选
    int64 start_time = 5;         // 可选，毫秒时间戳
    int64 end_time = 6;           // 可选
}

message GetTradesResponse {
    repeated Trade trades = 1;
    string next_cursor = 2;       // 下一页游标
    bool has_more = 3;
}

// 增强的 K线查询请求
message GetKlinesRequest {
    string symbol = 1;
    KlineInterval interval = 2;
    int64 start_time = 3;         // 可选，毫秒时间戳
    int64 end_time = 4;           // 可选
    int32 limit = 5;              // 默认 500，最大 1500

    // 分页
    string cursor = 6;            // 游标 (K线开盘时间)
}

message GetKlinesResponse {
    repeated Kline klines = 1;
    string next_cursor = 2;
    bool has_more = 3;
}
```

### 10.2 游标分页实现

```go
// 成交记录分页查询
func (s *MarketService) GetTrades(ctx context.Context, req *GetTradesRequest) (*GetTradesResponse, error) {
    limit := int(req.Limit)
    if limit <= 0 {
        limit = 100
    }
    if limit > 1000 {
        limit = 1000
    }

    // 构建查询条件
    query := s.db.Table("trades").Where("market = ?", req.Symbol)

    // 时间范围
    if req.StartTime > 0 {
        query = query.Where("traded_at >= ?", req.StartTime)
    }
    if req.EndTime > 0 {
        query = query.Where("traded_at <= ?", req.EndTime)
    }

    // 游标分页
    if req.Cursor != "" {
        cursor, err := decodeCursor(req.Cursor)
        if err != nil {
            return nil, ErrInvalidCursor
        }
        query = query.Where("(traded_at, trade_id) < (?, ?)", cursor.Time, cursor.ID)
    }

    // 查询 limit+1 条，用于判断是否有下一页
    var trades []*Trade
    query.Order("traded_at DESC, trade_id DESC").
        Limit(limit + 1).
        Find(&trades)

    // 构建响应
    resp := &GetTradesResponse{
        HasMore: len(trades) > limit,
    }

    if resp.HasMore {
        trades = trades[:limit]  // 只返回 limit 条
    }

    resp.Trades = trades

    // 生成下一页游标
    if resp.HasMore && len(trades) > 0 {
        lastTrade := trades[len(trades)-1]
        resp.NextCursor = encodeCursor(&Cursor{
            Time: lastTrade.TradedAt,
            ID:   lastTrade.TradeId,
        })
    }

    return resp, nil
}

// 游标编码/解码
type Cursor struct {
    Time int64  `json:"t"`
    ID   string `json:"i"`
}

func encodeCursor(c *Cursor) string {
    data, _ := json.Marshal(c)
    return base64.URLEncoding.EncodeToString(data)
}

func decodeCursor(s string) (*Cursor, error) {
    data, err := base64.URLEncoding.DecodeString(s)
    if err != nil {
        return nil, err
    }
    var c Cursor
    if err := json.Unmarshal(data, &c); err != nil {
        return nil, err
    }
    return &c, nil
}
```

### 10.3 历史成交存储

```sql
-- 历史成交表 (用于历史查询，与实时缓存分离)
CREATE TABLE trade_history (
    id              BIGSERIAL PRIMARY KEY,
    trade_id        VARCHAR(64) NOT NULL UNIQUE,
    market          VARCHAR(20) NOT NULL,

    -- 成交信息
    price           DECIMAL(36, 18) NOT NULL,
    size            DECIMAL(36, 18) NOT NULL,
    quote_amount    DECIMAL(36, 18) NOT NULL,
    side            SMALLINT NOT NULL,         -- taker 方向

    -- 用户信息
    maker           VARCHAR(42) NOT NULL,
    taker           VARCHAR(42) NOT NULL,

    traded_at       BIGINT NOT NULL,

    INDEX idx_trades_market_time (market, traded_at DESC),
    INDEX idx_trades_maker (maker, traded_at DESC),
    INDEX idx_trades_taker (taker, traded_at DESC)
);

-- 分区表 (按月分区，便于历史数据归档)
CREATE TABLE trade_history_partitioned (
    LIKE trade_history INCLUDING ALL
) PARTITION BY RANGE (traded_at);

-- 自动创建月度分区
CREATE TABLE trade_history_2026_01 PARTITION OF trade_history_partitioned
    FOR VALUES FROM (1735689600000) TO (1738368000000);  -- 2026-01
```

---

## 十一、缓存管理策略

### 11.1 缓存分层

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        缓存分层策略                                          │
│                                                                              │
│  Layer 1: 内存缓存 (进程内)                                                  │
│  ════════════════════════════                                                │
│  - 当前 K线 (各周期)                                                         │
│  - 当前订单簿快照                                                            │
│  - Ticker 计算器状态                                                         │
│  - TTL: 无过期 (随进程生命周期)                                              │
│                                                                              │
│  Layer 2: Redis 缓存 (分布式)                                                │
│  ════════════════════════════                                                │
│  - Ticker 缓存 (供 API 查询)                                                 │
│  - 订单簿缓存 (供 API 查询)                                                  │
│  - 最近成交 (100 条)                                                         │
│  - 检查点数据                                                                │
│  - TTL: 根据数据类型设置                                                     │
│                                                                              │
│  Layer 3: TimescaleDB (持久化)                                               │
│  ════════════════════════════                                                │
│  - 历史 K线                                                                  │
│  - 历史成交                                                                  │
│  - TTL: 按保留策略                                                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 11.2 Redis 缓存 TTL 策略

```yaml
# Redis 缓存 TTL 配置
redis_cache:
  # 实时数据 - 持续更新，无需过期
  ticker:
    ttl: 0                      # 不过期，由服务持续更新
    max_idle: 5m                # 5分钟无更新则清理

  orderbook:
    ttl: 0
    max_idle: 5m

  # 当前 K线 - 持续更新
  current_kline:
    ttl: 0
    max_idle: 5m

  # 1分钟桶 (Ticker 计算用)
  ticker_bucket:
    ttl: 25h                    # 24h + 1h 缓冲

  # 最近成交
  recent_trades:
    ttl: 0
    max_length: 100             # LTRIM 保持最多 100 条

  # 检查点
  checkpoint:
    ttl: 24h
```

### 11.3 缓存清理机制

```go
// 定期清理过期/无效缓存
type CacheCleaner struct {
    redis  *redis.ClusterClient
    config CacheConfig
}

func (c *CacheCleaner) StartCleanupTask(ctx context.Context) {
    ticker := time.NewTicker(5 * time.Minute)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            c.cleanupIdleMarkets()
            c.cleanupStaleTickerBuckets()
        }
    }
}

// 清理空闲市场的缓存 (已下线的交易对)
func (c *CacheCleaner) cleanupIdleMarkets() {
    activeMarkets := c.getActiveMarkets()

    // 扫描所有 eidos:ticker:* 键
    iter := c.redis.Scan(ctx, 0, "eidos:ticker:*", 100).Iterator()
    for iter.Next(ctx) {
        key := iter.Val()
        market := extractMarket(key)

        if !activeMarkets.Contains(market) {
            // 检查最后更新时间
            lastUpdate, _ := c.redis.HGet(ctx, key, "timestamp").Int64()
            if time.Since(time.UnixMilli(lastUpdate)) > c.config.MaxIdleTime {
                c.redis.Del(ctx, key)
                log.Info("Cleaned up idle market cache", "market", market)
            }
        }
    }
}

// 清理过期的 Ticker 桶
func (c *CacheCleaner) cleanupStaleTickerBuckets() {
    pattern := "eidos:ticker_bucket:*"
    threshold := time.Now().Add(-25 * time.Hour).UnixMilli() / 60000 // 分钟时间戳

    iter := c.redis.Scan(ctx, 0, pattern, 1000).Iterator()
    for iter.Next(ctx) {
        key := iter.Val()
        minute := extractMinute(key)

        if minute < threshold {
            c.redis.Del(ctx, key)
        }
    }
}
```
