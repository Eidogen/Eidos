// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v5.29.3
// source: common/kafka.proto

package commonv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// OrderMessage represents a new order sent to the matching engine
type OrderMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique order identifier
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// User wallet address
	Wallet string `protobuf:"bytes,2,opt,name=wallet,proto3" json:"wallet,omitempty"`
	// Trading pair symbol (e.g., "BTC-USDC")
	Market string `protobuf:"bytes,3,opt,name=market,proto3" json:"market,omitempty"`
	// Order direction (buy/sell)
	Side OrderSide `protobuf:"varint,4,opt,name=side,proto3,enum=eidos.common.v1.OrderSide" json:"side,omitempty"`
	// Order type (limit/market)
	OrderType OrderType `protobuf:"varint,5,opt,name=order_type,json=orderType,proto3,enum=eidos.common.v1.OrderType" json:"order_type,omitempty"`
	// Order price (decimal string, required for limit orders)
	Price string `protobuf:"bytes,6,opt,name=price,proto3" json:"price,omitempty"`
	// Order amount in base token (decimal string)
	Amount string `protobuf:"bytes,7,opt,name=amount,proto3" json:"amount,omitempty"`
	// Quote amount for market orders (decimal string, optional)
	// Used when buying with quote amount (e.g., "buy $100 worth of BTC")
	QuoteAmount string `protobuf:"bytes,8,opt,name=quote_amount,json=quoteAmount,proto3" json:"quote_amount,omitempty"`
	// Time in force policy
	TimeInForce TimeInForce `protobuf:"varint,9,opt,name=time_in_force,json=timeInForce,proto3,enum=eidos.common.v1.TimeInForce" json:"time_in_force,omitempty"`
	// Self-trade prevention mode
	SelfTradePrevention SelfTradePrevention `protobuf:"varint,10,opt,name=self_trade_prevention,json=selfTradePrevention,proto3,enum=eidos.common.v1.SelfTradePrevention" json:"self_trade_prevention,omitempty"`
	// Client-provided order ID for idempotency
	ClientOrderId string `protobuf:"bytes,11,opt,name=client_order_id,json=clientOrderId,proto3" json:"client_order_id,omitempty"`
	// Order expiry timestamp (Unix milliseconds, 0 = no expiry)
	ExpireAt int64 `protobuf:"varint,12,opt,name=expire_at,json=expireAt,proto3" json:"expire_at,omitempty"`
	// Maximum slippage for market orders (basis points, e.g., 50 = 0.5%)
	MaxSlippageBps uint32 `protobuf:"varint,13,opt,name=max_slippage_bps,json=maxSlippageBps,proto3" json:"max_slippage_bps,omitempty"`
	// Minimum fill amount for IOC orders (decimal string, optional)
	MinFillAmount string `protobuf:"bytes,14,opt,name=min_fill_amount,json=minFillAmount,proto3" json:"min_fill_amount,omitempty"`
	// Order creation timestamp (Unix milliseconds)
	CreatedAt     int64 `protobuf:"varint,15,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OrderMessage) Reset() {
	*x = OrderMessage{}
	mi := &file_common_kafka_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OrderMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OrderMessage) ProtoMessage() {}

func (x *OrderMessage) ProtoReflect() protoreflect.Message {
	mi := &file_common_kafka_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OrderMessage.ProtoReflect.Descriptor instead.
func (*OrderMessage) Descriptor() ([]byte, []int) {
	return file_common_kafka_proto_rawDescGZIP(), []int{0}
}

func (x *OrderMessage) GetOrderId() string {
	if x != nil {
		return x.OrderId
	}
	return ""
}

func (x *OrderMessage) GetWallet() string {
	if x != nil {
		return x.Wallet
	}
	return ""
}

func (x *OrderMessage) GetMarket() string {
	if x != nil {
		return x.Market
	}
	return ""
}

func (x *OrderMessage) GetSide() OrderSide {
	if x != nil {
		return x.Side
	}
	return OrderSide_ORDER_SIDE_UNSPECIFIED
}

func (x *OrderMessage) GetOrderType() OrderType {
	if x != nil {
		return x.OrderType
	}
	return OrderType_ORDER_TYPE_UNSPECIFIED
}

func (x *OrderMessage) GetPrice() string {
	if x != nil {
		return x.Price
	}
	return ""
}

func (x *OrderMessage) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *OrderMessage) GetQuoteAmount() string {
	if x != nil {
		return x.QuoteAmount
	}
	return ""
}

func (x *OrderMessage) GetTimeInForce() TimeInForce {
	if x != nil {
		return x.TimeInForce
	}
	return TimeInForce_TIME_IN_FORCE_UNSPECIFIED
}

func (x *OrderMessage) GetSelfTradePrevention() SelfTradePrevention {
	if x != nil {
		return x.SelfTradePrevention
	}
	return SelfTradePrevention_SELF_TRADE_PREVENTION_UNSPECIFIED
}

func (x *OrderMessage) GetClientOrderId() string {
	if x != nil {
		return x.ClientOrderId
	}
	return ""
}

func (x *OrderMessage) GetExpireAt() int64 {
	if x != nil {
		return x.ExpireAt
	}
	return 0
}

func (x *OrderMessage) GetMaxSlippageBps() uint32 {
	if x != nil {
		return x.MaxSlippageBps
	}
	return 0
}

func (x *OrderMessage) GetMinFillAmount() string {
	if x != nil {
		return x.MinFillAmount
	}
	return ""
}

func (x *OrderMessage) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

// CancelRequestMessage represents a request to cancel an order
type CancelRequestMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Order ID to cancel
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// Trading pair symbol
	Market string `protobuf:"bytes,2,opt,name=market,proto3" json:"market,omitempty"`
	// User wallet address
	Wallet string `protobuf:"bytes,3,opt,name=wallet,proto3" json:"wallet,omitempty"`
	// Cancellation request timestamp (Unix milliseconds)
	RequestedAt int64 `protobuf:"varint,4,opt,name=requested_at,json=requestedAt,proto3" json:"requested_at,omitempty"`
	// Cancellation reason
	Reason        string `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CancelRequestMessage) Reset() {
	*x = CancelRequestMessage{}
	mi := &file_common_kafka_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CancelRequestMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CancelRequestMessage) ProtoMessage() {}

func (x *CancelRequestMessage) ProtoReflect() protoreflect.Message {
	mi := &file_common_kafka_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CancelRequestMessage.ProtoReflect.Descriptor instead.
func (*CancelRequestMessage) Descriptor() ([]byte, []int) {
	return file_common_kafka_proto_rawDescGZIP(), []int{1}
}

func (x *CancelRequestMessage) GetOrderId() string {
	if x != nil {
		return x.OrderId
	}
	return ""
}

func (x *CancelRequestMessage) GetMarket() string {
	if x != nil {
		return x.Market
	}
	return ""
}

func (x *CancelRequestMessage) GetWallet() string {
	if x != nil {
		return x.Wallet
	}
	return ""
}

func (x *CancelRequestMessage) GetRequestedAt() int64 {
	if x != nil {
		return x.RequestedAt
	}
	return 0
}

func (x *CancelRequestMessage) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

// BatchCancelRequestMessage represents a request to cancel multiple orders
type BatchCancelRequestMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Trading pair symbol (optional, cancel all markets if empty)
	Market string `protobuf:"bytes,1,opt,name=market,proto3" json:"market,omitempty"`
	// User wallet address
	Wallet string `protobuf:"bytes,2,opt,name=wallet,proto3" json:"wallet,omitempty"`
	// Specific order IDs to cancel (empty = cancel all)
	OrderIds []string `protobuf:"bytes,3,rep,name=order_ids,json=orderIds,proto3" json:"order_ids,omitempty"`
	// Order side filter (optional)
	Side OrderSide `protobuf:"varint,4,opt,name=side,proto3,enum=eidos.common.v1.OrderSide" json:"side,omitempty"`
	// Cancellation request timestamp (Unix milliseconds)
	RequestedAt   int64 `protobuf:"varint,5,opt,name=requested_at,json=requestedAt,proto3" json:"requested_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchCancelRequestMessage) Reset() {
	*x = BatchCancelRequestMessage{}
	mi := &file_common_kafka_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchCancelRequestMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchCancelRequestMessage) ProtoMessage() {}

func (x *BatchCancelRequestMessage) ProtoReflect() protoreflect.Message {
	mi := &file_common_kafka_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchCancelRequestMessage.ProtoReflect.Descriptor instead.
func (*BatchCancelRequestMessage) Descriptor() ([]byte, []int) {
	return file_common_kafka_proto_rawDescGZIP(), []int{2}
}

func (x *BatchCancelRequestMessage) GetMarket() string {
	if x != nil {
		return x.Market
	}
	return ""
}

func (x *BatchCancelRequestMessage) GetWallet() string {
	if x != nil {
		return x.Wallet
	}
	return ""
}

func (x *BatchCancelRequestMessage) GetOrderIds() []string {
	if x != nil {
		return x.OrderIds
	}
	return nil
}

func (x *BatchCancelRequestMessage) GetSide() OrderSide {
	if x != nil {
		return x.Side
	}
	return OrderSide_ORDER_SIDE_UNSPECIFIED
}

func (x *BatchCancelRequestMessage) GetRequestedAt() int64 {
	if x != nil {
		return x.RequestedAt
	}
	return 0
}

// TradeResultMessage represents a completed trade
type TradeResultMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique trade identifier
	TradeId string `protobuf:"bytes,1,opt,name=trade_id,json=tradeId,proto3" json:"trade_id,omitempty"`
	// Trading pair symbol
	Market string `protobuf:"bytes,2,opt,name=market,proto3" json:"market,omitempty"`
	// Maker order ID
	MakerOrderId string `protobuf:"bytes,3,opt,name=maker_order_id,json=makerOrderId,proto3" json:"maker_order_id,omitempty"`
	// Taker order ID
	TakerOrderId string `protobuf:"bytes,4,opt,name=taker_order_id,json=takerOrderId,proto3" json:"taker_order_id,omitempty"`
	// Maker wallet address
	MakerWallet string `protobuf:"bytes,5,opt,name=maker_wallet,json=makerWallet,proto3" json:"maker_wallet,omitempty"`
	// Taker wallet address
	TakerWallet string `protobuf:"bytes,6,opt,name=taker_wallet,json=takerWallet,proto3" json:"taker_wallet,omitempty"`
	// Taker order side (indicates market direction)
	TakerSide OrderSide `protobuf:"varint,7,opt,name=taker_side,json=takerSide,proto3,enum=eidos.common.v1.OrderSide" json:"taker_side,omitempty"`
	// Trade execution price (decimal string)
	Price string `protobuf:"bytes,8,opt,name=price,proto3" json:"price,omitempty"`
	// Trade amount in base token (decimal string)
	Amount string `protobuf:"bytes,9,opt,name=amount,proto3" json:"amount,omitempty"`
	// Trade amount in quote token (decimal string)
	QuoteAmount string `protobuf:"bytes,10,opt,name=quote_amount,json=quoteAmount,proto3" json:"quote_amount,omitempty"`
	// Maker fee amount (decimal string)
	MakerFee string `protobuf:"bytes,11,opt,name=maker_fee,json=makerFee,proto3" json:"maker_fee,omitempty"`
	// Taker fee amount (decimal string)
	TakerFee string `protobuf:"bytes,12,opt,name=taker_fee,json=takerFee,proto3" json:"taker_fee,omitempty"`
	// Fee token symbol
	FeeToken string `protobuf:"bytes,13,opt,name=fee_token,json=feeToken,proto3" json:"fee_token,omitempty"`
	// Whether maker order is fully filled
	MakerFilled bool `protobuf:"varint,14,opt,name=maker_filled,json=makerFilled,proto3" json:"maker_filled,omitempty"`
	// Whether taker order is fully filled
	TakerFilled bool `protobuf:"varint,15,opt,name=taker_filled,json=takerFilled,proto3" json:"taker_filled,omitempty"`
	// Maker order remaining amount (decimal string)
	MakerRemaining string `protobuf:"bytes,16,opt,name=maker_remaining,json=makerRemaining,proto3" json:"maker_remaining,omitempty"`
	// Taker order remaining amount (decimal string)
	TakerRemaining string `protobuf:"bytes,17,opt,name=taker_remaining,json=takerRemaining,proto3" json:"taker_remaining,omitempty"`
	// Trade execution timestamp (Unix milliseconds)
	MatchedAt int64 `protobuf:"varint,18,opt,name=matched_at,json=matchedAt,proto3" json:"matched_at,omitempty"`
	// Matching engine sequence number
	Sequence      uint64 `protobuf:"varint,19,opt,name=sequence,proto3" json:"sequence,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TradeResultMessage) Reset() {
	*x = TradeResultMessage{}
	mi := &file_common_kafka_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TradeResultMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TradeResultMessage) ProtoMessage() {}

func (x *TradeResultMessage) ProtoReflect() protoreflect.Message {
	mi := &file_common_kafka_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TradeResultMessage.ProtoReflect.Descriptor instead.
func (*TradeResultMessage) Descriptor() ([]byte, []int) {
	return file_common_kafka_proto_rawDescGZIP(), []int{3}
}

func (x *TradeResultMessage) GetTradeId() string {
	if x != nil {
		return x.TradeId
	}
	return ""
}

func (x *TradeResultMessage) GetMarket() string {
	if x != nil {
		return x.Market
	}
	return ""
}

func (x *TradeResultMessage) GetMakerOrderId() string {
	if x != nil {
		return x.MakerOrderId
	}
	return ""
}

func (x *TradeResultMessage) GetTakerOrderId() string {
	if x != nil {
		return x.TakerOrderId
	}
	return ""
}

func (x *TradeResultMessage) GetMakerWallet() string {
	if x != nil {
		return x.MakerWallet
	}
	return ""
}

func (x *TradeResultMessage) GetTakerWallet() string {
	if x != nil {
		return x.TakerWallet
	}
	return ""
}

func (x *TradeResultMessage) GetTakerSide() OrderSide {
	if x != nil {
		return x.TakerSide
	}
	return OrderSide_ORDER_SIDE_UNSPECIFIED
}

func (x *TradeResultMessage) GetPrice() string {
	if x != nil {
		return x.Price
	}
	return ""
}

func (x *TradeResultMessage) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *TradeResultMessage) GetQuoteAmount() string {
	if x != nil {
		return x.QuoteAmount
	}
	return ""
}

func (x *TradeResultMessage) GetMakerFee() string {
	if x != nil {
		return x.MakerFee
	}
	return ""
}

func (x *TradeResultMessage) GetTakerFee() string {
	if x != nil {
		return x.TakerFee
	}
	return ""
}

func (x *TradeResultMessage) GetFeeToken() string {
	if x != nil {
		return x.FeeToken
	}
	return ""
}

func (x *TradeResultMessage) GetMakerFilled() bool {
	if x != nil {
		return x.MakerFilled
	}
	return false
}

func (x *TradeResultMessage) GetTakerFilled() bool {
	if x != nil {
		return x.TakerFilled
	}
	return false
}

func (x *TradeResultMessage) GetMakerRemaining() string {
	if x != nil {
		return x.MakerRemaining
	}
	return ""
}

func (x *TradeResultMessage) GetTakerRemaining() string {
	if x != nil {
		return x.TakerRemaining
	}
	return ""
}

func (x *TradeResultMessage) GetMatchedAt() int64 {
	if x != nil {
		return x.MatchedAt
	}
	return 0
}

func (x *TradeResultMessage) GetSequence() uint64 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

// OrderUpdateMessage represents an order status change
type OrderUpdateMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Order ID
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// User wallet address
	Wallet string `protobuf:"bytes,2,opt,name=wallet,proto3" json:"wallet,omitempty"`
	// Trading pair symbol
	Market string `protobuf:"bytes,3,opt,name=market,proto3" json:"market,omitempty"`
	// New order status
	Status OrderStatus `protobuf:"varint,4,opt,name=status,proto3,enum=eidos.common.v1.OrderStatus" json:"status,omitempty"`
	// Previous order status
	PreviousStatus OrderStatus `protobuf:"varint,5,opt,name=previous_status,json=previousStatus,proto3,enum=eidos.common.v1.OrderStatus" json:"previous_status,omitempty"`
	// Filled amount (decimal string)
	FilledAmount string `protobuf:"bytes,6,opt,name=filled_amount,json=filledAmount,proto3" json:"filled_amount,omitempty"`
	// Filled quote amount (decimal string)
	FilledQuote string `protobuf:"bytes,7,opt,name=filled_quote,json=filledQuote,proto3" json:"filled_quote,omitempty"`
	// Remaining amount (decimal string)
	RemainingAmount string `protobuf:"bytes,8,opt,name=remaining_amount,json=remainingAmount,proto3" json:"remaining_amount,omitempty"`
	// Average fill price (decimal string)
	AvgPrice string `protobuf:"bytes,9,opt,name=avg_price,json=avgPrice,proto3" json:"avg_price,omitempty"`
	// Update reason
	Reason string `protobuf:"bytes,10,opt,name=reason,proto3" json:"reason,omitempty"`
	// Related trade ID (if status change due to trade)
	TradeId string `protobuf:"bytes,11,opt,name=trade_id,json=tradeId,proto3" json:"trade_id,omitempty"`
	// Update timestamp (Unix milliseconds)
	UpdatedAt     int64 `protobuf:"varint,12,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OrderUpdateMessage) Reset() {
	*x = OrderUpdateMessage{}
	mi := &file_common_kafka_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OrderUpdateMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OrderUpdateMessage) ProtoMessage() {}

func (x *OrderUpdateMessage) ProtoReflect() protoreflect.Message {
	mi := &file_common_kafka_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OrderUpdateMessage.ProtoReflect.Descriptor instead.
func (*OrderUpdateMessage) Descriptor() ([]byte, []int) {
	return file_common_kafka_proto_rawDescGZIP(), []int{4}
}

func (x *OrderUpdateMessage) GetOrderId() string {
	if x != nil {
		return x.OrderId
	}
	return ""
}

func (x *OrderUpdateMessage) GetWallet() string {
	if x != nil {
		return x.Wallet
	}
	return ""
}

func (x *OrderUpdateMessage) GetMarket() string {
	if x != nil {
		return x.Market
	}
	return ""
}

func (x *OrderUpdateMessage) GetStatus() OrderStatus {
	if x != nil {
		return x.Status
	}
	return OrderStatus_ORDER_STATUS_UNSPECIFIED
}

func (x *OrderUpdateMessage) GetPreviousStatus() OrderStatus {
	if x != nil {
		return x.PreviousStatus
	}
	return OrderStatus_ORDER_STATUS_UNSPECIFIED
}

func (x *OrderUpdateMessage) GetFilledAmount() string {
	if x != nil {
		return x.FilledAmount
	}
	return ""
}

func (x *OrderUpdateMessage) GetFilledQuote() string {
	if x != nil {
		return x.FilledQuote
	}
	return ""
}

func (x *OrderUpdateMessage) GetRemainingAmount() string {
	if x != nil {
		return x.RemainingAmount
	}
	return ""
}

func (x *OrderUpdateMessage) GetAvgPrice() string {
	if x != nil {
		return x.AvgPrice
	}
	return ""
}

func (x *OrderUpdateMessage) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

func (x *OrderUpdateMessage) GetTradeId() string {
	if x != nil {
		return x.TradeId
	}
	return ""
}

func (x *OrderUpdateMessage) GetUpdatedAt() int64 {
	if x != nil {
		return x.UpdatedAt
	}
	return 0
}

// OrderCancelledMessage confirms an order was cancelled
type OrderCancelledMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Order ID
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// Trading pair symbol
	Market string `protobuf:"bytes,2,opt,name=market,proto3" json:"market,omitempty"`
	// User wallet address
	Wallet string `protobuf:"bytes,3,opt,name=wallet,proto3" json:"wallet,omitempty"`
	// Remaining amount at cancellation (decimal string)
	RemainingAmount string `protobuf:"bytes,4,opt,name=remaining_amount,json=remainingAmount,proto3" json:"remaining_amount,omitempty"`
	// Cancellation reason
	Reason string `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason,omitempty"`
	// Cancellation timestamp (Unix milliseconds)
	CancelledAt   int64 `protobuf:"varint,6,opt,name=cancelled_at,json=cancelledAt,proto3" json:"cancelled_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OrderCancelledMessage) Reset() {
	*x = OrderCancelledMessage{}
	mi := &file_common_kafka_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OrderCancelledMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OrderCancelledMessage) ProtoMessage() {}

func (x *OrderCancelledMessage) ProtoReflect() protoreflect.Message {
	mi := &file_common_kafka_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OrderCancelledMessage.ProtoReflect.Descriptor instead.
func (*OrderCancelledMessage) Descriptor() ([]byte, []int) {
	return file_common_kafka_proto_rawDescGZIP(), []int{5}
}

func (x *OrderCancelledMessage) GetOrderId() string {
	if x != nil {
		return x.OrderId
	}
	return ""
}

func (x *OrderCancelledMessage) GetMarket() string {
	if x != nil {
		return x.Market
	}
	return ""
}

func (x *OrderCancelledMessage) GetWallet() string {
	if x != nil {
		return x.Wallet
	}
	return ""
}

func (x *OrderCancelledMessage) GetRemainingAmount() string {
	if x != nil {
		return x.RemainingAmount
	}
	return ""
}

func (x *OrderCancelledMessage) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

func (x *OrderCancelledMessage) GetCancelledAt() int64 {
	if x != nil {
		return x.CancelledAt
	}
	return 0
}

// OrderbookUpdateMessage represents orderbook changes
type OrderbookUpdateMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Trading pair symbol
	Market string `protobuf:"bytes,1,opt,name=market,proto3" json:"market,omitempty"`
	// Sequence number for ordering updates
	Sequence uint64 `protobuf:"varint,2,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// Bid side updates
	Bids []*PriceLevelUpdate `protobuf:"bytes,3,rep,name=bids,proto3" json:"bids,omitempty"`
	// Ask side updates
	Asks []*PriceLevelUpdate `protobuf:"bytes,4,rep,name=asks,proto3" json:"asks,omitempty"`
	// Update timestamp (Unix milliseconds)
	Timestamp     int64 `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OrderbookUpdateMessage) Reset() {
	*x = OrderbookUpdateMessage{}
	mi := &file_common_kafka_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OrderbookUpdateMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OrderbookUpdateMessage) ProtoMessage() {}

func (x *OrderbookUpdateMessage) ProtoReflect() protoreflect.Message {
	mi := &file_common_kafka_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OrderbookUpdateMessage.ProtoReflect.Descriptor instead.
func (*OrderbookUpdateMessage) Descriptor() ([]byte, []int) {
	return file_common_kafka_proto_rawDescGZIP(), []int{6}
}

func (x *OrderbookUpdateMessage) GetMarket() string {
	if x != nil {
		return x.Market
	}
	return ""
}

func (x *OrderbookUpdateMessage) GetSequence() uint64 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

func (x *OrderbookUpdateMessage) GetBids() []*PriceLevelUpdate {
	if x != nil {
		return x.Bids
	}
	return nil
}

func (x *OrderbookUpdateMessage) GetAsks() []*PriceLevelUpdate {
	if x != nil {
		return x.Asks
	}
	return nil
}

func (x *OrderbookUpdateMessage) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// PriceLevelUpdate represents a change at a price level
type PriceLevelUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Price level (decimal string)
	Price string `protobuf:"bytes,1,opt,name=price,proto3" json:"price,omitempty"`
	// New total amount at price (decimal string, "0" means remove level)
	Amount string `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	// Number of orders at this price level
	OrderCount    int32 `protobuf:"varint,3,opt,name=order_count,json=orderCount,proto3" json:"order_count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PriceLevelUpdate) Reset() {
	*x = PriceLevelUpdate{}
	mi := &file_common_kafka_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PriceLevelUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PriceLevelUpdate) ProtoMessage() {}

func (x *PriceLevelUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_common_kafka_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PriceLevelUpdate.ProtoReflect.Descriptor instead.
func (*PriceLevelUpdate) Descriptor() ([]byte, []int) {
	return file_common_kafka_proto_rawDescGZIP(), []int{7}
}

func (x *PriceLevelUpdate) GetPrice() string {
	if x != nil {
		return x.Price
	}
	return ""
}

func (x *PriceLevelUpdate) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *PriceLevelUpdate) GetOrderCount() int32 {
	if x != nil {
		return x.OrderCount
	}
	return 0
}

// BalanceUpdateMessage represents a balance change
type BalanceUpdateMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// User wallet address
	Wallet string `protobuf:"bytes,1,opt,name=wallet,proto3" json:"wallet,omitempty"`
	// Token symbol
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	// Change type
	ChangeType BalanceChangeType `protobuf:"varint,3,opt,name=change_type,json=changeType,proto3,enum=eidos.common.v1.BalanceChangeType" json:"change_type,omitempty"`
	// Change amount (decimal string, can be negative)
	Amount string `protobuf:"bytes,4,opt,name=amount,proto3" json:"amount,omitempty"`
	// Balance before change (decimal string)
	BalanceBefore string `protobuf:"bytes,5,opt,name=balance_before,json=balanceBefore,proto3" json:"balance_before,omitempty"`
	// Balance after change (decimal string)
	BalanceAfter string `protobuf:"bytes,6,opt,name=balance_after,json=balanceAfter,proto3" json:"balance_after,omitempty"`
	// Available balance after change (decimal string)
	AvailableAfter string `protobuf:"bytes,7,opt,name=available_after,json=availableAfter,proto3" json:"available_after,omitempty"`
	// Frozen balance after change (decimal string)
	FrozenAfter string `protobuf:"bytes,8,opt,name=frozen_after,json=frozenAfter,proto3" json:"frozen_after,omitempty"`
	// Related order ID (optional)
	OrderId string `protobuf:"bytes,9,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// Related trade ID (optional)
	TradeId string `protobuf:"bytes,10,opt,name=trade_id,json=tradeId,proto3" json:"trade_id,omitempty"`
	// Related transaction hash (optional)
	TxHash string `protobuf:"bytes,11,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	// Change timestamp (Unix milliseconds)
	UpdatedAt     int64 `protobuf:"varint,12,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BalanceUpdateMessage) Reset() {
	*x = BalanceUpdateMessage{}
	mi := &file_common_kafka_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BalanceUpdateMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BalanceUpdateMessage) ProtoMessage() {}

func (x *BalanceUpdateMessage) ProtoReflect() protoreflect.Message {
	mi := &file_common_kafka_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BalanceUpdateMessage.ProtoReflect.Descriptor instead.
func (*BalanceUpdateMessage) Descriptor() ([]byte, []int) {
	return file_common_kafka_proto_rawDescGZIP(), []int{8}
}

func (x *BalanceUpdateMessage) GetWallet() string {
	if x != nil {
		return x.Wallet
	}
	return ""
}

func (x *BalanceUpdateMessage) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

func (x *BalanceUpdateMessage) GetChangeType() BalanceChangeType {
	if x != nil {
		return x.ChangeType
	}
	return BalanceChangeType_BALANCE_CHANGE_TYPE_UNSPECIFIED
}

func (x *BalanceUpdateMessage) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *BalanceUpdateMessage) GetBalanceBefore() string {
	if x != nil {
		return x.BalanceBefore
	}
	return ""
}

func (x *BalanceUpdateMessage) GetBalanceAfter() string {
	if x != nil {
		return x.BalanceAfter
	}
	return ""
}

func (x *BalanceUpdateMessage) GetAvailableAfter() string {
	if x != nil {
		return x.AvailableAfter
	}
	return ""
}

func (x *BalanceUpdateMessage) GetFrozenAfter() string {
	if x != nil {
		return x.FrozenAfter
	}
	return ""
}

func (x *BalanceUpdateMessage) GetOrderId() string {
	if x != nil {
		return x.OrderId
	}
	return ""
}

func (x *BalanceUpdateMessage) GetTradeId() string {
	if x != nil {
		return x.TradeId
	}
	return ""
}

func (x *BalanceUpdateMessage) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *BalanceUpdateMessage) GetUpdatedAt() int64 {
	if x != nil {
		return x.UpdatedAt
	}
	return 0
}

// DepositMessage represents a detected deposit event
type DepositMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique deposit identifier
	DepositId string `protobuf:"bytes,1,opt,name=deposit_id,json=depositId,proto3" json:"deposit_id,omitempty"`
	// On-chain transaction hash
	TxHash string `protobuf:"bytes,2,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	// Log index within transaction
	LogIndex uint32 `protobuf:"varint,3,opt,name=log_index,json=logIndex,proto3" json:"log_index,omitempty"`
	// User wallet address
	Wallet string `protobuf:"bytes,4,opt,name=wallet,proto3" json:"wallet,omitempty"`
	// Token symbol
	Token string `protobuf:"bytes,5,opt,name=token,proto3" json:"token,omitempty"`
	// Token contract address
	TokenAddress string `protobuf:"bytes,6,opt,name=token_address,json=tokenAddress,proto3" json:"token_address,omitempty"`
	// Deposit amount (decimal string)
	Amount string `protobuf:"bytes,7,opt,name=amount,proto3" json:"amount,omitempty"`
	// Block number where deposit was detected
	BlockNumber int64 `protobuf:"varint,8,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	// Chain ID
	ChainId int64 `protobuf:"varint,9,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Current confirmations
	Confirmations int32 `protobuf:"varint,10,opt,name=confirmations,proto3" json:"confirmations,omitempty"`
	// Required confirmations for crediting
	RequiredConfirmations int32 `protobuf:"varint,11,opt,name=required_confirmations,json=requiredConfirmations,proto3" json:"required_confirmations,omitempty"`
	// Detection timestamp (Unix milliseconds)
	DetectedAt    int64 `protobuf:"varint,12,opt,name=detected_at,json=detectedAt,proto3" json:"detected_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DepositMessage) Reset() {
	*x = DepositMessage{}
	mi := &file_common_kafka_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DepositMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DepositMessage) ProtoMessage() {}

func (x *DepositMessage) ProtoReflect() protoreflect.Message {
	mi := &file_common_kafka_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DepositMessage.ProtoReflect.Descriptor instead.
func (*DepositMessage) Descriptor() ([]byte, []int) {
	return file_common_kafka_proto_rawDescGZIP(), []int{9}
}

func (x *DepositMessage) GetDepositId() string {
	if x != nil {
		return x.DepositId
	}
	return ""
}

func (x *DepositMessage) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *DepositMessage) GetLogIndex() uint32 {
	if x != nil {
		return x.LogIndex
	}
	return 0
}

func (x *DepositMessage) GetWallet() string {
	if x != nil {
		return x.Wallet
	}
	return ""
}

func (x *DepositMessage) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

func (x *DepositMessage) GetTokenAddress() string {
	if x != nil {
		return x.TokenAddress
	}
	return ""
}

func (x *DepositMessage) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *DepositMessage) GetBlockNumber() int64 {
	if x != nil {
		return x.BlockNumber
	}
	return 0
}

func (x *DepositMessage) GetChainId() int64 {
	if x != nil {
		return x.ChainId
	}
	return 0
}

func (x *DepositMessage) GetConfirmations() int32 {
	if x != nil {
		return x.Confirmations
	}
	return 0
}

func (x *DepositMessage) GetRequiredConfirmations() int32 {
	if x != nil {
		return x.RequiredConfirmations
	}
	return 0
}

func (x *DepositMessage) GetDetectedAt() int64 {
	if x != nil {
		return x.DetectedAt
	}
	return 0
}

// DepositConfirmedMessage represents a confirmed deposit
type DepositConfirmedMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Deposit identifier
	DepositId string `protobuf:"bytes,1,opt,name=deposit_id,json=depositId,proto3" json:"deposit_id,omitempty"`
	// User wallet address
	Wallet string `protobuf:"bytes,2,opt,name=wallet,proto3" json:"wallet,omitempty"`
	// Token symbol
	Token string `protobuf:"bytes,3,opt,name=token,proto3" json:"token,omitempty"`
	// Deposit amount (decimal string)
	Amount string `protobuf:"bytes,4,opt,name=amount,proto3" json:"amount,omitempty"`
	// Transaction hash
	TxHash string `protobuf:"bytes,5,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	// Confirmation timestamp (Unix milliseconds)
	ConfirmedAt   int64 `protobuf:"varint,6,opt,name=confirmed_at,json=confirmedAt,proto3" json:"confirmed_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DepositConfirmedMessage) Reset() {
	*x = DepositConfirmedMessage{}
	mi := &file_common_kafka_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DepositConfirmedMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DepositConfirmedMessage) ProtoMessage() {}

func (x *DepositConfirmedMessage) ProtoReflect() protoreflect.Message {
	mi := &file_common_kafka_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DepositConfirmedMessage.ProtoReflect.Descriptor instead.
func (*DepositConfirmedMessage) Descriptor() ([]byte, []int) {
	return file_common_kafka_proto_rawDescGZIP(), []int{10}
}

func (x *DepositConfirmedMessage) GetDepositId() string {
	if x != nil {
		return x.DepositId
	}
	return ""
}

func (x *DepositConfirmedMessage) GetWallet() string {
	if x != nil {
		return x.Wallet
	}
	return ""
}

func (x *DepositConfirmedMessage) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

func (x *DepositConfirmedMessage) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *DepositConfirmedMessage) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *DepositConfirmedMessage) GetConfirmedAt() int64 {
	if x != nil {
		return x.ConfirmedAt
	}
	return 0
}

// WithdrawalRequestMessage represents a withdrawal to be processed
type WithdrawalRequestMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Withdrawal identifier
	WithdrawId string `protobuf:"bytes,1,opt,name=withdraw_id,json=withdrawId,proto3" json:"withdraw_id,omitempty"`
	// User wallet address
	Wallet string `protobuf:"bytes,2,opt,name=wallet,proto3" json:"wallet,omitempty"`
	// Token symbol
	Token string `protobuf:"bytes,3,opt,name=token,proto3" json:"token,omitempty"`
	// Token contract address
	TokenAddress string `protobuf:"bytes,4,opt,name=token_address,json=tokenAddress,proto3" json:"token_address,omitempty"`
	// Withdrawal amount (decimal string)
	Amount string `protobuf:"bytes,5,opt,name=amount,proto3" json:"amount,omitempty"`
	// Destination address
	ToAddress string `protobuf:"bytes,6,opt,name=to_address,json=toAddress,proto3" json:"to_address,omitempty"`
	// User's nonce for the withdrawal
	Nonce uint64 `protobuf:"varint,7,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// User's signature
	Signature []byte `protobuf:"bytes,8,opt,name=signature,proto3" json:"signature,omitempty"`
	// Chain ID
	ChainId int64 `protobuf:"varint,9,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Priority level (0 = normal, 1 = high)
	Priority int32 `protobuf:"varint,10,opt,name=priority,proto3" json:"priority,omitempty"`
	// Request timestamp (Unix milliseconds)
	RequestedAt   int64 `protobuf:"varint,11,opt,name=requested_at,json=requestedAt,proto3" json:"requested_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WithdrawalRequestMessage) Reset() {
	*x = WithdrawalRequestMessage{}
	mi := &file_common_kafka_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WithdrawalRequestMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WithdrawalRequestMessage) ProtoMessage() {}

func (x *WithdrawalRequestMessage) ProtoReflect() protoreflect.Message {
	mi := &file_common_kafka_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WithdrawalRequestMessage.ProtoReflect.Descriptor instead.
func (*WithdrawalRequestMessage) Descriptor() ([]byte, []int) {
	return file_common_kafka_proto_rawDescGZIP(), []int{11}
}

func (x *WithdrawalRequestMessage) GetWithdrawId() string {
	if x != nil {
		return x.WithdrawId
	}
	return ""
}

func (x *WithdrawalRequestMessage) GetWallet() string {
	if x != nil {
		return x.Wallet
	}
	return ""
}

func (x *WithdrawalRequestMessage) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

func (x *WithdrawalRequestMessage) GetTokenAddress() string {
	if x != nil {
		return x.TokenAddress
	}
	return ""
}

func (x *WithdrawalRequestMessage) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *WithdrawalRequestMessage) GetToAddress() string {
	if x != nil {
		return x.ToAddress
	}
	return ""
}

func (x *WithdrawalRequestMessage) GetNonce() uint64 {
	if x != nil {
		return x.Nonce
	}
	return 0
}

func (x *WithdrawalRequestMessage) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *WithdrawalRequestMessage) GetChainId() int64 {
	if x != nil {
		return x.ChainId
	}
	return 0
}

func (x *WithdrawalRequestMessage) GetPriority() int32 {
	if x != nil {
		return x.Priority
	}
	return 0
}

func (x *WithdrawalRequestMessage) GetRequestedAt() int64 {
	if x != nil {
		return x.RequestedAt
	}
	return 0
}

// WithdrawalStatusMessage represents withdrawal status update
type WithdrawalStatusMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Withdrawal identifier
	WithdrawId string `protobuf:"bytes,1,opt,name=withdraw_id,json=withdrawId,proto3" json:"withdraw_id,omitempty"`
	// User wallet address
	Wallet string `protobuf:"bytes,2,opt,name=wallet,proto3" json:"wallet,omitempty"`
	// New status
	Status WithdrawStatus `protobuf:"varint,3,opt,name=status,proto3,enum=eidos.common.v1.WithdrawStatus" json:"status,omitempty"`
	// Transaction hash (if submitted)
	TxHash string `protobuf:"bytes,4,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	// Block number (if confirmed)
	BlockNumber int64 `protobuf:"varint,5,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	// Error message (if failed)
	ErrorMessage string `protobuf:"bytes,6,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Update timestamp (Unix milliseconds)
	UpdatedAt     int64 `protobuf:"varint,7,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WithdrawalStatusMessage) Reset() {
	*x = WithdrawalStatusMessage{}
	mi := &file_common_kafka_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WithdrawalStatusMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WithdrawalStatusMessage) ProtoMessage() {}

func (x *WithdrawalStatusMessage) ProtoReflect() protoreflect.Message {
	mi := &file_common_kafka_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WithdrawalStatusMessage.ProtoReflect.Descriptor instead.
func (*WithdrawalStatusMessage) Descriptor() ([]byte, []int) {
	return file_common_kafka_proto_rawDescGZIP(), []int{12}
}

func (x *WithdrawalStatusMessage) GetWithdrawId() string {
	if x != nil {
		return x.WithdrawId
	}
	return ""
}

func (x *WithdrawalStatusMessage) GetWallet() string {
	if x != nil {
		return x.Wallet
	}
	return ""
}

func (x *WithdrawalStatusMessage) GetStatus() WithdrawStatus {
	if x != nil {
		return x.Status
	}
	return WithdrawStatus_WITHDRAW_STATUS_UNSPECIFIED
}

func (x *WithdrawalStatusMessage) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *WithdrawalStatusMessage) GetBlockNumber() int64 {
	if x != nil {
		return x.BlockNumber
	}
	return 0
}

func (x *WithdrawalStatusMessage) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *WithdrawalStatusMessage) GetUpdatedAt() int64 {
	if x != nil {
		return x.UpdatedAt
	}
	return 0
}

// SettlementMessage represents a batch of trades to settle
type SettlementMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique batch identifier
	BatchId string `protobuf:"bytes,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// Trades in this batch
	Trades []*SettlementTrade `protobuf:"bytes,2,rep,name=trades,proto3" json:"trades,omitempty"`
	// Chain ID for settlement
	ChainId int64 `protobuf:"varint,3,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Priority level (0 = normal, 1 = high)
	Priority int32 `protobuf:"varint,4,opt,name=priority,proto3" json:"priority,omitempty"`
	// Batch creation timestamp (Unix milliseconds)
	CreatedAt     int64 `protobuf:"varint,5,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SettlementMessage) Reset() {
	*x = SettlementMessage{}
	mi := &file_common_kafka_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SettlementMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SettlementMessage) ProtoMessage() {}

func (x *SettlementMessage) ProtoReflect() protoreflect.Message {
	mi := &file_common_kafka_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SettlementMessage.ProtoReflect.Descriptor instead.
func (*SettlementMessage) Descriptor() ([]byte, []int) {
	return file_common_kafka_proto_rawDescGZIP(), []int{13}
}

func (x *SettlementMessage) GetBatchId() string {
	if x != nil {
		return x.BatchId
	}
	return ""
}

func (x *SettlementMessage) GetTrades() []*SettlementTrade {
	if x != nil {
		return x.Trades
	}
	return nil
}

func (x *SettlementMessage) GetChainId() int64 {
	if x != nil {
		return x.ChainId
	}
	return 0
}

func (x *SettlementMessage) GetPriority() int32 {
	if x != nil {
		return x.Priority
	}
	return 0
}

func (x *SettlementMessage) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

// SettlementTrade represents a single trade in settlement batch
type SettlementTrade struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Trade identifier
	TradeId string `protobuf:"bytes,1,opt,name=trade_id,json=tradeId,proto3" json:"trade_id,omitempty"`
	// Trading pair symbol
	Market string `protobuf:"bytes,2,opt,name=market,proto3" json:"market,omitempty"`
	// Maker wallet address
	MakerWallet string `protobuf:"bytes,3,opt,name=maker_wallet,json=makerWallet,proto3" json:"maker_wallet,omitempty"`
	// Taker wallet address
	TakerWallet string `protobuf:"bytes,4,opt,name=taker_wallet,json=takerWallet,proto3" json:"taker_wallet,omitempty"`
	// Base token symbol
	BaseToken string `protobuf:"bytes,5,opt,name=base_token,json=baseToken,proto3" json:"base_token,omitempty"`
	// Quote token symbol
	QuoteToken string `protobuf:"bytes,6,opt,name=quote_token,json=quoteToken,proto3" json:"quote_token,omitempty"`
	// Base token contract address
	BaseTokenAddress string `protobuf:"bytes,7,opt,name=base_token_address,json=baseTokenAddress,proto3" json:"base_token_address,omitempty"`
	// Quote token contract address
	QuoteTokenAddress string `protobuf:"bytes,8,opt,name=quote_token_address,json=quoteTokenAddress,proto3" json:"quote_token_address,omitempty"`
	// Trade price (decimal string)
	Price string `protobuf:"bytes,9,opt,name=price,proto3" json:"price,omitempty"`
	// Base amount (decimal string)
	BaseAmount string `protobuf:"bytes,10,opt,name=base_amount,json=baseAmount,proto3" json:"base_amount,omitempty"`
	// Quote amount (decimal string)
	QuoteAmount string `protobuf:"bytes,11,opt,name=quote_amount,json=quoteAmount,proto3" json:"quote_amount,omitempty"`
	// Taker side (buy = taker buys base, sell = taker sells base)
	TakerSide OrderSide `protobuf:"varint,12,opt,name=taker_side,json=takerSide,proto3,enum=eidos.common.v1.OrderSide" json:"taker_side,omitempty"`
	// Maker fee (decimal string)
	MakerFee string `protobuf:"bytes,13,opt,name=maker_fee,json=makerFee,proto3" json:"maker_fee,omitempty"`
	// Taker fee (decimal string)
	TakerFee string `protobuf:"bytes,14,opt,name=taker_fee,json=takerFee,proto3" json:"taker_fee,omitempty"`
	// Trade timestamp (Unix milliseconds)
	MatchedAt     int64 `protobuf:"varint,15,opt,name=matched_at,json=matchedAt,proto3" json:"matched_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SettlementTrade) Reset() {
	*x = SettlementTrade{}
	mi := &file_common_kafka_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SettlementTrade) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SettlementTrade) ProtoMessage() {}

func (x *SettlementTrade) ProtoReflect() protoreflect.Message {
	mi := &file_common_kafka_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SettlementTrade.ProtoReflect.Descriptor instead.
func (*SettlementTrade) Descriptor() ([]byte, []int) {
	return file_common_kafka_proto_rawDescGZIP(), []int{14}
}

func (x *SettlementTrade) GetTradeId() string {
	if x != nil {
		return x.TradeId
	}
	return ""
}

func (x *SettlementTrade) GetMarket() string {
	if x != nil {
		return x.Market
	}
	return ""
}

func (x *SettlementTrade) GetMakerWallet() string {
	if x != nil {
		return x.MakerWallet
	}
	return ""
}

func (x *SettlementTrade) GetTakerWallet() string {
	if x != nil {
		return x.TakerWallet
	}
	return ""
}

func (x *SettlementTrade) GetBaseToken() string {
	if x != nil {
		return x.BaseToken
	}
	return ""
}

func (x *SettlementTrade) GetQuoteToken() string {
	if x != nil {
		return x.QuoteToken
	}
	return ""
}

func (x *SettlementTrade) GetBaseTokenAddress() string {
	if x != nil {
		return x.BaseTokenAddress
	}
	return ""
}

func (x *SettlementTrade) GetQuoteTokenAddress() string {
	if x != nil {
		return x.QuoteTokenAddress
	}
	return ""
}

func (x *SettlementTrade) GetPrice() string {
	if x != nil {
		return x.Price
	}
	return ""
}

func (x *SettlementTrade) GetBaseAmount() string {
	if x != nil {
		return x.BaseAmount
	}
	return ""
}

func (x *SettlementTrade) GetQuoteAmount() string {
	if x != nil {
		return x.QuoteAmount
	}
	return ""
}

func (x *SettlementTrade) GetTakerSide() OrderSide {
	if x != nil {
		return x.TakerSide
	}
	return OrderSide_ORDER_SIDE_UNSPECIFIED
}

func (x *SettlementTrade) GetMakerFee() string {
	if x != nil {
		return x.MakerFee
	}
	return ""
}

func (x *SettlementTrade) GetTakerFee() string {
	if x != nil {
		return x.TakerFee
	}
	return ""
}

func (x *SettlementTrade) GetMatchedAt() int64 {
	if x != nil {
		return x.MatchedAt
	}
	return 0
}

// SettlementConfirmedMessage confirms trades settled on-chain
type SettlementConfirmedMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Batch identifier
	BatchId string `protobuf:"bytes,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// Transaction hash
	TxHash string `protobuf:"bytes,2,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	// Block number
	BlockNumber int64 `protobuf:"varint,3,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	// Trade IDs in the batch
	TradeIds []string `protobuf:"bytes,4,rep,name=trade_ids,json=tradeIds,proto3" json:"trade_ids,omitempty"`
	// Gas used
	GasUsed int64 `protobuf:"varint,5,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
	// Gas price (wei string)
	GasPrice string `protobuf:"bytes,6,opt,name=gas_price,json=gasPrice,proto3" json:"gas_price,omitempty"`
	// Confirmation timestamp (Unix milliseconds)
	ConfirmedAt   int64 `protobuf:"varint,7,opt,name=confirmed_at,json=confirmedAt,proto3" json:"confirmed_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SettlementConfirmedMessage) Reset() {
	*x = SettlementConfirmedMessage{}
	mi := &file_common_kafka_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SettlementConfirmedMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SettlementConfirmedMessage) ProtoMessage() {}

func (x *SettlementConfirmedMessage) ProtoReflect() protoreflect.Message {
	mi := &file_common_kafka_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SettlementConfirmedMessage.ProtoReflect.Descriptor instead.
func (*SettlementConfirmedMessage) Descriptor() ([]byte, []int) {
	return file_common_kafka_proto_rawDescGZIP(), []int{15}
}

func (x *SettlementConfirmedMessage) GetBatchId() string {
	if x != nil {
		return x.BatchId
	}
	return ""
}

func (x *SettlementConfirmedMessage) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *SettlementConfirmedMessage) GetBlockNumber() int64 {
	if x != nil {
		return x.BlockNumber
	}
	return 0
}

func (x *SettlementConfirmedMessage) GetTradeIds() []string {
	if x != nil {
		return x.TradeIds
	}
	return nil
}

func (x *SettlementConfirmedMessage) GetGasUsed() int64 {
	if x != nil {
		return x.GasUsed
	}
	return 0
}

func (x *SettlementConfirmedMessage) GetGasPrice() string {
	if x != nil {
		return x.GasPrice
	}
	return ""
}

func (x *SettlementConfirmedMessage) GetConfirmedAt() int64 {
	if x != nil {
		return x.ConfirmedAt
	}
	return 0
}

// SettlementFailedMessage indicates settlement failure
type SettlementFailedMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Batch identifier
	BatchId string `protobuf:"bytes,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// Trade IDs in the batch
	TradeIds []string `protobuf:"bytes,2,rep,name=trade_ids,json=tradeIds,proto3" json:"trade_ids,omitempty"`
	// Error message
	ErrorMessage string `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Failure reason code
	ErrorCode string `protobuf:"bytes,4,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	// Whether to retry
	ShouldRetry bool `protobuf:"varint,5,opt,name=should_retry,json=shouldRetry,proto3" json:"should_retry,omitempty"`
	// Suggested retry delay (seconds)
	RetryDelaySeconds int32 `protobuf:"varint,6,opt,name=retry_delay_seconds,json=retryDelaySeconds,proto3" json:"retry_delay_seconds,omitempty"`
	// Failure timestamp (Unix milliseconds)
	FailedAt      int64 `protobuf:"varint,7,opt,name=failed_at,json=failedAt,proto3" json:"failed_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SettlementFailedMessage) Reset() {
	*x = SettlementFailedMessage{}
	mi := &file_common_kafka_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SettlementFailedMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SettlementFailedMessage) ProtoMessage() {}

func (x *SettlementFailedMessage) ProtoReflect() protoreflect.Message {
	mi := &file_common_kafka_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SettlementFailedMessage.ProtoReflect.Descriptor instead.
func (*SettlementFailedMessage) Descriptor() ([]byte, []int) {
	return file_common_kafka_proto_rawDescGZIP(), []int{16}
}

func (x *SettlementFailedMessage) GetBatchId() string {
	if x != nil {
		return x.BatchId
	}
	return ""
}

func (x *SettlementFailedMessage) GetTradeIds() []string {
	if x != nil {
		return x.TradeIds
	}
	return nil
}

func (x *SettlementFailedMessage) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *SettlementFailedMessage) GetErrorCode() string {
	if x != nil {
		return x.ErrorCode
	}
	return ""
}

func (x *SettlementFailedMessage) GetShouldRetry() bool {
	if x != nil {
		return x.ShouldRetry
	}
	return false
}

func (x *SettlementFailedMessage) GetRetryDelaySeconds() int32 {
	if x != nil {
		return x.RetryDelaySeconds
	}
	return 0
}

func (x *SettlementFailedMessage) GetFailedAt() int64 {
	if x != nil {
		return x.FailedAt
	}
	return 0
}

// RiskAlertMessage represents a risk management alert
type RiskAlertMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique alert identifier
	AlertId string `protobuf:"bytes,1,opt,name=alert_id,json=alertId,proto3" json:"alert_id,omitempty"`
	// User wallet address (optional, may be system-wide alert)
	Wallet string `protobuf:"bytes,2,opt,name=wallet,proto3" json:"wallet,omitempty"`
	// Alert type
	AlertType RiskEventType `protobuf:"varint,3,opt,name=alert_type,json=alertType,proto3,enum=eidos.common.v1.RiskEventType" json:"alert_type,omitempty"`
	// Risk level/severity
	Severity RiskLevel `protobuf:"varint,4,opt,name=severity,proto3,enum=eidos.common.v1.RiskLevel" json:"severity,omitempty"`
	// Risk rule ID that triggered alert
	RuleId string `protobuf:"bytes,5,opt,name=rule_id,json=ruleId,proto3" json:"rule_id,omitempty"`
	// Alert description
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	// Action taken
	ActionTaken RiskAction `protobuf:"varint,7,opt,name=action_taken,json=actionTaken,proto3,enum=eidos.common.v1.RiskAction" json:"action_taken,omitempty"`
	// Additional context
	Context map[string]string `protobuf:"bytes,8,rep,name=context,proto3" json:"context,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Related order ID (optional)
	OrderId string `protobuf:"bytes,9,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// Related withdrawal ID (optional)
	WithdrawId string `protobuf:"bytes,10,opt,name=withdraw_id,json=withdrawId,proto3" json:"withdraw_id,omitempty"`
	// Alert timestamp (Unix milliseconds)
	CreatedAt     int64 `protobuf:"varint,11,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RiskAlertMessage) Reset() {
	*x = RiskAlertMessage{}
	mi := &file_common_kafka_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RiskAlertMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RiskAlertMessage) ProtoMessage() {}

func (x *RiskAlertMessage) ProtoReflect() protoreflect.Message {
	mi := &file_common_kafka_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RiskAlertMessage.ProtoReflect.Descriptor instead.
func (*RiskAlertMessage) Descriptor() ([]byte, []int) {
	return file_common_kafka_proto_rawDescGZIP(), []int{17}
}

func (x *RiskAlertMessage) GetAlertId() string {
	if x != nil {
		return x.AlertId
	}
	return ""
}

func (x *RiskAlertMessage) GetWallet() string {
	if x != nil {
		return x.Wallet
	}
	return ""
}

func (x *RiskAlertMessage) GetAlertType() RiskEventType {
	if x != nil {
		return x.AlertType
	}
	return RiskEventType_RISK_EVENT_TYPE_UNSPECIFIED
}

func (x *RiskAlertMessage) GetSeverity() RiskLevel {
	if x != nil {
		return x.Severity
	}
	return RiskLevel_RISK_LEVEL_UNSPECIFIED
}

func (x *RiskAlertMessage) GetRuleId() string {
	if x != nil {
		return x.RuleId
	}
	return ""
}

func (x *RiskAlertMessage) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *RiskAlertMessage) GetActionTaken() RiskAction {
	if x != nil {
		return x.ActionTaken
	}
	return RiskAction_RISK_ACTION_UNSPECIFIED
}

func (x *RiskAlertMessage) GetContext() map[string]string {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *RiskAlertMessage) GetOrderId() string {
	if x != nil {
		return x.OrderId
	}
	return ""
}

func (x *RiskAlertMessage) GetWithdrawId() string {
	if x != nil {
		return x.WithdrawId
	}
	return ""
}

func (x *RiskAlertMessage) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

// NotificationMessage represents a user notification
type NotificationMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique notification identifier
	NotificationId string `protobuf:"bytes,1,opt,name=notification_id,json=notificationId,proto3" json:"notification_id,omitempty"`
	// User wallet address
	Wallet string `protobuf:"bytes,2,opt,name=wallet,proto3" json:"wallet,omitempty"`
	// Notification type
	NotificationType NotificationType `protobuf:"varint,3,opt,name=notification_type,json=notificationType,proto3,enum=eidos.common.v1.NotificationType" json:"notification_type,omitempty"`
	// Notification title
	Title string `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty"`
	// Notification message body
	Message string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	// Additional data as JSON string
	Data string `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
	// Related entity ID (order_id, trade_id, etc.)
	EntityId string `protobuf:"bytes,7,opt,name=entity_id,json=entityId,proto3" json:"entity_id,omitempty"`
	// Channels to deliver (email, push, websocket)
	Channels []string `protobuf:"bytes,8,rep,name=channels,proto3" json:"channels,omitempty"`
	// Notification timestamp (Unix milliseconds)
	CreatedAt     int64 `protobuf:"varint,9,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NotificationMessage) Reset() {
	*x = NotificationMessage{}
	mi := &file_common_kafka_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NotificationMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NotificationMessage) ProtoMessage() {}

func (x *NotificationMessage) ProtoReflect() protoreflect.Message {
	mi := &file_common_kafka_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NotificationMessage.ProtoReflect.Descriptor instead.
func (*NotificationMessage) Descriptor() ([]byte, []int) {
	return file_common_kafka_proto_rawDescGZIP(), []int{18}
}

func (x *NotificationMessage) GetNotificationId() string {
	if x != nil {
		return x.NotificationId
	}
	return ""
}

func (x *NotificationMessage) GetWallet() string {
	if x != nil {
		return x.Wallet
	}
	return ""
}

func (x *NotificationMessage) GetNotificationType() NotificationType {
	if x != nil {
		return x.NotificationType
	}
	return NotificationType_NOTIFICATION_TYPE_UNSPECIFIED
}

func (x *NotificationMessage) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *NotificationMessage) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *NotificationMessage) GetData() string {
	if x != nil {
		return x.Data
	}
	return ""
}

func (x *NotificationMessage) GetEntityId() string {
	if x != nil {
		return x.EntityId
	}
	return ""
}

func (x *NotificationMessage) GetChannels() []string {
	if x != nil {
		return x.Channels
	}
	return nil
}

func (x *NotificationMessage) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

// MarketStatsMessage represents market statistics update
type MarketStatsMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Trading pair symbol
	Market string `protobuf:"bytes,1,opt,name=market,proto3" json:"market,omitempty"`
	// Statistics interval (1m, 1h, 1d)
	Interval string `protobuf:"bytes,2,opt,name=interval,proto3" json:"interval,omitempty"`
	// Interval start timestamp (Unix milliseconds)
	IntervalStart int64 `protobuf:"varint,3,opt,name=interval_start,json=intervalStart,proto3" json:"interval_start,omitempty"`
	// Open price (decimal string)
	Open string `protobuf:"bytes,4,opt,name=open,proto3" json:"open,omitempty"`
	// High price (decimal string)
	High string `protobuf:"bytes,5,opt,name=high,proto3" json:"high,omitempty"`
	// Low price (decimal string)
	Low string `protobuf:"bytes,6,opt,name=low,proto3" json:"low,omitempty"`
	// Close price (decimal string)
	Close string `protobuf:"bytes,7,opt,name=close,proto3" json:"close,omitempty"`
	// Volume in base token (decimal string)
	Volume string `protobuf:"bytes,8,opt,name=volume,proto3" json:"volume,omitempty"`
	// Volume in quote token (decimal string)
	QuoteVolume string `protobuf:"bytes,9,opt,name=quote_volume,json=quoteVolume,proto3" json:"quote_volume,omitempty"`
	// Number of trades
	TradeCount int64 `protobuf:"varint,10,opt,name=trade_count,json=tradeCount,proto3" json:"trade_count,omitempty"`
	// Buyer volume (decimal string)
	BuyerVolume string `protobuf:"bytes,11,opt,name=buyer_volume,json=buyerVolume,proto3" json:"buyer_volume,omitempty"`
	// Seller volume (decimal string)
	SellerVolume string `protobuf:"bytes,12,opt,name=seller_volume,json=sellerVolume,proto3" json:"seller_volume,omitempty"`
	// Update timestamp (Unix milliseconds)
	UpdatedAt     int64 `protobuf:"varint,13,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MarketStatsMessage) Reset() {
	*x = MarketStatsMessage{}
	mi := &file_common_kafka_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MarketStatsMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MarketStatsMessage) ProtoMessage() {}

func (x *MarketStatsMessage) ProtoReflect() protoreflect.Message {
	mi := &file_common_kafka_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MarketStatsMessage.ProtoReflect.Descriptor instead.
func (*MarketStatsMessage) Descriptor() ([]byte, []int) {
	return file_common_kafka_proto_rawDescGZIP(), []int{19}
}

func (x *MarketStatsMessage) GetMarket() string {
	if x != nil {
		return x.Market
	}
	return ""
}

func (x *MarketStatsMessage) GetInterval() string {
	if x != nil {
		return x.Interval
	}
	return ""
}

func (x *MarketStatsMessage) GetIntervalStart() int64 {
	if x != nil {
		return x.IntervalStart
	}
	return 0
}

func (x *MarketStatsMessage) GetOpen() string {
	if x != nil {
		return x.Open
	}
	return ""
}

func (x *MarketStatsMessage) GetHigh() string {
	if x != nil {
		return x.High
	}
	return ""
}

func (x *MarketStatsMessage) GetLow() string {
	if x != nil {
		return x.Low
	}
	return ""
}

func (x *MarketStatsMessage) GetClose() string {
	if x != nil {
		return x.Close
	}
	return ""
}

func (x *MarketStatsMessage) GetVolume() string {
	if x != nil {
		return x.Volume
	}
	return ""
}

func (x *MarketStatsMessage) GetQuoteVolume() string {
	if x != nil {
		return x.QuoteVolume
	}
	return ""
}

func (x *MarketStatsMessage) GetTradeCount() int64 {
	if x != nil {
		return x.TradeCount
	}
	return 0
}

func (x *MarketStatsMessage) GetBuyerVolume() string {
	if x != nil {
		return x.BuyerVolume
	}
	return ""
}

func (x *MarketStatsMessage) GetSellerVolume() string {
	if x != nil {
		return x.SellerVolume
	}
	return ""
}

func (x *MarketStatsMessage) GetUpdatedAt() int64 {
	if x != nil {
		return x.UpdatedAt
	}
	return 0
}

var File_common_kafka_proto protoreflect.FileDescriptor

const file_common_kafka_proto_rawDesc = "" +
	"\n" +
	"\x12common/kafka.proto\x12\x0feidos.common.v1\x1a\x12common/enums.proto\"\xe7\x04\n" +
	"\fOrderMessage\x12\x19\n" +
	"\border_id\x18\x01 \x01(\tR\aorderId\x12\x16\n" +
	"\x06wallet\x18\x02 \x01(\tR\x06wallet\x12\x16\n" +
	"\x06market\x18\x03 \x01(\tR\x06market\x12.\n" +
	"\x04side\x18\x04 \x01(\x0e2\x1a.eidos.common.v1.OrderSideR\x04side\x129\n" +
	"\n" +
	"order_type\x18\x05 \x01(\x0e2\x1a.eidos.common.v1.OrderTypeR\torderType\x12\x14\n" +
	"\x05price\x18\x06 \x01(\tR\x05price\x12\x16\n" +
	"\x06amount\x18\a \x01(\tR\x06amount\x12!\n" +
	"\fquote_amount\x18\b \x01(\tR\vquoteAmount\x12@\n" +
	"\rtime_in_force\x18\t \x01(\x0e2\x1c.eidos.common.v1.TimeInForceR\vtimeInForce\x12X\n" +
	"\x15self_trade_prevention\x18\n" +
	" \x01(\x0e2$.eidos.common.v1.SelfTradePreventionR\x13selfTradePrevention\x12&\n" +
	"\x0fclient_order_id\x18\v \x01(\tR\rclientOrderId\x12\x1b\n" +
	"\texpire_at\x18\f \x01(\x03R\bexpireAt\x12(\n" +
	"\x10max_slippage_bps\x18\r \x01(\rR\x0emaxSlippageBps\x12&\n" +
	"\x0fmin_fill_amount\x18\x0e \x01(\tR\rminFillAmount\x12\x1d\n" +
	"\n" +
	"created_at\x18\x0f \x01(\x03R\tcreatedAt\"\x9c\x01\n" +
	"\x14CancelRequestMessage\x12\x19\n" +
	"\border_id\x18\x01 \x01(\tR\aorderId\x12\x16\n" +
	"\x06market\x18\x02 \x01(\tR\x06market\x12\x16\n" +
	"\x06wallet\x18\x03 \x01(\tR\x06wallet\x12!\n" +
	"\frequested_at\x18\x04 \x01(\x03R\vrequestedAt\x12\x16\n" +
	"\x06reason\x18\x05 \x01(\tR\x06reason\"\xbb\x01\n" +
	"\x19BatchCancelRequestMessage\x12\x16\n" +
	"\x06market\x18\x01 \x01(\tR\x06market\x12\x16\n" +
	"\x06wallet\x18\x02 \x01(\tR\x06wallet\x12\x1b\n" +
	"\torder_ids\x18\x03 \x03(\tR\borderIds\x12.\n" +
	"\x04side\x18\x04 \x01(\x0e2\x1a.eidos.common.v1.OrderSideR\x04side\x12!\n" +
	"\frequested_at\x18\x05 \x01(\x03R\vrequestedAt\"\x8f\x05\n" +
	"\x12TradeResultMessage\x12\x19\n" +
	"\btrade_id\x18\x01 \x01(\tR\atradeId\x12\x16\n" +
	"\x06market\x18\x02 \x01(\tR\x06market\x12$\n" +
	"\x0emaker_order_id\x18\x03 \x01(\tR\fmakerOrderId\x12$\n" +
	"\x0etaker_order_id\x18\x04 \x01(\tR\ftakerOrderId\x12!\n" +
	"\fmaker_wallet\x18\x05 \x01(\tR\vmakerWallet\x12!\n" +
	"\ftaker_wallet\x18\x06 \x01(\tR\vtakerWallet\x129\n" +
	"\n" +
	"taker_side\x18\a \x01(\x0e2\x1a.eidos.common.v1.OrderSideR\ttakerSide\x12\x14\n" +
	"\x05price\x18\b \x01(\tR\x05price\x12\x16\n" +
	"\x06amount\x18\t \x01(\tR\x06amount\x12!\n" +
	"\fquote_amount\x18\n" +
	" \x01(\tR\vquoteAmount\x12\x1b\n" +
	"\tmaker_fee\x18\v \x01(\tR\bmakerFee\x12\x1b\n" +
	"\ttaker_fee\x18\f \x01(\tR\btakerFee\x12\x1b\n" +
	"\tfee_token\x18\r \x01(\tR\bfeeToken\x12!\n" +
	"\fmaker_filled\x18\x0e \x01(\bR\vmakerFilled\x12!\n" +
	"\ftaker_filled\x18\x0f \x01(\bR\vtakerFilled\x12'\n" +
	"\x0fmaker_remaining\x18\x10 \x01(\tR\x0emakerRemaining\x12'\n" +
	"\x0ftaker_remaining\x18\x11 \x01(\tR\x0etakerRemaining\x12\x1d\n" +
	"\n" +
	"matched_at\x18\x12 \x01(\x03R\tmatchedAt\x12\x1a\n" +
	"\bsequence\x18\x13 \x01(\x04R\bsequence\"\xbe\x03\n" +
	"\x12OrderUpdateMessage\x12\x19\n" +
	"\border_id\x18\x01 \x01(\tR\aorderId\x12\x16\n" +
	"\x06wallet\x18\x02 \x01(\tR\x06wallet\x12\x16\n" +
	"\x06market\x18\x03 \x01(\tR\x06market\x124\n" +
	"\x06status\x18\x04 \x01(\x0e2\x1c.eidos.common.v1.OrderStatusR\x06status\x12E\n" +
	"\x0fprevious_status\x18\x05 \x01(\x0e2\x1c.eidos.common.v1.OrderStatusR\x0epreviousStatus\x12#\n" +
	"\rfilled_amount\x18\x06 \x01(\tR\ffilledAmount\x12!\n" +
	"\ffilled_quote\x18\a \x01(\tR\vfilledQuote\x12)\n" +
	"\x10remaining_amount\x18\b \x01(\tR\x0fremainingAmount\x12\x1b\n" +
	"\tavg_price\x18\t \x01(\tR\bavgPrice\x12\x16\n" +
	"\x06reason\x18\n" +
	" \x01(\tR\x06reason\x12\x19\n" +
	"\btrade_id\x18\v \x01(\tR\atradeId\x12\x1d\n" +
	"\n" +
	"updated_at\x18\f \x01(\x03R\tupdatedAt\"\xc8\x01\n" +
	"\x15OrderCancelledMessage\x12\x19\n" +
	"\border_id\x18\x01 \x01(\tR\aorderId\x12\x16\n" +
	"\x06market\x18\x02 \x01(\tR\x06market\x12\x16\n" +
	"\x06wallet\x18\x03 \x01(\tR\x06wallet\x12)\n" +
	"\x10remaining_amount\x18\x04 \x01(\tR\x0fremainingAmount\x12\x16\n" +
	"\x06reason\x18\x05 \x01(\tR\x06reason\x12!\n" +
	"\fcancelled_at\x18\x06 \x01(\x03R\vcancelledAt\"\xd8\x01\n" +
	"\x16OrderbookUpdateMessage\x12\x16\n" +
	"\x06market\x18\x01 \x01(\tR\x06market\x12\x1a\n" +
	"\bsequence\x18\x02 \x01(\x04R\bsequence\x125\n" +
	"\x04bids\x18\x03 \x03(\v2!.eidos.common.v1.PriceLevelUpdateR\x04bids\x125\n" +
	"\x04asks\x18\x04 \x03(\v2!.eidos.common.v1.PriceLevelUpdateR\x04asks\x12\x1c\n" +
	"\ttimestamp\x18\x05 \x01(\x03R\ttimestamp\"a\n" +
	"\x10PriceLevelUpdate\x12\x14\n" +
	"\x05price\x18\x01 \x01(\tR\x05price\x12\x16\n" +
	"\x06amount\x18\x02 \x01(\tR\x06amount\x12\x1f\n" +
	"\vorder_count\x18\x03 \x01(\x05R\n" +
	"orderCount\"\xa7\x03\n" +
	"\x14BalanceUpdateMessage\x12\x16\n" +
	"\x06wallet\x18\x01 \x01(\tR\x06wallet\x12\x14\n" +
	"\x05token\x18\x02 \x01(\tR\x05token\x12C\n" +
	"\vchange_type\x18\x03 \x01(\x0e2\".eidos.common.v1.BalanceChangeTypeR\n" +
	"changeType\x12\x16\n" +
	"\x06amount\x18\x04 \x01(\tR\x06amount\x12%\n" +
	"\x0ebalance_before\x18\x05 \x01(\tR\rbalanceBefore\x12#\n" +
	"\rbalance_after\x18\x06 \x01(\tR\fbalanceAfter\x12'\n" +
	"\x0favailable_after\x18\a \x01(\tR\x0eavailableAfter\x12!\n" +
	"\ffrozen_after\x18\b \x01(\tR\vfrozenAfter\x12\x19\n" +
	"\border_id\x18\t \x01(\tR\aorderId\x12\x19\n" +
	"\btrade_id\x18\n" +
	" \x01(\tR\atradeId\x12\x17\n" +
	"\atx_hash\x18\v \x01(\tR\x06txHash\x12\x1d\n" +
	"\n" +
	"updated_at\x18\f \x01(\x03R\tupdatedAt\"\x8c\x03\n" +
	"\x0eDepositMessage\x12\x1d\n" +
	"\n" +
	"deposit_id\x18\x01 \x01(\tR\tdepositId\x12\x17\n" +
	"\atx_hash\x18\x02 \x01(\tR\x06txHash\x12\x1b\n" +
	"\tlog_index\x18\x03 \x01(\rR\blogIndex\x12\x16\n" +
	"\x06wallet\x18\x04 \x01(\tR\x06wallet\x12\x14\n" +
	"\x05token\x18\x05 \x01(\tR\x05token\x12#\n" +
	"\rtoken_address\x18\x06 \x01(\tR\ftokenAddress\x12\x16\n" +
	"\x06amount\x18\a \x01(\tR\x06amount\x12!\n" +
	"\fblock_number\x18\b \x01(\x03R\vblockNumber\x12\x19\n" +
	"\bchain_id\x18\t \x01(\x03R\achainId\x12$\n" +
	"\rconfirmations\x18\n" +
	" \x01(\x05R\rconfirmations\x125\n" +
	"\x16required_confirmations\x18\v \x01(\x05R\x15requiredConfirmations\x12\x1f\n" +
	"\vdetected_at\x18\f \x01(\x03R\n" +
	"detectedAt\"\xba\x01\n" +
	"\x17DepositConfirmedMessage\x12\x1d\n" +
	"\n" +
	"deposit_id\x18\x01 \x01(\tR\tdepositId\x12\x16\n" +
	"\x06wallet\x18\x02 \x01(\tR\x06wallet\x12\x14\n" +
	"\x05token\x18\x03 \x01(\tR\x05token\x12\x16\n" +
	"\x06amount\x18\x04 \x01(\tR\x06amount\x12\x17\n" +
	"\atx_hash\x18\x05 \x01(\tR\x06txHash\x12!\n" +
	"\fconfirmed_at\x18\x06 \x01(\x03R\vconfirmedAt\"\xd3\x02\n" +
	"\x18WithdrawalRequestMessage\x12\x1f\n" +
	"\vwithdraw_id\x18\x01 \x01(\tR\n" +
	"withdrawId\x12\x16\n" +
	"\x06wallet\x18\x02 \x01(\tR\x06wallet\x12\x14\n" +
	"\x05token\x18\x03 \x01(\tR\x05token\x12#\n" +
	"\rtoken_address\x18\x04 \x01(\tR\ftokenAddress\x12\x16\n" +
	"\x06amount\x18\x05 \x01(\tR\x06amount\x12\x1d\n" +
	"\n" +
	"to_address\x18\x06 \x01(\tR\ttoAddress\x12\x14\n" +
	"\x05nonce\x18\a \x01(\x04R\x05nonce\x12\x1c\n" +
	"\tsignature\x18\b \x01(\fR\tsignature\x12\x19\n" +
	"\bchain_id\x18\t \x01(\x03R\achainId\x12\x1a\n" +
	"\bpriority\x18\n" +
	" \x01(\x05R\bpriority\x12!\n" +
	"\frequested_at\x18\v \x01(\x03R\vrequestedAt\"\x8b\x02\n" +
	"\x17WithdrawalStatusMessage\x12\x1f\n" +
	"\vwithdraw_id\x18\x01 \x01(\tR\n" +
	"withdrawId\x12\x16\n" +
	"\x06wallet\x18\x02 \x01(\tR\x06wallet\x127\n" +
	"\x06status\x18\x03 \x01(\x0e2\x1f.eidos.common.v1.WithdrawStatusR\x06status\x12\x17\n" +
	"\atx_hash\x18\x04 \x01(\tR\x06txHash\x12!\n" +
	"\fblock_number\x18\x05 \x01(\x03R\vblockNumber\x12#\n" +
	"\rerror_message\x18\x06 \x01(\tR\ferrorMessage\x12\x1d\n" +
	"\n" +
	"updated_at\x18\a \x01(\x03R\tupdatedAt\"\xbe\x01\n" +
	"\x11SettlementMessage\x12\x19\n" +
	"\bbatch_id\x18\x01 \x01(\tR\abatchId\x128\n" +
	"\x06trades\x18\x02 \x03(\v2 .eidos.common.v1.SettlementTradeR\x06trades\x12\x19\n" +
	"\bchain_id\x18\x03 \x01(\x03R\achainId\x12\x1a\n" +
	"\bpriority\x18\x04 \x01(\x05R\bpriority\x12\x1d\n" +
	"\n" +
	"created_at\x18\x05 \x01(\x03R\tcreatedAt\"\x96\x04\n" +
	"\x0fSettlementTrade\x12\x19\n" +
	"\btrade_id\x18\x01 \x01(\tR\atradeId\x12\x16\n" +
	"\x06market\x18\x02 \x01(\tR\x06market\x12!\n" +
	"\fmaker_wallet\x18\x03 \x01(\tR\vmakerWallet\x12!\n" +
	"\ftaker_wallet\x18\x04 \x01(\tR\vtakerWallet\x12\x1d\n" +
	"\n" +
	"base_token\x18\x05 \x01(\tR\tbaseToken\x12\x1f\n" +
	"\vquote_token\x18\x06 \x01(\tR\n" +
	"quoteToken\x12,\n" +
	"\x12base_token_address\x18\a \x01(\tR\x10baseTokenAddress\x12.\n" +
	"\x13quote_token_address\x18\b \x01(\tR\x11quoteTokenAddress\x12\x14\n" +
	"\x05price\x18\t \x01(\tR\x05price\x12\x1f\n" +
	"\vbase_amount\x18\n" +
	" \x01(\tR\n" +
	"baseAmount\x12!\n" +
	"\fquote_amount\x18\v \x01(\tR\vquoteAmount\x129\n" +
	"\n" +
	"taker_side\x18\f \x01(\x0e2\x1a.eidos.common.v1.OrderSideR\ttakerSide\x12\x1b\n" +
	"\tmaker_fee\x18\r \x01(\tR\bmakerFee\x12\x1b\n" +
	"\ttaker_fee\x18\x0e \x01(\tR\btakerFee\x12\x1d\n" +
	"\n" +
	"matched_at\x18\x0f \x01(\x03R\tmatchedAt\"\xeb\x01\n" +
	"\x1aSettlementConfirmedMessage\x12\x19\n" +
	"\bbatch_id\x18\x01 \x01(\tR\abatchId\x12\x17\n" +
	"\atx_hash\x18\x02 \x01(\tR\x06txHash\x12!\n" +
	"\fblock_number\x18\x03 \x01(\x03R\vblockNumber\x12\x1b\n" +
	"\ttrade_ids\x18\x04 \x03(\tR\btradeIds\x12\x19\n" +
	"\bgas_used\x18\x05 \x01(\x03R\agasUsed\x12\x1b\n" +
	"\tgas_price\x18\x06 \x01(\tR\bgasPrice\x12!\n" +
	"\fconfirmed_at\x18\a \x01(\x03R\vconfirmedAt\"\x85\x02\n" +
	"\x17SettlementFailedMessage\x12\x19\n" +
	"\bbatch_id\x18\x01 \x01(\tR\abatchId\x12\x1b\n" +
	"\ttrade_ids\x18\x02 \x03(\tR\btradeIds\x12#\n" +
	"\rerror_message\x18\x03 \x01(\tR\ferrorMessage\x12\x1d\n" +
	"\n" +
	"error_code\x18\x04 \x01(\tR\terrorCode\x12!\n" +
	"\fshould_retry\x18\x05 \x01(\bR\vshouldRetry\x12.\n" +
	"\x13retry_delay_seconds\x18\x06 \x01(\x05R\x11retryDelaySeconds\x12\x1b\n" +
	"\tfailed_at\x18\a \x01(\x03R\bfailedAt\"\x98\x04\n" +
	"\x10RiskAlertMessage\x12\x19\n" +
	"\balert_id\x18\x01 \x01(\tR\aalertId\x12\x16\n" +
	"\x06wallet\x18\x02 \x01(\tR\x06wallet\x12=\n" +
	"\n" +
	"alert_type\x18\x03 \x01(\x0e2\x1e.eidos.common.v1.RiskEventTypeR\talertType\x126\n" +
	"\bseverity\x18\x04 \x01(\x0e2\x1a.eidos.common.v1.RiskLevelR\bseverity\x12\x17\n" +
	"\arule_id\x18\x05 \x01(\tR\x06ruleId\x12 \n" +
	"\vdescription\x18\x06 \x01(\tR\vdescription\x12>\n" +
	"\faction_taken\x18\a \x01(\x0e2\x1b.eidos.common.v1.RiskActionR\vactionTaken\x12H\n" +
	"\acontext\x18\b \x03(\v2..eidos.common.v1.RiskAlertMessage.ContextEntryR\acontext\x12\x19\n" +
	"\border_id\x18\t \x01(\tR\aorderId\x12\x1f\n" +
	"\vwithdraw_id\x18\n" +
	" \x01(\tR\n" +
	"withdrawId\x12\x1d\n" +
	"\n" +
	"created_at\x18\v \x01(\x03R\tcreatedAt\x1a:\n" +
	"\fContextEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xc2\x02\n" +
	"\x13NotificationMessage\x12'\n" +
	"\x0fnotification_id\x18\x01 \x01(\tR\x0enotificationId\x12\x16\n" +
	"\x06wallet\x18\x02 \x01(\tR\x06wallet\x12N\n" +
	"\x11notification_type\x18\x03 \x01(\x0e2!.eidos.common.v1.NotificationTypeR\x10notificationType\x12\x14\n" +
	"\x05title\x18\x04 \x01(\tR\x05title\x12\x18\n" +
	"\amessage\x18\x05 \x01(\tR\amessage\x12\x12\n" +
	"\x04data\x18\x06 \x01(\tR\x04data\x12\x1b\n" +
	"\tentity_id\x18\a \x01(\tR\bentityId\x12\x1a\n" +
	"\bchannels\x18\b \x03(\tR\bchannels\x12\x1d\n" +
	"\n" +
	"created_at\x18\t \x01(\x03R\tcreatedAt\"\x82\x03\n" +
	"\x12MarketStatsMessage\x12\x16\n" +
	"\x06market\x18\x01 \x01(\tR\x06market\x12\x1a\n" +
	"\binterval\x18\x02 \x01(\tR\binterval\x12%\n" +
	"\x0einterval_start\x18\x03 \x01(\x03R\rintervalStart\x12\x12\n" +
	"\x04open\x18\x04 \x01(\tR\x04open\x12\x12\n" +
	"\x04high\x18\x05 \x01(\tR\x04high\x12\x10\n" +
	"\x03low\x18\x06 \x01(\tR\x03low\x12\x14\n" +
	"\x05close\x18\a \x01(\tR\x05close\x12\x16\n" +
	"\x06volume\x18\b \x01(\tR\x06volume\x12!\n" +
	"\fquote_volume\x18\t \x01(\tR\vquoteVolume\x12\x1f\n" +
	"\vtrade_count\x18\n" +
	" \x01(\x03R\n" +
	"tradeCount\x12!\n" +
	"\fbuyer_volume\x18\v \x01(\tR\vbuyerVolume\x12#\n" +
	"\rseller_volume\x18\f \x01(\tR\fsellerVolume\x12\x1d\n" +
	"\n" +
	"updated_at\x18\r \x01(\x03R\tupdatedAtB7Z5github.com/eidos-exchange/eidos/proto/common;commonv1b\x06proto3"

var (
	file_common_kafka_proto_rawDescOnce sync.Once
	file_common_kafka_proto_rawDescData []byte
)

func file_common_kafka_proto_rawDescGZIP() []byte {
	file_common_kafka_proto_rawDescOnce.Do(func() {
		file_common_kafka_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_common_kafka_proto_rawDesc), len(file_common_kafka_proto_rawDesc)))
	})
	return file_common_kafka_proto_rawDescData
}

var file_common_kafka_proto_msgTypes = make([]protoimpl.MessageInfo, 21)
var file_common_kafka_proto_goTypes = []any{
	(*OrderMessage)(nil),               // 0: eidos.common.v1.OrderMessage
	(*CancelRequestMessage)(nil),       // 1: eidos.common.v1.CancelRequestMessage
	(*BatchCancelRequestMessage)(nil),  // 2: eidos.common.v1.BatchCancelRequestMessage
	(*TradeResultMessage)(nil),         // 3: eidos.common.v1.TradeResultMessage
	(*OrderUpdateMessage)(nil),         // 4: eidos.common.v1.OrderUpdateMessage
	(*OrderCancelledMessage)(nil),      // 5: eidos.common.v1.OrderCancelledMessage
	(*OrderbookUpdateMessage)(nil),     // 6: eidos.common.v1.OrderbookUpdateMessage
	(*PriceLevelUpdate)(nil),           // 7: eidos.common.v1.PriceLevelUpdate
	(*BalanceUpdateMessage)(nil),       // 8: eidos.common.v1.BalanceUpdateMessage
	(*DepositMessage)(nil),             // 9: eidos.common.v1.DepositMessage
	(*DepositConfirmedMessage)(nil),    // 10: eidos.common.v1.DepositConfirmedMessage
	(*WithdrawalRequestMessage)(nil),   // 11: eidos.common.v1.WithdrawalRequestMessage
	(*WithdrawalStatusMessage)(nil),    // 12: eidos.common.v1.WithdrawalStatusMessage
	(*SettlementMessage)(nil),          // 13: eidos.common.v1.SettlementMessage
	(*SettlementTrade)(nil),            // 14: eidos.common.v1.SettlementTrade
	(*SettlementConfirmedMessage)(nil), // 15: eidos.common.v1.SettlementConfirmedMessage
	(*SettlementFailedMessage)(nil),    // 16: eidos.common.v1.SettlementFailedMessage
	(*RiskAlertMessage)(nil),           // 17: eidos.common.v1.RiskAlertMessage
	(*NotificationMessage)(nil),        // 18: eidos.common.v1.NotificationMessage
	(*MarketStatsMessage)(nil),         // 19: eidos.common.v1.MarketStatsMessage
	nil,                                // 20: eidos.common.v1.RiskAlertMessage.ContextEntry
	(OrderSide)(0),                     // 21: eidos.common.v1.OrderSide
	(OrderType)(0),                     // 22: eidos.common.v1.OrderType
	(TimeInForce)(0),                   // 23: eidos.common.v1.TimeInForce
	(SelfTradePrevention)(0),           // 24: eidos.common.v1.SelfTradePrevention
	(OrderStatus)(0),                   // 25: eidos.common.v1.OrderStatus
	(BalanceChangeType)(0),             // 26: eidos.common.v1.BalanceChangeType
	(WithdrawStatus)(0),                // 27: eidos.common.v1.WithdrawStatus
	(RiskEventType)(0),                 // 28: eidos.common.v1.RiskEventType
	(RiskLevel)(0),                     // 29: eidos.common.v1.RiskLevel
	(RiskAction)(0),                    // 30: eidos.common.v1.RiskAction
	(NotificationType)(0),              // 31: eidos.common.v1.NotificationType
}
var file_common_kafka_proto_depIdxs = []int32{
	21, // 0: eidos.common.v1.OrderMessage.side:type_name -> eidos.common.v1.OrderSide
	22, // 1: eidos.common.v1.OrderMessage.order_type:type_name -> eidos.common.v1.OrderType
	23, // 2: eidos.common.v1.OrderMessage.time_in_force:type_name -> eidos.common.v1.TimeInForce
	24, // 3: eidos.common.v1.OrderMessage.self_trade_prevention:type_name -> eidos.common.v1.SelfTradePrevention
	21, // 4: eidos.common.v1.BatchCancelRequestMessage.side:type_name -> eidos.common.v1.OrderSide
	21, // 5: eidos.common.v1.TradeResultMessage.taker_side:type_name -> eidos.common.v1.OrderSide
	25, // 6: eidos.common.v1.OrderUpdateMessage.status:type_name -> eidos.common.v1.OrderStatus
	25, // 7: eidos.common.v1.OrderUpdateMessage.previous_status:type_name -> eidos.common.v1.OrderStatus
	7,  // 8: eidos.common.v1.OrderbookUpdateMessage.bids:type_name -> eidos.common.v1.PriceLevelUpdate
	7,  // 9: eidos.common.v1.OrderbookUpdateMessage.asks:type_name -> eidos.common.v1.PriceLevelUpdate
	26, // 10: eidos.common.v1.BalanceUpdateMessage.change_type:type_name -> eidos.common.v1.BalanceChangeType
	27, // 11: eidos.common.v1.WithdrawalStatusMessage.status:type_name -> eidos.common.v1.WithdrawStatus
	14, // 12: eidos.common.v1.SettlementMessage.trades:type_name -> eidos.common.v1.SettlementTrade
	21, // 13: eidos.common.v1.SettlementTrade.taker_side:type_name -> eidos.common.v1.OrderSide
	28, // 14: eidos.common.v1.RiskAlertMessage.alert_type:type_name -> eidos.common.v1.RiskEventType
	29, // 15: eidos.common.v1.RiskAlertMessage.severity:type_name -> eidos.common.v1.RiskLevel
	30, // 16: eidos.common.v1.RiskAlertMessage.action_taken:type_name -> eidos.common.v1.RiskAction
	20, // 17: eidos.common.v1.RiskAlertMessage.context:type_name -> eidos.common.v1.RiskAlertMessage.ContextEntry
	31, // 18: eidos.common.v1.NotificationMessage.notification_type:type_name -> eidos.common.v1.NotificationType
	19, // [19:19] is the sub-list for method output_type
	19, // [19:19] is the sub-list for method input_type
	19, // [19:19] is the sub-list for extension type_name
	19, // [19:19] is the sub-list for extension extendee
	0,  // [0:19] is the sub-list for field type_name
}

func init() { file_common_kafka_proto_init() }
func file_common_kafka_proto_init() {
	if File_common_kafka_proto != nil {
		return
	}
	file_common_enums_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_common_kafka_proto_rawDesc), len(file_common_kafka_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   21,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_common_kafka_proto_goTypes,
		DependencyIndexes: file_common_kafka_proto_depIdxs,
		MessageInfos:      file_common_kafka_proto_msgTypes,
	}.Build()
	File_common_kafka_proto = out.File
	file_common_kafka_proto_goTypes = nil
	file_common_kafka_proto_depIdxs = nil
}
