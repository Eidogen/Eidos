// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: trading/v1/trading.proto

package tradingv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	TradingService_PrepareOrder_FullMethodName        = "/eidos.trading.v1.TradingService/PrepareOrder"
	TradingService_CreateOrder_FullMethodName         = "/eidos.trading.v1.TradingService/CreateOrder"
	TradingService_CancelOrder_FullMethodName         = "/eidos.trading.v1.TradingService/CancelOrder"
	TradingService_BatchCancelOrders_FullMethodName   = "/eidos.trading.v1.TradingService/BatchCancelOrders"
	TradingService_GetOrder_FullMethodName            = "/eidos.trading.v1.TradingService/GetOrder"
	TradingService_ListOrders_FullMethodName          = "/eidos.trading.v1.TradingService/ListOrders"
	TradingService_ListOpenOrders_FullMethodName      = "/eidos.trading.v1.TradingService/ListOpenOrders"
	TradingService_GetBalance_FullMethodName          = "/eidos.trading.v1.TradingService/GetBalance"
	TradingService_GetBalances_FullMethodName         = "/eidos.trading.v1.TradingService/GetBalances"
	TradingService_GetBalanceLogs_FullMethodName      = "/eidos.trading.v1.TradingService/GetBalanceLogs"
	TradingService_GetTrade_FullMethodName            = "/eidos.trading.v1.TradingService/GetTrade"
	TradingService_ListTrades_FullMethodName          = "/eidos.trading.v1.TradingService/ListTrades"
	TradingService_ListTradesByOrder_FullMethodName   = "/eidos.trading.v1.TradingService/ListTradesByOrder"
	TradingService_GetDeposit_FullMethodName          = "/eidos.trading.v1.TradingService/GetDeposit"
	TradingService_ListDeposits_FullMethodName        = "/eidos.trading.v1.TradingService/ListDeposits"
	TradingService_CreateWithdrawal_FullMethodName    = "/eidos.trading.v1.TradingService/CreateWithdrawal"
	TradingService_CancelWithdrawal_FullMethodName    = "/eidos.trading.v1.TradingService/CancelWithdrawal"
	TradingService_GetWithdrawal_FullMethodName       = "/eidos.trading.v1.TradingService/GetWithdrawal"
	TradingService_ListWithdrawals_FullMethodName     = "/eidos.trading.v1.TradingService/ListWithdrawals"
	TradingService_ProcessTradeResult_FullMethodName  = "/eidos.trading.v1.TradingService/ProcessTradeResult"
	TradingService_ProcessDepositEvent_FullMethodName = "/eidos.trading.v1.TradingService/ProcessDepositEvent"
	TradingService_ConfirmSettlement_FullMethodName   = "/eidos.trading.v1.TradingService/ConfirmSettlement"
	TradingService_RollbackSettlement_FullMethodName  = "/eidos.trading.v1.TradingService/RollbackSettlement"
)

// TradingServiceClient is the client API for TradingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// TradingService provides the core trading functionality including:
// - Order management (create, cancel, query)
// - Balance management (query, freeze/unfreeze)
// - Trade history
// - Deposit/Withdrawal operations
type TradingServiceClient interface {
	// PrepareOrder prepares an order for signing
	// Returns EIP-712 typed data for client to sign
	PrepareOrder(ctx context.Context, in *PrepareOrderRequest, opts ...grpc.CallOption) (*PrepareOrderResponse, error)
	// CreateOrder creates a new order (limit or market)
	// Returns the created order with initial status
	CreateOrder(ctx context.Context, in *CreateOrderRequest, opts ...grpc.CallOption) (*CreateOrderResponse, error)
	// CancelOrder cancels an active order
	// Only orders with status OPEN or PARTIAL can be cancelled
	CancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// BatchCancelOrders cancels multiple orders at once
	// Supports filtering by market and side
	BatchCancelOrders(ctx context.Context, in *BatchCancelOrdersRequest, opts ...grpc.CallOption) (*BatchCancelOrdersResponse, error)
	// GetOrder retrieves order details by order ID
	GetOrder(ctx context.Context, in *GetOrderRequest, opts ...grpc.CallOption) (*Order, error)
	// ListOrders retrieves orders with optional filters
	ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error)
	// ListOpenOrders retrieves all active orders for a wallet
	ListOpenOrders(ctx context.Context, in *ListOpenOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error)
	// GetBalance retrieves balance for a specific token
	GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*Balance, error)
	// GetBalances retrieves all token balances for a wallet
	GetBalances(ctx context.Context, in *GetBalancesRequest, opts ...grpc.CallOption) (*GetBalancesResponse, error)
	// GetBalanceLogs retrieves balance change history
	GetBalanceLogs(ctx context.Context, in *GetBalanceLogsRequest, opts ...grpc.CallOption) (*GetBalanceLogsResponse, error)
	// GetTrade retrieves trade details by trade ID
	GetTrade(ctx context.Context, in *GetTradeRequest, opts ...grpc.CallOption) (*Trade, error)
	// ListTrades retrieves trade history with optional filters
	ListTrades(ctx context.Context, in *ListTradesRequest, opts ...grpc.CallOption) (*ListTradesResponse, error)
	// ListTradesByOrder retrieves all trades for a specific order
	ListTradesByOrder(ctx context.Context, in *ListTradesByOrderRequest, opts ...grpc.CallOption) (*ListTradesResponse, error)
	// GetDeposit retrieves deposit details by deposit ID
	GetDeposit(ctx context.Context, in *GetDepositRequest, opts ...grpc.CallOption) (*Deposit, error)
	// ListDeposits retrieves deposit history with optional filters
	ListDeposits(ctx context.Context, in *ListDepositsRequest, opts ...grpc.CallOption) (*ListDepositsResponse, error)
	// CreateWithdrawal creates a new withdrawal request
	// Requires sufficient available balance
	CreateWithdrawal(ctx context.Context, in *CreateWithdrawalRequest, opts ...grpc.CallOption) (*CreateWithdrawalResponse, error)
	// CancelWithdrawal cancels a pending withdrawal
	// Only withdrawals with status PENDING can be cancelled
	CancelWithdrawal(ctx context.Context, in *CancelWithdrawalRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetWithdrawal retrieves withdrawal details by withdrawal ID
	GetWithdrawal(ctx context.Context, in *GetWithdrawalRequest, opts ...grpc.CallOption) (*Withdrawal, error)
	// ListWithdrawals retrieves withdrawal history with optional filters
	ListWithdrawals(ctx context.Context, in *ListWithdrawalsRequest, opts ...grpc.CallOption) (*ListWithdrawalsResponse, error)
	// ProcessTradeResult processes a trade result from matching engine
	// Called by Settlement Service after trade matching
	ProcessTradeResult(ctx context.Context, in *ProcessTradeResultRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ProcessDepositEvent processes a deposit event from chain indexer
	// Called by Chain Service when deposit is detected
	ProcessDepositEvent(ctx context.Context, in *ProcessDepositEventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ConfirmSettlement confirms on-chain settlement of trades
	// Called by Chain Service when settlement tx is confirmed
	ConfirmSettlement(ctx context.Context, in *ConfirmSettlementRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// RollbackSettlement rolls back a failed settlement
	// Called when on-chain settlement fails
	RollbackSettlement(ctx context.Context, in *RollbackSettlementRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type tradingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTradingServiceClient(cc grpc.ClientConnInterface) TradingServiceClient {
	return &tradingServiceClient{cc}
}

func (c *tradingServiceClient) PrepareOrder(ctx context.Context, in *PrepareOrderRequest, opts ...grpc.CallOption) (*PrepareOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PrepareOrderResponse)
	err := c.cc.Invoke(ctx, TradingService_PrepareOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) CreateOrder(ctx context.Context, in *CreateOrderRequest, opts ...grpc.CallOption) (*CreateOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateOrderResponse)
	err := c.cc.Invoke(ctx, TradingService_CreateOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) CancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TradingService_CancelOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) BatchCancelOrders(ctx context.Context, in *BatchCancelOrdersRequest, opts ...grpc.CallOption) (*BatchCancelOrdersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchCancelOrdersResponse)
	err := c.cc.Invoke(ctx, TradingService_BatchCancelOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) GetOrder(ctx context.Context, in *GetOrderRequest, opts ...grpc.CallOption) (*Order, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Order)
	err := c.cc.Invoke(ctx, TradingService_GetOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListOrdersResponse)
	err := c.cc.Invoke(ctx, TradingService_ListOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) ListOpenOrders(ctx context.Context, in *ListOpenOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListOrdersResponse)
	err := c.cc.Invoke(ctx, TradingService_ListOpenOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*Balance, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Balance)
	err := c.cc.Invoke(ctx, TradingService_GetBalance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) GetBalances(ctx context.Context, in *GetBalancesRequest, opts ...grpc.CallOption) (*GetBalancesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBalancesResponse)
	err := c.cc.Invoke(ctx, TradingService_GetBalances_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) GetBalanceLogs(ctx context.Context, in *GetBalanceLogsRequest, opts ...grpc.CallOption) (*GetBalanceLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBalanceLogsResponse)
	err := c.cc.Invoke(ctx, TradingService_GetBalanceLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) GetTrade(ctx context.Context, in *GetTradeRequest, opts ...grpc.CallOption) (*Trade, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Trade)
	err := c.cc.Invoke(ctx, TradingService_GetTrade_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) ListTrades(ctx context.Context, in *ListTradesRequest, opts ...grpc.CallOption) (*ListTradesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTradesResponse)
	err := c.cc.Invoke(ctx, TradingService_ListTrades_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) ListTradesByOrder(ctx context.Context, in *ListTradesByOrderRequest, opts ...grpc.CallOption) (*ListTradesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTradesResponse)
	err := c.cc.Invoke(ctx, TradingService_ListTradesByOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) GetDeposit(ctx context.Context, in *GetDepositRequest, opts ...grpc.CallOption) (*Deposit, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Deposit)
	err := c.cc.Invoke(ctx, TradingService_GetDeposit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) ListDeposits(ctx context.Context, in *ListDepositsRequest, opts ...grpc.CallOption) (*ListDepositsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDepositsResponse)
	err := c.cc.Invoke(ctx, TradingService_ListDeposits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) CreateWithdrawal(ctx context.Context, in *CreateWithdrawalRequest, opts ...grpc.CallOption) (*CreateWithdrawalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateWithdrawalResponse)
	err := c.cc.Invoke(ctx, TradingService_CreateWithdrawal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) CancelWithdrawal(ctx context.Context, in *CancelWithdrawalRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TradingService_CancelWithdrawal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) GetWithdrawal(ctx context.Context, in *GetWithdrawalRequest, opts ...grpc.CallOption) (*Withdrawal, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Withdrawal)
	err := c.cc.Invoke(ctx, TradingService_GetWithdrawal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) ListWithdrawals(ctx context.Context, in *ListWithdrawalsRequest, opts ...grpc.CallOption) (*ListWithdrawalsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListWithdrawalsResponse)
	err := c.cc.Invoke(ctx, TradingService_ListWithdrawals_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) ProcessTradeResult(ctx context.Context, in *ProcessTradeResultRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TradingService_ProcessTradeResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) ProcessDepositEvent(ctx context.Context, in *ProcessDepositEventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TradingService_ProcessDepositEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) ConfirmSettlement(ctx context.Context, in *ConfirmSettlementRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TradingService_ConfirmSettlement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) RollbackSettlement(ctx context.Context, in *RollbackSettlementRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TradingService_RollbackSettlement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TradingServiceServer is the server API for TradingService service.
// All implementations must embed UnimplementedTradingServiceServer
// for forward compatibility.
//
// TradingService provides the core trading functionality including:
// - Order management (create, cancel, query)
// - Balance management (query, freeze/unfreeze)
// - Trade history
// - Deposit/Withdrawal operations
type TradingServiceServer interface {
	// PrepareOrder prepares an order for signing
	// Returns EIP-712 typed data for client to sign
	PrepareOrder(context.Context, *PrepareOrderRequest) (*PrepareOrderResponse, error)
	// CreateOrder creates a new order (limit or market)
	// Returns the created order with initial status
	CreateOrder(context.Context, *CreateOrderRequest) (*CreateOrderResponse, error)
	// CancelOrder cancels an active order
	// Only orders with status OPEN or PARTIAL can be cancelled
	CancelOrder(context.Context, *CancelOrderRequest) (*emptypb.Empty, error)
	// BatchCancelOrders cancels multiple orders at once
	// Supports filtering by market and side
	BatchCancelOrders(context.Context, *BatchCancelOrdersRequest) (*BatchCancelOrdersResponse, error)
	// GetOrder retrieves order details by order ID
	GetOrder(context.Context, *GetOrderRequest) (*Order, error)
	// ListOrders retrieves orders with optional filters
	ListOrders(context.Context, *ListOrdersRequest) (*ListOrdersResponse, error)
	// ListOpenOrders retrieves all active orders for a wallet
	ListOpenOrders(context.Context, *ListOpenOrdersRequest) (*ListOrdersResponse, error)
	// GetBalance retrieves balance for a specific token
	GetBalance(context.Context, *GetBalanceRequest) (*Balance, error)
	// GetBalances retrieves all token balances for a wallet
	GetBalances(context.Context, *GetBalancesRequest) (*GetBalancesResponse, error)
	// GetBalanceLogs retrieves balance change history
	GetBalanceLogs(context.Context, *GetBalanceLogsRequest) (*GetBalanceLogsResponse, error)
	// GetTrade retrieves trade details by trade ID
	GetTrade(context.Context, *GetTradeRequest) (*Trade, error)
	// ListTrades retrieves trade history with optional filters
	ListTrades(context.Context, *ListTradesRequest) (*ListTradesResponse, error)
	// ListTradesByOrder retrieves all trades for a specific order
	ListTradesByOrder(context.Context, *ListTradesByOrderRequest) (*ListTradesResponse, error)
	// GetDeposit retrieves deposit details by deposit ID
	GetDeposit(context.Context, *GetDepositRequest) (*Deposit, error)
	// ListDeposits retrieves deposit history with optional filters
	ListDeposits(context.Context, *ListDepositsRequest) (*ListDepositsResponse, error)
	// CreateWithdrawal creates a new withdrawal request
	// Requires sufficient available balance
	CreateWithdrawal(context.Context, *CreateWithdrawalRequest) (*CreateWithdrawalResponse, error)
	// CancelWithdrawal cancels a pending withdrawal
	// Only withdrawals with status PENDING can be cancelled
	CancelWithdrawal(context.Context, *CancelWithdrawalRequest) (*emptypb.Empty, error)
	// GetWithdrawal retrieves withdrawal details by withdrawal ID
	GetWithdrawal(context.Context, *GetWithdrawalRequest) (*Withdrawal, error)
	// ListWithdrawals retrieves withdrawal history with optional filters
	ListWithdrawals(context.Context, *ListWithdrawalsRequest) (*ListWithdrawalsResponse, error)
	// ProcessTradeResult processes a trade result from matching engine
	// Called by Settlement Service after trade matching
	ProcessTradeResult(context.Context, *ProcessTradeResultRequest) (*emptypb.Empty, error)
	// ProcessDepositEvent processes a deposit event from chain indexer
	// Called by Chain Service when deposit is detected
	ProcessDepositEvent(context.Context, *ProcessDepositEventRequest) (*emptypb.Empty, error)
	// ConfirmSettlement confirms on-chain settlement of trades
	// Called by Chain Service when settlement tx is confirmed
	ConfirmSettlement(context.Context, *ConfirmSettlementRequest) (*emptypb.Empty, error)
	// RollbackSettlement rolls back a failed settlement
	// Called when on-chain settlement fails
	RollbackSettlement(context.Context, *RollbackSettlementRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedTradingServiceServer()
}

// UnimplementedTradingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTradingServiceServer struct{}

func (UnimplementedTradingServiceServer) PrepareOrder(context.Context, *PrepareOrderRequest) (*PrepareOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareOrder not implemented")
}
func (UnimplementedTradingServiceServer) CreateOrder(context.Context, *CreateOrderRequest) (*CreateOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrder not implemented")
}
func (UnimplementedTradingServiceServer) CancelOrder(context.Context, *CancelOrderRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelOrder not implemented")
}
func (UnimplementedTradingServiceServer) BatchCancelOrders(context.Context, *BatchCancelOrdersRequest) (*BatchCancelOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCancelOrders not implemented")
}
func (UnimplementedTradingServiceServer) GetOrder(context.Context, *GetOrderRequest) (*Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOrder not implemented")
}
func (UnimplementedTradingServiceServer) ListOrders(context.Context, *ListOrdersRequest) (*ListOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOrders not implemented")
}
func (UnimplementedTradingServiceServer) ListOpenOrders(context.Context, *ListOpenOrdersRequest) (*ListOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOpenOrders not implemented")
}
func (UnimplementedTradingServiceServer) GetBalance(context.Context, *GetBalanceRequest) (*Balance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalance not implemented")
}
func (UnimplementedTradingServiceServer) GetBalances(context.Context, *GetBalancesRequest) (*GetBalancesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalances not implemented")
}
func (UnimplementedTradingServiceServer) GetBalanceLogs(context.Context, *GetBalanceLogsRequest) (*GetBalanceLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalanceLogs not implemented")
}
func (UnimplementedTradingServiceServer) GetTrade(context.Context, *GetTradeRequest) (*Trade, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrade not implemented")
}
func (UnimplementedTradingServiceServer) ListTrades(context.Context, *ListTradesRequest) (*ListTradesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTrades not implemented")
}
func (UnimplementedTradingServiceServer) ListTradesByOrder(context.Context, *ListTradesByOrderRequest) (*ListTradesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTradesByOrder not implemented")
}
func (UnimplementedTradingServiceServer) GetDeposit(context.Context, *GetDepositRequest) (*Deposit, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeposit not implemented")
}
func (UnimplementedTradingServiceServer) ListDeposits(context.Context, *ListDepositsRequest) (*ListDepositsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDeposits not implemented")
}
func (UnimplementedTradingServiceServer) CreateWithdrawal(context.Context, *CreateWithdrawalRequest) (*CreateWithdrawalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWithdrawal not implemented")
}
func (UnimplementedTradingServiceServer) CancelWithdrawal(context.Context, *CancelWithdrawalRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelWithdrawal not implemented")
}
func (UnimplementedTradingServiceServer) GetWithdrawal(context.Context, *GetWithdrawalRequest) (*Withdrawal, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWithdrawal not implemented")
}
func (UnimplementedTradingServiceServer) ListWithdrawals(context.Context, *ListWithdrawalsRequest) (*ListWithdrawalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWithdrawals not implemented")
}
func (UnimplementedTradingServiceServer) ProcessTradeResult(context.Context, *ProcessTradeResultRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessTradeResult not implemented")
}
func (UnimplementedTradingServiceServer) ProcessDepositEvent(context.Context, *ProcessDepositEventRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessDepositEvent not implemented")
}
func (UnimplementedTradingServiceServer) ConfirmSettlement(context.Context, *ConfirmSettlementRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmSettlement not implemented")
}
func (UnimplementedTradingServiceServer) RollbackSettlement(context.Context, *RollbackSettlementRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RollbackSettlement not implemented")
}
func (UnimplementedTradingServiceServer) mustEmbedUnimplementedTradingServiceServer() {}
func (UnimplementedTradingServiceServer) testEmbeddedByValue()                        {}

// UnsafeTradingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TradingServiceServer will
// result in compilation errors.
type UnsafeTradingServiceServer interface {
	mustEmbedUnimplementedTradingServiceServer()
}

func RegisterTradingServiceServer(s grpc.ServiceRegistrar, srv TradingServiceServer) {
	// If the following call pancis, it indicates UnimplementedTradingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TradingService_ServiceDesc, srv)
}

func _TradingService_PrepareOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).PrepareOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_PrepareOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).PrepareOrder(ctx, req.(*PrepareOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_CreateOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).CreateOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_CreateOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).CreateOrder(ctx, req.(*CreateOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_CancelOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).CancelOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_CancelOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).CancelOrder(ctx, req.(*CancelOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_BatchCancelOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCancelOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).BatchCancelOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_BatchCancelOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).BatchCancelOrders(ctx, req.(*BatchCancelOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_GetOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).GetOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_GetOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).GetOrder(ctx, req.(*GetOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_ListOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).ListOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_ListOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).ListOrders(ctx, req.(*ListOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_ListOpenOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOpenOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).ListOpenOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_ListOpenOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).ListOpenOrders(ctx, req.(*ListOpenOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_GetBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).GetBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_GetBalance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).GetBalance(ctx, req.(*GetBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_GetBalances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBalancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).GetBalances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_GetBalances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).GetBalances(ctx, req.(*GetBalancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_GetBalanceLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBalanceLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).GetBalanceLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_GetBalanceLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).GetBalanceLogs(ctx, req.(*GetBalanceLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_GetTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).GetTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_GetTrade_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).GetTrade(ctx, req.(*GetTradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_ListTrades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTradesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).ListTrades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_ListTrades_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).ListTrades(ctx, req.(*ListTradesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_ListTradesByOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTradesByOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).ListTradesByOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_ListTradesByOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).ListTradesByOrder(ctx, req.(*ListTradesByOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_GetDeposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDepositRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).GetDeposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_GetDeposit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).GetDeposit(ctx, req.(*GetDepositRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_ListDeposits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDepositsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).ListDeposits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_ListDeposits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).ListDeposits(ctx, req.(*ListDepositsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_CreateWithdrawal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateWithdrawalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).CreateWithdrawal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_CreateWithdrawal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).CreateWithdrawal(ctx, req.(*CreateWithdrawalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_CancelWithdrawal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelWithdrawalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).CancelWithdrawal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_CancelWithdrawal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).CancelWithdrawal(ctx, req.(*CancelWithdrawalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_GetWithdrawal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWithdrawalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).GetWithdrawal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_GetWithdrawal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).GetWithdrawal(ctx, req.(*GetWithdrawalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_ListWithdrawals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWithdrawalsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).ListWithdrawals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_ListWithdrawals_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).ListWithdrawals(ctx, req.(*ListWithdrawalsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_ProcessTradeResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessTradeResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).ProcessTradeResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_ProcessTradeResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).ProcessTradeResult(ctx, req.(*ProcessTradeResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_ProcessDepositEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessDepositEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).ProcessDepositEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_ProcessDepositEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).ProcessDepositEvent(ctx, req.(*ProcessDepositEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_ConfirmSettlement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfirmSettlementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).ConfirmSettlement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_ConfirmSettlement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).ConfirmSettlement(ctx, req.(*ConfirmSettlementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_RollbackSettlement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RollbackSettlementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).RollbackSettlement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_RollbackSettlement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).RollbackSettlement(ctx, req.(*RollbackSettlementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TradingService_ServiceDesc is the grpc.ServiceDesc for TradingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TradingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "eidos.trading.v1.TradingService",
	HandlerType: (*TradingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PrepareOrder",
			Handler:    _TradingService_PrepareOrder_Handler,
		},
		{
			MethodName: "CreateOrder",
			Handler:    _TradingService_CreateOrder_Handler,
		},
		{
			MethodName: "CancelOrder",
			Handler:    _TradingService_CancelOrder_Handler,
		},
		{
			MethodName: "BatchCancelOrders",
			Handler:    _TradingService_BatchCancelOrders_Handler,
		},
		{
			MethodName: "GetOrder",
			Handler:    _TradingService_GetOrder_Handler,
		},
		{
			MethodName: "ListOrders",
			Handler:    _TradingService_ListOrders_Handler,
		},
		{
			MethodName: "ListOpenOrders",
			Handler:    _TradingService_ListOpenOrders_Handler,
		},
		{
			MethodName: "GetBalance",
			Handler:    _TradingService_GetBalance_Handler,
		},
		{
			MethodName: "GetBalances",
			Handler:    _TradingService_GetBalances_Handler,
		},
		{
			MethodName: "GetBalanceLogs",
			Handler:    _TradingService_GetBalanceLogs_Handler,
		},
		{
			MethodName: "GetTrade",
			Handler:    _TradingService_GetTrade_Handler,
		},
		{
			MethodName: "ListTrades",
			Handler:    _TradingService_ListTrades_Handler,
		},
		{
			MethodName: "ListTradesByOrder",
			Handler:    _TradingService_ListTradesByOrder_Handler,
		},
		{
			MethodName: "GetDeposit",
			Handler:    _TradingService_GetDeposit_Handler,
		},
		{
			MethodName: "ListDeposits",
			Handler:    _TradingService_ListDeposits_Handler,
		},
		{
			MethodName: "CreateWithdrawal",
			Handler:    _TradingService_CreateWithdrawal_Handler,
		},
		{
			MethodName: "CancelWithdrawal",
			Handler:    _TradingService_CancelWithdrawal_Handler,
		},
		{
			MethodName: "GetWithdrawal",
			Handler:    _TradingService_GetWithdrawal_Handler,
		},
		{
			MethodName: "ListWithdrawals",
			Handler:    _TradingService_ListWithdrawals_Handler,
		},
		{
			MethodName: "ProcessTradeResult",
			Handler:    _TradingService_ProcessTradeResult_Handler,
		},
		{
			MethodName: "ProcessDepositEvent",
			Handler:    _TradingService_ProcessDepositEvent_Handler,
		},
		{
			MethodName: "ConfirmSettlement",
			Handler:    _TradingService_ConfirmSettlement_Handler,
		},
		{
			MethodName: "RollbackSettlement",
			Handler:    _TradingService_RollbackSettlement_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "trading/v1/trading.proto",
}

const (
	SubAccountService_CreateSubAccount_FullMethodName         = "/eidos.trading.v1.SubAccountService/CreateSubAccount"
	SubAccountService_GetSubAccount_FullMethodName            = "/eidos.trading.v1.SubAccountService/GetSubAccount"
	SubAccountService_ListSubAccounts_FullMethodName          = "/eidos.trading.v1.SubAccountService/ListSubAccounts"
	SubAccountService_UpdateSubAccount_FullMethodName         = "/eidos.trading.v1.SubAccountService/UpdateSubAccount"
	SubAccountService_DeleteSubAccount_FullMethodName         = "/eidos.trading.v1.SubAccountService/DeleteSubAccount"
	SubAccountService_FreezeSubAccount_FullMethodName         = "/eidos.trading.v1.SubAccountService/FreezeSubAccount"
	SubAccountService_UnfreezeSubAccount_FullMethodName       = "/eidos.trading.v1.SubAccountService/UnfreezeSubAccount"
	SubAccountService_SetDefaultSubAccount_FullMethodName     = "/eidos.trading.v1.SubAccountService/SetDefaultSubAccount"
	SubAccountService_GetSubAccountBalance_FullMethodName     = "/eidos.trading.v1.SubAccountService/GetSubAccountBalance"
	SubAccountService_GetSubAccountBalances_FullMethodName    = "/eidos.trading.v1.SubAccountService/GetSubAccountBalances"
	SubAccountService_GetAllSubAccountBalances_FullMethodName = "/eidos.trading.v1.SubAccountService/GetAllSubAccountBalances"
	SubAccountService_TransferIn_FullMethodName               = "/eidos.trading.v1.SubAccountService/TransferIn"
	SubAccountService_TransferOut_FullMethodName              = "/eidos.trading.v1.SubAccountService/TransferOut"
	SubAccountService_GetTransferHistory_FullMethodName       = "/eidos.trading.v1.SubAccountService/GetTransferHistory"
)

// SubAccountServiceClient is the client API for SubAccountService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// SubAccountService 提供子账户管理功能
// 一个钱包可以创建多个独立的交易子账户
type SubAccountServiceClient interface {
	// CreateSubAccount 创建子账户
	CreateSubAccount(ctx context.Context, in *CreateSubAccountRequest, opts ...grpc.CallOption) (*CreateSubAccountResponse, error)
	// GetSubAccount 获取子账户详情
	GetSubAccount(ctx context.Context, in *GetSubAccountRequest, opts ...grpc.CallOption) (*SubAccount, error)
	// ListSubAccounts 获取钱包下所有子账户
	ListSubAccounts(ctx context.Context, in *ListSubAccountsRequest, opts ...grpc.CallOption) (*ListSubAccountsResponse, error)
	// UpdateSubAccount 更新子账户 (名称、备注)
	UpdateSubAccount(ctx context.Context, in *UpdateSubAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteSubAccount 删除子账户
	DeleteSubAccount(ctx context.Context, in *DeleteSubAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// FreezeSubAccount 冻结子账户
	FreezeSubAccount(ctx context.Context, in *FreezeSubAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UnfreezeSubAccount 解冻子账户
	UnfreezeSubAccount(ctx context.Context, in *UnfreezeSubAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SetDefaultSubAccount 设置默认子账户
	SetDefaultSubAccount(ctx context.Context, in *SetDefaultSubAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetSubAccountBalance 获取子账户单个代币余额
	GetSubAccountBalance(ctx context.Context, in *GetSubAccountBalanceRequest, opts ...grpc.CallOption) (*SubAccountBalance, error)
	// GetSubAccountBalances 获取子账户所有余额
	GetSubAccountBalances(ctx context.Context, in *GetSubAccountBalancesRequest, opts ...grpc.CallOption) (*GetSubAccountBalancesResponse, error)
	// GetAllSubAccountBalances 获取钱包下所有子账户余额
	GetAllSubAccountBalances(ctx context.Context, in *GetAllSubAccountBalancesRequest, opts ...grpc.CallOption) (*GetSubAccountBalancesResponse, error)
	// TransferIn 划入子账户 (主账户 → 子账户)
	TransferIn(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (*TransferResponse, error)
	// TransferOut 划出子账户 (子账户 → 主账户)
	TransferOut(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (*TransferResponse, error)
	// GetTransferHistory 获取划转历史
	GetTransferHistory(ctx context.Context, in *GetTransferHistoryRequest, opts ...grpc.CallOption) (*GetTransferHistoryResponse, error)
}

type subAccountServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSubAccountServiceClient(cc grpc.ClientConnInterface) SubAccountServiceClient {
	return &subAccountServiceClient{cc}
}

func (c *subAccountServiceClient) CreateSubAccount(ctx context.Context, in *CreateSubAccountRequest, opts ...grpc.CallOption) (*CreateSubAccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateSubAccountResponse)
	err := c.cc.Invoke(ctx, SubAccountService_CreateSubAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subAccountServiceClient) GetSubAccount(ctx context.Context, in *GetSubAccountRequest, opts ...grpc.CallOption) (*SubAccount, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubAccount)
	err := c.cc.Invoke(ctx, SubAccountService_GetSubAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subAccountServiceClient) ListSubAccounts(ctx context.Context, in *ListSubAccountsRequest, opts ...grpc.CallOption) (*ListSubAccountsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSubAccountsResponse)
	err := c.cc.Invoke(ctx, SubAccountService_ListSubAccounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subAccountServiceClient) UpdateSubAccount(ctx context.Context, in *UpdateSubAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SubAccountService_UpdateSubAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subAccountServiceClient) DeleteSubAccount(ctx context.Context, in *DeleteSubAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SubAccountService_DeleteSubAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subAccountServiceClient) FreezeSubAccount(ctx context.Context, in *FreezeSubAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SubAccountService_FreezeSubAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subAccountServiceClient) UnfreezeSubAccount(ctx context.Context, in *UnfreezeSubAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SubAccountService_UnfreezeSubAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subAccountServiceClient) SetDefaultSubAccount(ctx context.Context, in *SetDefaultSubAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SubAccountService_SetDefaultSubAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subAccountServiceClient) GetSubAccountBalance(ctx context.Context, in *GetSubAccountBalanceRequest, opts ...grpc.CallOption) (*SubAccountBalance, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubAccountBalance)
	err := c.cc.Invoke(ctx, SubAccountService_GetSubAccountBalance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subAccountServiceClient) GetSubAccountBalances(ctx context.Context, in *GetSubAccountBalancesRequest, opts ...grpc.CallOption) (*GetSubAccountBalancesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSubAccountBalancesResponse)
	err := c.cc.Invoke(ctx, SubAccountService_GetSubAccountBalances_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subAccountServiceClient) GetAllSubAccountBalances(ctx context.Context, in *GetAllSubAccountBalancesRequest, opts ...grpc.CallOption) (*GetSubAccountBalancesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSubAccountBalancesResponse)
	err := c.cc.Invoke(ctx, SubAccountService_GetAllSubAccountBalances_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subAccountServiceClient) TransferIn(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (*TransferResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransferResponse)
	err := c.cc.Invoke(ctx, SubAccountService_TransferIn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subAccountServiceClient) TransferOut(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (*TransferResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransferResponse)
	err := c.cc.Invoke(ctx, SubAccountService_TransferOut_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subAccountServiceClient) GetTransferHistory(ctx context.Context, in *GetTransferHistoryRequest, opts ...grpc.CallOption) (*GetTransferHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTransferHistoryResponse)
	err := c.cc.Invoke(ctx, SubAccountService_GetTransferHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SubAccountServiceServer is the server API for SubAccountService service.
// All implementations must embed UnimplementedSubAccountServiceServer
// for forward compatibility.
//
// SubAccountService 提供子账户管理功能
// 一个钱包可以创建多个独立的交易子账户
type SubAccountServiceServer interface {
	// CreateSubAccount 创建子账户
	CreateSubAccount(context.Context, *CreateSubAccountRequest) (*CreateSubAccountResponse, error)
	// GetSubAccount 获取子账户详情
	GetSubAccount(context.Context, *GetSubAccountRequest) (*SubAccount, error)
	// ListSubAccounts 获取钱包下所有子账户
	ListSubAccounts(context.Context, *ListSubAccountsRequest) (*ListSubAccountsResponse, error)
	// UpdateSubAccount 更新子账户 (名称、备注)
	UpdateSubAccount(context.Context, *UpdateSubAccountRequest) (*emptypb.Empty, error)
	// DeleteSubAccount 删除子账户
	DeleteSubAccount(context.Context, *DeleteSubAccountRequest) (*emptypb.Empty, error)
	// FreezeSubAccount 冻结子账户
	FreezeSubAccount(context.Context, *FreezeSubAccountRequest) (*emptypb.Empty, error)
	// UnfreezeSubAccount 解冻子账户
	UnfreezeSubAccount(context.Context, *UnfreezeSubAccountRequest) (*emptypb.Empty, error)
	// SetDefaultSubAccount 设置默认子账户
	SetDefaultSubAccount(context.Context, *SetDefaultSubAccountRequest) (*emptypb.Empty, error)
	// GetSubAccountBalance 获取子账户单个代币余额
	GetSubAccountBalance(context.Context, *GetSubAccountBalanceRequest) (*SubAccountBalance, error)
	// GetSubAccountBalances 获取子账户所有余额
	GetSubAccountBalances(context.Context, *GetSubAccountBalancesRequest) (*GetSubAccountBalancesResponse, error)
	// GetAllSubAccountBalances 获取钱包下所有子账户余额
	GetAllSubAccountBalances(context.Context, *GetAllSubAccountBalancesRequest) (*GetSubAccountBalancesResponse, error)
	// TransferIn 划入子账户 (主账户 → 子账户)
	TransferIn(context.Context, *TransferRequest) (*TransferResponse, error)
	// TransferOut 划出子账户 (子账户 → 主账户)
	TransferOut(context.Context, *TransferRequest) (*TransferResponse, error)
	// GetTransferHistory 获取划转历史
	GetTransferHistory(context.Context, *GetTransferHistoryRequest) (*GetTransferHistoryResponse, error)
	mustEmbedUnimplementedSubAccountServiceServer()
}

// UnimplementedSubAccountServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSubAccountServiceServer struct{}

func (UnimplementedSubAccountServiceServer) CreateSubAccount(context.Context, *CreateSubAccountRequest) (*CreateSubAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSubAccount not implemented")
}
func (UnimplementedSubAccountServiceServer) GetSubAccount(context.Context, *GetSubAccountRequest) (*SubAccount, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubAccount not implemented")
}
func (UnimplementedSubAccountServiceServer) ListSubAccounts(context.Context, *ListSubAccountsRequest) (*ListSubAccountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSubAccounts not implemented")
}
func (UnimplementedSubAccountServiceServer) UpdateSubAccount(context.Context, *UpdateSubAccountRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSubAccount not implemented")
}
func (UnimplementedSubAccountServiceServer) DeleteSubAccount(context.Context, *DeleteSubAccountRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSubAccount not implemented")
}
func (UnimplementedSubAccountServiceServer) FreezeSubAccount(context.Context, *FreezeSubAccountRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FreezeSubAccount not implemented")
}
func (UnimplementedSubAccountServiceServer) UnfreezeSubAccount(context.Context, *UnfreezeSubAccountRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnfreezeSubAccount not implemented")
}
func (UnimplementedSubAccountServiceServer) SetDefaultSubAccount(context.Context, *SetDefaultSubAccountRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDefaultSubAccount not implemented")
}
func (UnimplementedSubAccountServiceServer) GetSubAccountBalance(context.Context, *GetSubAccountBalanceRequest) (*SubAccountBalance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubAccountBalance not implemented")
}
func (UnimplementedSubAccountServiceServer) GetSubAccountBalances(context.Context, *GetSubAccountBalancesRequest) (*GetSubAccountBalancesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubAccountBalances not implemented")
}
func (UnimplementedSubAccountServiceServer) GetAllSubAccountBalances(context.Context, *GetAllSubAccountBalancesRequest) (*GetSubAccountBalancesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllSubAccountBalances not implemented")
}
func (UnimplementedSubAccountServiceServer) TransferIn(context.Context, *TransferRequest) (*TransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferIn not implemented")
}
func (UnimplementedSubAccountServiceServer) TransferOut(context.Context, *TransferRequest) (*TransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferOut not implemented")
}
func (UnimplementedSubAccountServiceServer) GetTransferHistory(context.Context, *GetTransferHistoryRequest) (*GetTransferHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransferHistory not implemented")
}
func (UnimplementedSubAccountServiceServer) mustEmbedUnimplementedSubAccountServiceServer() {}
func (UnimplementedSubAccountServiceServer) testEmbeddedByValue()                           {}

// UnsafeSubAccountServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SubAccountServiceServer will
// result in compilation errors.
type UnsafeSubAccountServiceServer interface {
	mustEmbedUnimplementedSubAccountServiceServer()
}

func RegisterSubAccountServiceServer(s grpc.ServiceRegistrar, srv SubAccountServiceServer) {
	// If the following call pancis, it indicates UnimplementedSubAccountServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SubAccountService_ServiceDesc, srv)
}

func _SubAccountService_CreateSubAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSubAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubAccountServiceServer).CreateSubAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubAccountService_CreateSubAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubAccountServiceServer).CreateSubAccount(ctx, req.(*CreateSubAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubAccountService_GetSubAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubAccountServiceServer).GetSubAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubAccountService_GetSubAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubAccountServiceServer).GetSubAccount(ctx, req.(*GetSubAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubAccountService_ListSubAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSubAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubAccountServiceServer).ListSubAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubAccountService_ListSubAccounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubAccountServiceServer).ListSubAccounts(ctx, req.(*ListSubAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubAccountService_UpdateSubAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSubAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubAccountServiceServer).UpdateSubAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubAccountService_UpdateSubAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubAccountServiceServer).UpdateSubAccount(ctx, req.(*UpdateSubAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubAccountService_DeleteSubAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSubAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubAccountServiceServer).DeleteSubAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubAccountService_DeleteSubAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubAccountServiceServer).DeleteSubAccount(ctx, req.(*DeleteSubAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubAccountService_FreezeSubAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FreezeSubAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubAccountServiceServer).FreezeSubAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubAccountService_FreezeSubAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubAccountServiceServer).FreezeSubAccount(ctx, req.(*FreezeSubAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubAccountService_UnfreezeSubAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnfreezeSubAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubAccountServiceServer).UnfreezeSubAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubAccountService_UnfreezeSubAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubAccountServiceServer).UnfreezeSubAccount(ctx, req.(*UnfreezeSubAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubAccountService_SetDefaultSubAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDefaultSubAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubAccountServiceServer).SetDefaultSubAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubAccountService_SetDefaultSubAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubAccountServiceServer).SetDefaultSubAccount(ctx, req.(*SetDefaultSubAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubAccountService_GetSubAccountBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubAccountBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubAccountServiceServer).GetSubAccountBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubAccountService_GetSubAccountBalance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubAccountServiceServer).GetSubAccountBalance(ctx, req.(*GetSubAccountBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubAccountService_GetSubAccountBalances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubAccountBalancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubAccountServiceServer).GetSubAccountBalances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubAccountService_GetSubAccountBalances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubAccountServiceServer).GetSubAccountBalances(ctx, req.(*GetSubAccountBalancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubAccountService_GetAllSubAccountBalances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllSubAccountBalancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubAccountServiceServer).GetAllSubAccountBalances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubAccountService_GetAllSubAccountBalances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubAccountServiceServer).GetAllSubAccountBalances(ctx, req.(*GetAllSubAccountBalancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubAccountService_TransferIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubAccountServiceServer).TransferIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubAccountService_TransferIn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubAccountServiceServer).TransferIn(ctx, req.(*TransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubAccountService_TransferOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubAccountServiceServer).TransferOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubAccountService_TransferOut_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubAccountServiceServer).TransferOut(ctx, req.(*TransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubAccountService_GetTransferHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransferHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubAccountServiceServer).GetTransferHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubAccountService_GetTransferHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubAccountServiceServer).GetTransferHistory(ctx, req.(*GetTransferHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SubAccountService_ServiceDesc is the grpc.ServiceDesc for SubAccountService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SubAccountService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "eidos.trading.v1.SubAccountService",
	HandlerType: (*SubAccountServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSubAccount",
			Handler:    _SubAccountService_CreateSubAccount_Handler,
		},
		{
			MethodName: "GetSubAccount",
			Handler:    _SubAccountService_GetSubAccount_Handler,
		},
		{
			MethodName: "ListSubAccounts",
			Handler:    _SubAccountService_ListSubAccounts_Handler,
		},
		{
			MethodName: "UpdateSubAccount",
			Handler:    _SubAccountService_UpdateSubAccount_Handler,
		},
		{
			MethodName: "DeleteSubAccount",
			Handler:    _SubAccountService_DeleteSubAccount_Handler,
		},
		{
			MethodName: "FreezeSubAccount",
			Handler:    _SubAccountService_FreezeSubAccount_Handler,
		},
		{
			MethodName: "UnfreezeSubAccount",
			Handler:    _SubAccountService_UnfreezeSubAccount_Handler,
		},
		{
			MethodName: "SetDefaultSubAccount",
			Handler:    _SubAccountService_SetDefaultSubAccount_Handler,
		},
		{
			MethodName: "GetSubAccountBalance",
			Handler:    _SubAccountService_GetSubAccountBalance_Handler,
		},
		{
			MethodName: "GetSubAccountBalances",
			Handler:    _SubAccountService_GetSubAccountBalances_Handler,
		},
		{
			MethodName: "GetAllSubAccountBalances",
			Handler:    _SubAccountService_GetAllSubAccountBalances_Handler,
		},
		{
			MethodName: "TransferIn",
			Handler:    _SubAccountService_TransferIn_Handler,
		},
		{
			MethodName: "TransferOut",
			Handler:    _SubAccountService_TransferOut_Handler,
		},
		{
			MethodName: "GetTransferHistory",
			Handler:    _SubAccountService_GetTransferHistory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "trading/v1/trading.proto",
}
