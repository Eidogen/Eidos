// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: trading/v1/trading.proto

package tradingv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	TradingService_PrepareOrder_FullMethodName        = "/eidos.trading.v1.TradingService/PrepareOrder"
	TradingService_CreateOrder_FullMethodName         = "/eidos.trading.v1.TradingService/CreateOrder"
	TradingService_CancelOrder_FullMethodName         = "/eidos.trading.v1.TradingService/CancelOrder"
	TradingService_BatchCancelOrders_FullMethodName   = "/eidos.trading.v1.TradingService/BatchCancelOrders"
	TradingService_GetOrder_FullMethodName            = "/eidos.trading.v1.TradingService/GetOrder"
	TradingService_ListOrders_FullMethodName          = "/eidos.trading.v1.TradingService/ListOrders"
	TradingService_ListOpenOrders_FullMethodName      = "/eidos.trading.v1.TradingService/ListOpenOrders"
	TradingService_GetBalance_FullMethodName          = "/eidos.trading.v1.TradingService/GetBalance"
	TradingService_GetBalances_FullMethodName         = "/eidos.trading.v1.TradingService/GetBalances"
	TradingService_GetBalanceLogs_FullMethodName      = "/eidos.trading.v1.TradingService/GetBalanceLogs"
	TradingService_GetTrade_FullMethodName            = "/eidos.trading.v1.TradingService/GetTrade"
	TradingService_ListTrades_FullMethodName          = "/eidos.trading.v1.TradingService/ListTrades"
	TradingService_ListTradesByOrder_FullMethodName   = "/eidos.trading.v1.TradingService/ListTradesByOrder"
	TradingService_GetDeposit_FullMethodName          = "/eidos.trading.v1.TradingService/GetDeposit"
	TradingService_ListDeposits_FullMethodName        = "/eidos.trading.v1.TradingService/ListDeposits"
	TradingService_CreateWithdrawal_FullMethodName    = "/eidos.trading.v1.TradingService/CreateWithdrawal"
	TradingService_CancelWithdrawal_FullMethodName    = "/eidos.trading.v1.TradingService/CancelWithdrawal"
	TradingService_GetWithdrawal_FullMethodName       = "/eidos.trading.v1.TradingService/GetWithdrawal"
	TradingService_ListWithdrawals_FullMethodName     = "/eidos.trading.v1.TradingService/ListWithdrawals"
	TradingService_ProcessTradeResult_FullMethodName  = "/eidos.trading.v1.TradingService/ProcessTradeResult"
	TradingService_ProcessDepositEvent_FullMethodName = "/eidos.trading.v1.TradingService/ProcessDepositEvent"
	TradingService_ConfirmSettlement_FullMethodName   = "/eidos.trading.v1.TradingService/ConfirmSettlement"
	TradingService_RollbackSettlement_FullMethodName  = "/eidos.trading.v1.TradingService/RollbackSettlement"
)

// TradingServiceClient is the client API for TradingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// TradingService provides the core trading functionality including:
// - Order management (create, cancel, query)
// - Balance management (query, freeze/unfreeze)
// - Trade history
// - Deposit/Withdrawal operations
type TradingServiceClient interface {
	// PrepareOrder prepares an order for signing
	// Returns EIP-712 typed data for client to sign
	PrepareOrder(ctx context.Context, in *PrepareOrderRequest, opts ...grpc.CallOption) (*PrepareOrderResponse, error)
	// CreateOrder creates a new order (limit or market)
	// Returns the created order with initial status
	CreateOrder(ctx context.Context, in *CreateOrderRequest, opts ...grpc.CallOption) (*CreateOrderResponse, error)
	// CancelOrder cancels an active order
	// Only orders with status OPEN or PARTIAL can be cancelled
	CancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// BatchCancelOrders cancels multiple orders at once
	// Supports filtering by market and side
	BatchCancelOrders(ctx context.Context, in *BatchCancelOrdersRequest, opts ...grpc.CallOption) (*BatchCancelOrdersResponse, error)
	// GetOrder retrieves order details by order ID
	GetOrder(ctx context.Context, in *GetOrderRequest, opts ...grpc.CallOption) (*Order, error)
	// ListOrders retrieves orders with optional filters
	ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error)
	// ListOpenOrders retrieves all active orders for a wallet
	ListOpenOrders(ctx context.Context, in *ListOpenOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error)
	// GetBalance retrieves balance for a specific token
	GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*Balance, error)
	// GetBalances retrieves all token balances for a wallet
	GetBalances(ctx context.Context, in *GetBalancesRequest, opts ...grpc.CallOption) (*GetBalancesResponse, error)
	// GetBalanceLogs retrieves balance change history
	GetBalanceLogs(ctx context.Context, in *GetBalanceLogsRequest, opts ...grpc.CallOption) (*GetBalanceLogsResponse, error)
	// GetTrade retrieves trade details by trade ID
	GetTrade(ctx context.Context, in *GetTradeRequest, opts ...grpc.CallOption) (*Trade, error)
	// ListTrades retrieves trade history with optional filters
	ListTrades(ctx context.Context, in *ListTradesRequest, opts ...grpc.CallOption) (*ListTradesResponse, error)
	// ListTradesByOrder retrieves all trades for a specific order
	ListTradesByOrder(ctx context.Context, in *ListTradesByOrderRequest, opts ...grpc.CallOption) (*ListTradesResponse, error)
	// GetDeposit retrieves deposit details by deposit ID
	GetDeposit(ctx context.Context, in *GetDepositRequest, opts ...grpc.CallOption) (*Deposit, error)
	// ListDeposits retrieves deposit history with optional filters
	ListDeposits(ctx context.Context, in *ListDepositsRequest, opts ...grpc.CallOption) (*ListDepositsResponse, error)
	// CreateWithdrawal creates a new withdrawal request
	// Requires sufficient available balance
	CreateWithdrawal(ctx context.Context, in *CreateWithdrawalRequest, opts ...grpc.CallOption) (*CreateWithdrawalResponse, error)
	// CancelWithdrawal cancels a pending withdrawal
	// Only withdrawals with status PENDING can be cancelled
	CancelWithdrawal(ctx context.Context, in *CancelWithdrawalRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetWithdrawal retrieves withdrawal details by withdrawal ID
	GetWithdrawal(ctx context.Context, in *GetWithdrawalRequest, opts ...grpc.CallOption) (*Withdrawal, error)
	// ListWithdrawals retrieves withdrawal history with optional filters
	ListWithdrawals(ctx context.Context, in *ListWithdrawalsRequest, opts ...grpc.CallOption) (*ListWithdrawalsResponse, error)
	// ProcessTradeResult processes a trade result from matching engine
	// Called by Settlement Service after trade matching
	ProcessTradeResult(ctx context.Context, in *ProcessTradeResultRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ProcessDepositEvent processes a deposit event from chain indexer
	// Called by Chain Service when deposit is detected
	ProcessDepositEvent(ctx context.Context, in *ProcessDepositEventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ConfirmSettlement confirms on-chain settlement of trades
	// Called by Chain Service when settlement tx is confirmed
	ConfirmSettlement(ctx context.Context, in *ConfirmSettlementRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// RollbackSettlement rolls back a failed settlement
	// Called when on-chain settlement fails
	RollbackSettlement(ctx context.Context, in *RollbackSettlementRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type tradingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTradingServiceClient(cc grpc.ClientConnInterface) TradingServiceClient {
	return &tradingServiceClient{cc}
}

func (c *tradingServiceClient) PrepareOrder(ctx context.Context, in *PrepareOrderRequest, opts ...grpc.CallOption) (*PrepareOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PrepareOrderResponse)
	err := c.cc.Invoke(ctx, TradingService_PrepareOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) CreateOrder(ctx context.Context, in *CreateOrderRequest, opts ...grpc.CallOption) (*CreateOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateOrderResponse)
	err := c.cc.Invoke(ctx, TradingService_CreateOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) CancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TradingService_CancelOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) BatchCancelOrders(ctx context.Context, in *BatchCancelOrdersRequest, opts ...grpc.CallOption) (*BatchCancelOrdersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchCancelOrdersResponse)
	err := c.cc.Invoke(ctx, TradingService_BatchCancelOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) GetOrder(ctx context.Context, in *GetOrderRequest, opts ...grpc.CallOption) (*Order, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Order)
	err := c.cc.Invoke(ctx, TradingService_GetOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListOrdersResponse)
	err := c.cc.Invoke(ctx, TradingService_ListOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) ListOpenOrders(ctx context.Context, in *ListOpenOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListOrdersResponse)
	err := c.cc.Invoke(ctx, TradingService_ListOpenOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*Balance, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Balance)
	err := c.cc.Invoke(ctx, TradingService_GetBalance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) GetBalances(ctx context.Context, in *GetBalancesRequest, opts ...grpc.CallOption) (*GetBalancesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBalancesResponse)
	err := c.cc.Invoke(ctx, TradingService_GetBalances_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) GetBalanceLogs(ctx context.Context, in *GetBalanceLogsRequest, opts ...grpc.CallOption) (*GetBalanceLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBalanceLogsResponse)
	err := c.cc.Invoke(ctx, TradingService_GetBalanceLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) GetTrade(ctx context.Context, in *GetTradeRequest, opts ...grpc.CallOption) (*Trade, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Trade)
	err := c.cc.Invoke(ctx, TradingService_GetTrade_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) ListTrades(ctx context.Context, in *ListTradesRequest, opts ...grpc.CallOption) (*ListTradesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTradesResponse)
	err := c.cc.Invoke(ctx, TradingService_ListTrades_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) ListTradesByOrder(ctx context.Context, in *ListTradesByOrderRequest, opts ...grpc.CallOption) (*ListTradesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTradesResponse)
	err := c.cc.Invoke(ctx, TradingService_ListTradesByOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) GetDeposit(ctx context.Context, in *GetDepositRequest, opts ...grpc.CallOption) (*Deposit, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Deposit)
	err := c.cc.Invoke(ctx, TradingService_GetDeposit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) ListDeposits(ctx context.Context, in *ListDepositsRequest, opts ...grpc.CallOption) (*ListDepositsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDepositsResponse)
	err := c.cc.Invoke(ctx, TradingService_ListDeposits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) CreateWithdrawal(ctx context.Context, in *CreateWithdrawalRequest, opts ...grpc.CallOption) (*CreateWithdrawalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateWithdrawalResponse)
	err := c.cc.Invoke(ctx, TradingService_CreateWithdrawal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) CancelWithdrawal(ctx context.Context, in *CancelWithdrawalRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TradingService_CancelWithdrawal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) GetWithdrawal(ctx context.Context, in *GetWithdrawalRequest, opts ...grpc.CallOption) (*Withdrawal, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Withdrawal)
	err := c.cc.Invoke(ctx, TradingService_GetWithdrawal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) ListWithdrawals(ctx context.Context, in *ListWithdrawalsRequest, opts ...grpc.CallOption) (*ListWithdrawalsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListWithdrawalsResponse)
	err := c.cc.Invoke(ctx, TradingService_ListWithdrawals_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) ProcessTradeResult(ctx context.Context, in *ProcessTradeResultRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TradingService_ProcessTradeResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) ProcessDepositEvent(ctx context.Context, in *ProcessDepositEventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TradingService_ProcessDepositEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) ConfirmSettlement(ctx context.Context, in *ConfirmSettlementRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TradingService_ConfirmSettlement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingServiceClient) RollbackSettlement(ctx context.Context, in *RollbackSettlementRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TradingService_RollbackSettlement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TradingServiceServer is the server API for TradingService service.
// All implementations must embed UnimplementedTradingServiceServer
// for forward compatibility.
//
// TradingService provides the core trading functionality including:
// - Order management (create, cancel, query)
// - Balance management (query, freeze/unfreeze)
// - Trade history
// - Deposit/Withdrawal operations
type TradingServiceServer interface {
	// PrepareOrder prepares an order for signing
	// Returns EIP-712 typed data for client to sign
	PrepareOrder(context.Context, *PrepareOrderRequest) (*PrepareOrderResponse, error)
	// CreateOrder creates a new order (limit or market)
	// Returns the created order with initial status
	CreateOrder(context.Context, *CreateOrderRequest) (*CreateOrderResponse, error)
	// CancelOrder cancels an active order
	// Only orders with status OPEN or PARTIAL can be cancelled
	CancelOrder(context.Context, *CancelOrderRequest) (*emptypb.Empty, error)
	// BatchCancelOrders cancels multiple orders at once
	// Supports filtering by market and side
	BatchCancelOrders(context.Context, *BatchCancelOrdersRequest) (*BatchCancelOrdersResponse, error)
	// GetOrder retrieves order details by order ID
	GetOrder(context.Context, *GetOrderRequest) (*Order, error)
	// ListOrders retrieves orders with optional filters
	ListOrders(context.Context, *ListOrdersRequest) (*ListOrdersResponse, error)
	// ListOpenOrders retrieves all active orders for a wallet
	ListOpenOrders(context.Context, *ListOpenOrdersRequest) (*ListOrdersResponse, error)
	// GetBalance retrieves balance for a specific token
	GetBalance(context.Context, *GetBalanceRequest) (*Balance, error)
	// GetBalances retrieves all token balances for a wallet
	GetBalances(context.Context, *GetBalancesRequest) (*GetBalancesResponse, error)
	// GetBalanceLogs retrieves balance change history
	GetBalanceLogs(context.Context, *GetBalanceLogsRequest) (*GetBalanceLogsResponse, error)
	// GetTrade retrieves trade details by trade ID
	GetTrade(context.Context, *GetTradeRequest) (*Trade, error)
	// ListTrades retrieves trade history with optional filters
	ListTrades(context.Context, *ListTradesRequest) (*ListTradesResponse, error)
	// ListTradesByOrder retrieves all trades for a specific order
	ListTradesByOrder(context.Context, *ListTradesByOrderRequest) (*ListTradesResponse, error)
	// GetDeposit retrieves deposit details by deposit ID
	GetDeposit(context.Context, *GetDepositRequest) (*Deposit, error)
	// ListDeposits retrieves deposit history with optional filters
	ListDeposits(context.Context, *ListDepositsRequest) (*ListDepositsResponse, error)
	// CreateWithdrawal creates a new withdrawal request
	// Requires sufficient available balance
	CreateWithdrawal(context.Context, *CreateWithdrawalRequest) (*CreateWithdrawalResponse, error)
	// CancelWithdrawal cancels a pending withdrawal
	// Only withdrawals with status PENDING can be cancelled
	CancelWithdrawal(context.Context, *CancelWithdrawalRequest) (*emptypb.Empty, error)
	// GetWithdrawal retrieves withdrawal details by withdrawal ID
	GetWithdrawal(context.Context, *GetWithdrawalRequest) (*Withdrawal, error)
	// ListWithdrawals retrieves withdrawal history with optional filters
	ListWithdrawals(context.Context, *ListWithdrawalsRequest) (*ListWithdrawalsResponse, error)
	// ProcessTradeResult processes a trade result from matching engine
	// Called by Settlement Service after trade matching
	ProcessTradeResult(context.Context, *ProcessTradeResultRequest) (*emptypb.Empty, error)
	// ProcessDepositEvent processes a deposit event from chain indexer
	// Called by Chain Service when deposit is detected
	ProcessDepositEvent(context.Context, *ProcessDepositEventRequest) (*emptypb.Empty, error)
	// ConfirmSettlement confirms on-chain settlement of trades
	// Called by Chain Service when settlement tx is confirmed
	ConfirmSettlement(context.Context, *ConfirmSettlementRequest) (*emptypb.Empty, error)
	// RollbackSettlement rolls back a failed settlement
	// Called when on-chain settlement fails
	RollbackSettlement(context.Context, *RollbackSettlementRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedTradingServiceServer()
}

// UnimplementedTradingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTradingServiceServer struct{}

func (UnimplementedTradingServiceServer) PrepareOrder(context.Context, *PrepareOrderRequest) (*PrepareOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareOrder not implemented")
}
func (UnimplementedTradingServiceServer) CreateOrder(context.Context, *CreateOrderRequest) (*CreateOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrder not implemented")
}
func (UnimplementedTradingServiceServer) CancelOrder(context.Context, *CancelOrderRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelOrder not implemented")
}
func (UnimplementedTradingServiceServer) BatchCancelOrders(context.Context, *BatchCancelOrdersRequest) (*BatchCancelOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCancelOrders not implemented")
}
func (UnimplementedTradingServiceServer) GetOrder(context.Context, *GetOrderRequest) (*Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOrder not implemented")
}
func (UnimplementedTradingServiceServer) ListOrders(context.Context, *ListOrdersRequest) (*ListOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOrders not implemented")
}
func (UnimplementedTradingServiceServer) ListOpenOrders(context.Context, *ListOpenOrdersRequest) (*ListOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOpenOrders not implemented")
}
func (UnimplementedTradingServiceServer) GetBalance(context.Context, *GetBalanceRequest) (*Balance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalance not implemented")
}
func (UnimplementedTradingServiceServer) GetBalances(context.Context, *GetBalancesRequest) (*GetBalancesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalances not implemented")
}
func (UnimplementedTradingServiceServer) GetBalanceLogs(context.Context, *GetBalanceLogsRequest) (*GetBalanceLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalanceLogs not implemented")
}
func (UnimplementedTradingServiceServer) GetTrade(context.Context, *GetTradeRequest) (*Trade, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrade not implemented")
}
func (UnimplementedTradingServiceServer) ListTrades(context.Context, *ListTradesRequest) (*ListTradesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTrades not implemented")
}
func (UnimplementedTradingServiceServer) ListTradesByOrder(context.Context, *ListTradesByOrderRequest) (*ListTradesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTradesByOrder not implemented")
}
func (UnimplementedTradingServiceServer) GetDeposit(context.Context, *GetDepositRequest) (*Deposit, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeposit not implemented")
}
func (UnimplementedTradingServiceServer) ListDeposits(context.Context, *ListDepositsRequest) (*ListDepositsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDeposits not implemented")
}
func (UnimplementedTradingServiceServer) CreateWithdrawal(context.Context, *CreateWithdrawalRequest) (*CreateWithdrawalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWithdrawal not implemented")
}
func (UnimplementedTradingServiceServer) CancelWithdrawal(context.Context, *CancelWithdrawalRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelWithdrawal not implemented")
}
func (UnimplementedTradingServiceServer) GetWithdrawal(context.Context, *GetWithdrawalRequest) (*Withdrawal, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWithdrawal not implemented")
}
func (UnimplementedTradingServiceServer) ListWithdrawals(context.Context, *ListWithdrawalsRequest) (*ListWithdrawalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWithdrawals not implemented")
}
func (UnimplementedTradingServiceServer) ProcessTradeResult(context.Context, *ProcessTradeResultRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessTradeResult not implemented")
}
func (UnimplementedTradingServiceServer) ProcessDepositEvent(context.Context, *ProcessDepositEventRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessDepositEvent not implemented")
}
func (UnimplementedTradingServiceServer) ConfirmSettlement(context.Context, *ConfirmSettlementRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmSettlement not implemented")
}
func (UnimplementedTradingServiceServer) RollbackSettlement(context.Context, *RollbackSettlementRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RollbackSettlement not implemented")
}
func (UnimplementedTradingServiceServer) mustEmbedUnimplementedTradingServiceServer() {}
func (UnimplementedTradingServiceServer) testEmbeddedByValue()                        {}

// UnsafeTradingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TradingServiceServer will
// result in compilation errors.
type UnsafeTradingServiceServer interface {
	mustEmbedUnimplementedTradingServiceServer()
}

func RegisterTradingServiceServer(s grpc.ServiceRegistrar, srv TradingServiceServer) {
	// If the following call pancis, it indicates UnimplementedTradingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TradingService_ServiceDesc, srv)
}

func _TradingService_PrepareOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).PrepareOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_PrepareOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).PrepareOrder(ctx, req.(*PrepareOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_CreateOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).CreateOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_CreateOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).CreateOrder(ctx, req.(*CreateOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_CancelOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).CancelOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_CancelOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).CancelOrder(ctx, req.(*CancelOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_BatchCancelOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCancelOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).BatchCancelOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_BatchCancelOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).BatchCancelOrders(ctx, req.(*BatchCancelOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_GetOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).GetOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_GetOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).GetOrder(ctx, req.(*GetOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_ListOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).ListOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_ListOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).ListOrders(ctx, req.(*ListOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_ListOpenOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOpenOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).ListOpenOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_ListOpenOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).ListOpenOrders(ctx, req.(*ListOpenOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_GetBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).GetBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_GetBalance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).GetBalance(ctx, req.(*GetBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_GetBalances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBalancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).GetBalances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_GetBalances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).GetBalances(ctx, req.(*GetBalancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_GetBalanceLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBalanceLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).GetBalanceLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_GetBalanceLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).GetBalanceLogs(ctx, req.(*GetBalanceLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_GetTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).GetTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_GetTrade_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).GetTrade(ctx, req.(*GetTradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_ListTrades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTradesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).ListTrades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_ListTrades_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).ListTrades(ctx, req.(*ListTradesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_ListTradesByOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTradesByOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).ListTradesByOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_ListTradesByOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).ListTradesByOrder(ctx, req.(*ListTradesByOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_GetDeposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDepositRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).GetDeposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_GetDeposit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).GetDeposit(ctx, req.(*GetDepositRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_ListDeposits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDepositsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).ListDeposits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_ListDeposits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).ListDeposits(ctx, req.(*ListDepositsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_CreateWithdrawal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateWithdrawalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).CreateWithdrawal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_CreateWithdrawal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).CreateWithdrawal(ctx, req.(*CreateWithdrawalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_CancelWithdrawal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelWithdrawalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).CancelWithdrawal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_CancelWithdrawal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).CancelWithdrawal(ctx, req.(*CancelWithdrawalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_GetWithdrawal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWithdrawalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).GetWithdrawal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_GetWithdrawal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).GetWithdrawal(ctx, req.(*GetWithdrawalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_ListWithdrawals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWithdrawalsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).ListWithdrawals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_ListWithdrawals_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).ListWithdrawals(ctx, req.(*ListWithdrawalsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_ProcessTradeResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessTradeResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).ProcessTradeResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_ProcessTradeResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).ProcessTradeResult(ctx, req.(*ProcessTradeResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_ProcessDepositEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessDepositEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).ProcessDepositEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_ProcessDepositEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).ProcessDepositEvent(ctx, req.(*ProcessDepositEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_ConfirmSettlement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfirmSettlementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).ConfirmSettlement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_ConfirmSettlement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).ConfirmSettlement(ctx, req.(*ConfirmSettlementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingService_RollbackSettlement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RollbackSettlementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServiceServer).RollbackSettlement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TradingService_RollbackSettlement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServiceServer).RollbackSettlement(ctx, req.(*RollbackSettlementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TradingService_ServiceDesc is the grpc.ServiceDesc for TradingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TradingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "eidos.trading.v1.TradingService",
	HandlerType: (*TradingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PrepareOrder",
			Handler:    _TradingService_PrepareOrder_Handler,
		},
		{
			MethodName: "CreateOrder",
			Handler:    _TradingService_CreateOrder_Handler,
		},
		{
			MethodName: "CancelOrder",
			Handler:    _TradingService_CancelOrder_Handler,
		},
		{
			MethodName: "BatchCancelOrders",
			Handler:    _TradingService_BatchCancelOrders_Handler,
		},
		{
			MethodName: "GetOrder",
			Handler:    _TradingService_GetOrder_Handler,
		},
		{
			MethodName: "ListOrders",
			Handler:    _TradingService_ListOrders_Handler,
		},
		{
			MethodName: "ListOpenOrders",
			Handler:    _TradingService_ListOpenOrders_Handler,
		},
		{
			MethodName: "GetBalance",
			Handler:    _TradingService_GetBalance_Handler,
		},
		{
			MethodName: "GetBalances",
			Handler:    _TradingService_GetBalances_Handler,
		},
		{
			MethodName: "GetBalanceLogs",
			Handler:    _TradingService_GetBalanceLogs_Handler,
		},
		{
			MethodName: "GetTrade",
			Handler:    _TradingService_GetTrade_Handler,
		},
		{
			MethodName: "ListTrades",
			Handler:    _TradingService_ListTrades_Handler,
		},
		{
			MethodName: "ListTradesByOrder",
			Handler:    _TradingService_ListTradesByOrder_Handler,
		},
		{
			MethodName: "GetDeposit",
			Handler:    _TradingService_GetDeposit_Handler,
		},
		{
			MethodName: "ListDeposits",
			Handler:    _TradingService_ListDeposits_Handler,
		},
		{
			MethodName: "CreateWithdrawal",
			Handler:    _TradingService_CreateWithdrawal_Handler,
		},
		{
			MethodName: "CancelWithdrawal",
			Handler:    _TradingService_CancelWithdrawal_Handler,
		},
		{
			MethodName: "GetWithdrawal",
			Handler:    _TradingService_GetWithdrawal_Handler,
		},
		{
			MethodName: "ListWithdrawals",
			Handler:    _TradingService_ListWithdrawals_Handler,
		},
		{
			MethodName: "ProcessTradeResult",
			Handler:    _TradingService_ProcessTradeResult_Handler,
		},
		{
			MethodName: "ProcessDepositEvent",
			Handler:    _TradingService_ProcessDepositEvent_Handler,
		},
		{
			MethodName: "ConfirmSettlement",
			Handler:    _TradingService_ConfirmSettlement_Handler,
		},
		{
			MethodName: "RollbackSettlement",
			Handler:    _TradingService_RollbackSettlement_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "trading/v1/trading.proto",
}
