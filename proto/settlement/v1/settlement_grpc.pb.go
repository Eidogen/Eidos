// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: settlement/v1/settlement.proto

package settlementv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SettlementService_GetBatch_FullMethodName           = "/eidos.settlement.v1.SettlementService/GetBatch"
	SettlementService_ListBatches_FullMethodName        = "/eidos.settlement.v1.SettlementService/ListBatches"
	SettlementService_ListTradesInBatch_FullMethodName  = "/eidos.settlement.v1.SettlementService/ListTradesInBatch"
	SettlementService_TriggerSettlement_FullMethodName  = "/eidos.settlement.v1.SettlementService/TriggerSettlement"
	SettlementService_RetryBatch_FullMethodName         = "/eidos.settlement.v1.SettlementService/RetryBatch"
	SettlementService_SplitBatch_FullMethodName         = "/eidos.settlement.v1.SettlementService/SplitBatch"
	SettlementService_RollbackBatch_FullMethodName      = "/eidos.settlement.v1.SettlementService/RollbackBatch"
	SettlementService_GetTradeSettlement_FullMethodName = "/eidos.settlement.v1.SettlementService/GetTradeSettlement"
	SettlementService_ListPendingTrades_FullMethodName  = "/eidos.settlement.v1.SettlementService/ListPendingTrades"
	SettlementService_GetSettlementStats_FullMethodName = "/eidos.settlement.v1.SettlementService/GetSettlementStats"
	SettlementService_GetBatcherStatus_FullMethodName   = "/eidos.settlement.v1.SettlementService/GetBatcherStatus"
	SettlementService_OnTradeMatched_FullMethodName     = "/eidos.settlement.v1.SettlementService/OnTradeMatched"
	SettlementService_OnBatchSubmitted_FullMethodName   = "/eidos.settlement.v1.SettlementService/OnBatchSubmitted"
	SettlementService_OnBatchConfirmed_FullMethodName   = "/eidos.settlement.v1.SettlementService/OnBatchConfirmed"
	SettlementService_OnBatchFailed_FullMethodName      = "/eidos.settlement.v1.SettlementService/OnBatchFailed"
)

// SettlementServiceClient is the client API for SettlementService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// SettlementService manages the settlement of off-chain trades to on-chain.
// It handles batching, submission, confirmation, and rollback of settlements.
type SettlementServiceClient interface {
	// GetBatch retrieves details of a settlement batch
	GetBatch(ctx context.Context, in *GetBatchRequest, opts ...grpc.CallOption) (*GetBatchResponse, error)
	// ListBatches retrieves settlement batches with filters
	ListBatches(ctx context.Context, in *ListBatchesRequest, opts ...grpc.CallOption) (*ListBatchesResponse, error)
	// ListTradesInBatch retrieves trades in a specific batch
	ListTradesInBatch(ctx context.Context, in *ListTradesInBatchRequest, opts ...grpc.CallOption) (*ListTradesInBatchResponse, error)
	// TriggerSettlement manually triggers settlement for pending trades
	// Used for immediate settlement needs or recovery scenarios
	TriggerSettlement(ctx context.Context, in *TriggerSettlementRequest, opts ...grpc.CallOption) (*TriggerSettlementResponse, error)
	// RetryBatch retries a failed settlement batch
	RetryBatch(ctx context.Context, in *RetryBatchRequest, opts ...grpc.CallOption) (*RetryBatchResponse, error)
	// SplitBatch splits a failed batch into smaller batches for retry
	SplitBatch(ctx context.Context, in *SplitBatchRequest, opts ...grpc.CallOption) (*SplitBatchResponse, error)
	// RollbackBatch marks a batch as rolled back and reverts trade states
	RollbackBatch(ctx context.Context, in *RollbackBatchRequest, opts ...grpc.CallOption) (*RollbackBatchResponse, error)
	// GetTradeSettlement retrieves settlement status for a trade
	GetTradeSettlement(ctx context.Context, in *GetTradeSettlementRequest, opts ...grpc.CallOption) (*GetTradeSettlementResponse, error)
	// ListPendingTrades retrieves trades pending settlement
	ListPendingTrades(ctx context.Context, in *ListPendingTradesRequest, opts ...grpc.CallOption) (*ListPendingTradesResponse, error)
	// GetSettlementStats retrieves settlement statistics
	GetSettlementStats(ctx context.Context, in *GetSettlementStatsRequest, opts ...grpc.CallOption) (*GetSettlementStatsResponse, error)
	// GetBatcherStatus retrieves status of the settlement batcher
	GetBatcherStatus(ctx context.Context, in *GetBatcherStatusRequest, opts ...grpc.CallOption) (*GetBatcherStatusResponse, error)
	// OnTradeMatched is called when a trade is matched (internal)
	OnTradeMatched(ctx context.Context, in *OnTradeMatchedRequest, opts ...grpc.CallOption) (*OnTradeMatchedResponse, error)
	// OnBatchSubmitted is called when a batch is submitted to chain (internal)
	OnBatchSubmitted(ctx context.Context, in *OnBatchSubmittedRequest, opts ...grpc.CallOption) (*OnBatchSubmittedResponse, error)
	// OnBatchConfirmed is called when a batch is confirmed on chain (internal)
	OnBatchConfirmed(ctx context.Context, in *OnBatchConfirmedRequest, opts ...grpc.CallOption) (*OnBatchConfirmedResponse, error)
	// OnBatchFailed is called when a batch submission fails (internal)
	OnBatchFailed(ctx context.Context, in *OnBatchFailedRequest, opts ...grpc.CallOption) (*OnBatchFailedResponse, error)
}

type settlementServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSettlementServiceClient(cc grpc.ClientConnInterface) SettlementServiceClient {
	return &settlementServiceClient{cc}
}

func (c *settlementServiceClient) GetBatch(ctx context.Context, in *GetBatchRequest, opts ...grpc.CallOption) (*GetBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBatchResponse)
	err := c.cc.Invoke(ctx, SettlementService_GetBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settlementServiceClient) ListBatches(ctx context.Context, in *ListBatchesRequest, opts ...grpc.CallOption) (*ListBatchesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListBatchesResponse)
	err := c.cc.Invoke(ctx, SettlementService_ListBatches_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settlementServiceClient) ListTradesInBatch(ctx context.Context, in *ListTradesInBatchRequest, opts ...grpc.CallOption) (*ListTradesInBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTradesInBatchResponse)
	err := c.cc.Invoke(ctx, SettlementService_ListTradesInBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settlementServiceClient) TriggerSettlement(ctx context.Context, in *TriggerSettlementRequest, opts ...grpc.CallOption) (*TriggerSettlementResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TriggerSettlementResponse)
	err := c.cc.Invoke(ctx, SettlementService_TriggerSettlement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settlementServiceClient) RetryBatch(ctx context.Context, in *RetryBatchRequest, opts ...grpc.CallOption) (*RetryBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RetryBatchResponse)
	err := c.cc.Invoke(ctx, SettlementService_RetryBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settlementServiceClient) SplitBatch(ctx context.Context, in *SplitBatchRequest, opts ...grpc.CallOption) (*SplitBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SplitBatchResponse)
	err := c.cc.Invoke(ctx, SettlementService_SplitBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settlementServiceClient) RollbackBatch(ctx context.Context, in *RollbackBatchRequest, opts ...grpc.CallOption) (*RollbackBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RollbackBatchResponse)
	err := c.cc.Invoke(ctx, SettlementService_RollbackBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settlementServiceClient) GetTradeSettlement(ctx context.Context, in *GetTradeSettlementRequest, opts ...grpc.CallOption) (*GetTradeSettlementResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTradeSettlementResponse)
	err := c.cc.Invoke(ctx, SettlementService_GetTradeSettlement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settlementServiceClient) ListPendingTrades(ctx context.Context, in *ListPendingTradesRequest, opts ...grpc.CallOption) (*ListPendingTradesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPendingTradesResponse)
	err := c.cc.Invoke(ctx, SettlementService_ListPendingTrades_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settlementServiceClient) GetSettlementStats(ctx context.Context, in *GetSettlementStatsRequest, opts ...grpc.CallOption) (*GetSettlementStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSettlementStatsResponse)
	err := c.cc.Invoke(ctx, SettlementService_GetSettlementStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settlementServiceClient) GetBatcherStatus(ctx context.Context, in *GetBatcherStatusRequest, opts ...grpc.CallOption) (*GetBatcherStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBatcherStatusResponse)
	err := c.cc.Invoke(ctx, SettlementService_GetBatcherStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settlementServiceClient) OnTradeMatched(ctx context.Context, in *OnTradeMatchedRequest, opts ...grpc.CallOption) (*OnTradeMatchedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnTradeMatchedResponse)
	err := c.cc.Invoke(ctx, SettlementService_OnTradeMatched_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settlementServiceClient) OnBatchSubmitted(ctx context.Context, in *OnBatchSubmittedRequest, opts ...grpc.CallOption) (*OnBatchSubmittedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnBatchSubmittedResponse)
	err := c.cc.Invoke(ctx, SettlementService_OnBatchSubmitted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settlementServiceClient) OnBatchConfirmed(ctx context.Context, in *OnBatchConfirmedRequest, opts ...grpc.CallOption) (*OnBatchConfirmedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnBatchConfirmedResponse)
	err := c.cc.Invoke(ctx, SettlementService_OnBatchConfirmed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settlementServiceClient) OnBatchFailed(ctx context.Context, in *OnBatchFailedRequest, opts ...grpc.CallOption) (*OnBatchFailedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnBatchFailedResponse)
	err := c.cc.Invoke(ctx, SettlementService_OnBatchFailed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SettlementServiceServer is the server API for SettlementService service.
// All implementations must embed UnimplementedSettlementServiceServer
// for forward compatibility.
//
// SettlementService manages the settlement of off-chain trades to on-chain.
// It handles batching, submission, confirmation, and rollback of settlements.
type SettlementServiceServer interface {
	// GetBatch retrieves details of a settlement batch
	GetBatch(context.Context, *GetBatchRequest) (*GetBatchResponse, error)
	// ListBatches retrieves settlement batches with filters
	ListBatches(context.Context, *ListBatchesRequest) (*ListBatchesResponse, error)
	// ListTradesInBatch retrieves trades in a specific batch
	ListTradesInBatch(context.Context, *ListTradesInBatchRequest) (*ListTradesInBatchResponse, error)
	// TriggerSettlement manually triggers settlement for pending trades
	// Used for immediate settlement needs or recovery scenarios
	TriggerSettlement(context.Context, *TriggerSettlementRequest) (*TriggerSettlementResponse, error)
	// RetryBatch retries a failed settlement batch
	RetryBatch(context.Context, *RetryBatchRequest) (*RetryBatchResponse, error)
	// SplitBatch splits a failed batch into smaller batches for retry
	SplitBatch(context.Context, *SplitBatchRequest) (*SplitBatchResponse, error)
	// RollbackBatch marks a batch as rolled back and reverts trade states
	RollbackBatch(context.Context, *RollbackBatchRequest) (*RollbackBatchResponse, error)
	// GetTradeSettlement retrieves settlement status for a trade
	GetTradeSettlement(context.Context, *GetTradeSettlementRequest) (*GetTradeSettlementResponse, error)
	// ListPendingTrades retrieves trades pending settlement
	ListPendingTrades(context.Context, *ListPendingTradesRequest) (*ListPendingTradesResponse, error)
	// GetSettlementStats retrieves settlement statistics
	GetSettlementStats(context.Context, *GetSettlementStatsRequest) (*GetSettlementStatsResponse, error)
	// GetBatcherStatus retrieves status of the settlement batcher
	GetBatcherStatus(context.Context, *GetBatcherStatusRequest) (*GetBatcherStatusResponse, error)
	// OnTradeMatched is called when a trade is matched (internal)
	OnTradeMatched(context.Context, *OnTradeMatchedRequest) (*OnTradeMatchedResponse, error)
	// OnBatchSubmitted is called when a batch is submitted to chain (internal)
	OnBatchSubmitted(context.Context, *OnBatchSubmittedRequest) (*OnBatchSubmittedResponse, error)
	// OnBatchConfirmed is called when a batch is confirmed on chain (internal)
	OnBatchConfirmed(context.Context, *OnBatchConfirmedRequest) (*OnBatchConfirmedResponse, error)
	// OnBatchFailed is called when a batch submission fails (internal)
	OnBatchFailed(context.Context, *OnBatchFailedRequest) (*OnBatchFailedResponse, error)
	mustEmbedUnimplementedSettlementServiceServer()
}

// UnimplementedSettlementServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSettlementServiceServer struct{}

func (UnimplementedSettlementServiceServer) GetBatch(context.Context, *GetBatchRequest) (*GetBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBatch not implemented")
}
func (UnimplementedSettlementServiceServer) ListBatches(context.Context, *ListBatchesRequest) (*ListBatchesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBatches not implemented")
}
func (UnimplementedSettlementServiceServer) ListTradesInBatch(context.Context, *ListTradesInBatchRequest) (*ListTradesInBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTradesInBatch not implemented")
}
func (UnimplementedSettlementServiceServer) TriggerSettlement(context.Context, *TriggerSettlementRequest) (*TriggerSettlementResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerSettlement not implemented")
}
func (UnimplementedSettlementServiceServer) RetryBatch(context.Context, *RetryBatchRequest) (*RetryBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetryBatch not implemented")
}
func (UnimplementedSettlementServiceServer) SplitBatch(context.Context, *SplitBatchRequest) (*SplitBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SplitBatch not implemented")
}
func (UnimplementedSettlementServiceServer) RollbackBatch(context.Context, *RollbackBatchRequest) (*RollbackBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RollbackBatch not implemented")
}
func (UnimplementedSettlementServiceServer) GetTradeSettlement(context.Context, *GetTradeSettlementRequest) (*GetTradeSettlementResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTradeSettlement not implemented")
}
func (UnimplementedSettlementServiceServer) ListPendingTrades(context.Context, *ListPendingTradesRequest) (*ListPendingTradesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPendingTrades not implemented")
}
func (UnimplementedSettlementServiceServer) GetSettlementStats(context.Context, *GetSettlementStatsRequest) (*GetSettlementStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSettlementStats not implemented")
}
func (UnimplementedSettlementServiceServer) GetBatcherStatus(context.Context, *GetBatcherStatusRequest) (*GetBatcherStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBatcherStatus not implemented")
}
func (UnimplementedSettlementServiceServer) OnTradeMatched(context.Context, *OnTradeMatchedRequest) (*OnTradeMatchedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnTradeMatched not implemented")
}
func (UnimplementedSettlementServiceServer) OnBatchSubmitted(context.Context, *OnBatchSubmittedRequest) (*OnBatchSubmittedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnBatchSubmitted not implemented")
}
func (UnimplementedSettlementServiceServer) OnBatchConfirmed(context.Context, *OnBatchConfirmedRequest) (*OnBatchConfirmedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnBatchConfirmed not implemented")
}
func (UnimplementedSettlementServiceServer) OnBatchFailed(context.Context, *OnBatchFailedRequest) (*OnBatchFailedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnBatchFailed not implemented")
}
func (UnimplementedSettlementServiceServer) mustEmbedUnimplementedSettlementServiceServer() {}
func (UnimplementedSettlementServiceServer) testEmbeddedByValue()                           {}

// UnsafeSettlementServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SettlementServiceServer will
// result in compilation errors.
type UnsafeSettlementServiceServer interface {
	mustEmbedUnimplementedSettlementServiceServer()
}

func RegisterSettlementServiceServer(s grpc.ServiceRegistrar, srv SettlementServiceServer) {
	// If the following call pancis, it indicates UnimplementedSettlementServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SettlementService_ServiceDesc, srv)
}

func _SettlementService_GetBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettlementServiceServer).GetBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettlementService_GetBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettlementServiceServer).GetBatch(ctx, req.(*GetBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettlementService_ListBatches_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBatchesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettlementServiceServer).ListBatches(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettlementService_ListBatches_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettlementServiceServer).ListBatches(ctx, req.(*ListBatchesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettlementService_ListTradesInBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTradesInBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettlementServiceServer).ListTradesInBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettlementService_ListTradesInBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettlementServiceServer).ListTradesInBatch(ctx, req.(*ListTradesInBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettlementService_TriggerSettlement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TriggerSettlementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettlementServiceServer).TriggerSettlement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettlementService_TriggerSettlement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettlementServiceServer).TriggerSettlement(ctx, req.(*TriggerSettlementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettlementService_RetryBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetryBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettlementServiceServer).RetryBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettlementService_RetryBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettlementServiceServer).RetryBatch(ctx, req.(*RetryBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettlementService_SplitBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SplitBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettlementServiceServer).SplitBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettlementService_SplitBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettlementServiceServer).SplitBatch(ctx, req.(*SplitBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettlementService_RollbackBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RollbackBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettlementServiceServer).RollbackBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettlementService_RollbackBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettlementServiceServer).RollbackBatch(ctx, req.(*RollbackBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettlementService_GetTradeSettlement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTradeSettlementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettlementServiceServer).GetTradeSettlement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettlementService_GetTradeSettlement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettlementServiceServer).GetTradeSettlement(ctx, req.(*GetTradeSettlementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettlementService_ListPendingTrades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPendingTradesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettlementServiceServer).ListPendingTrades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettlementService_ListPendingTrades_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettlementServiceServer).ListPendingTrades(ctx, req.(*ListPendingTradesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettlementService_GetSettlementStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSettlementStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettlementServiceServer).GetSettlementStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettlementService_GetSettlementStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettlementServiceServer).GetSettlementStats(ctx, req.(*GetSettlementStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettlementService_GetBatcherStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBatcherStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettlementServiceServer).GetBatcherStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettlementService_GetBatcherStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettlementServiceServer).GetBatcherStatus(ctx, req.(*GetBatcherStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettlementService_OnTradeMatched_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnTradeMatchedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettlementServiceServer).OnTradeMatched(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettlementService_OnTradeMatched_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettlementServiceServer).OnTradeMatched(ctx, req.(*OnTradeMatchedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettlementService_OnBatchSubmitted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnBatchSubmittedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettlementServiceServer).OnBatchSubmitted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettlementService_OnBatchSubmitted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettlementServiceServer).OnBatchSubmitted(ctx, req.(*OnBatchSubmittedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettlementService_OnBatchConfirmed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnBatchConfirmedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettlementServiceServer).OnBatchConfirmed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettlementService_OnBatchConfirmed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettlementServiceServer).OnBatchConfirmed(ctx, req.(*OnBatchConfirmedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettlementService_OnBatchFailed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnBatchFailedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettlementServiceServer).OnBatchFailed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettlementService_OnBatchFailed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettlementServiceServer).OnBatchFailed(ctx, req.(*OnBatchFailedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SettlementService_ServiceDesc is the grpc.ServiceDesc for SettlementService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SettlementService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "eidos.settlement.v1.SettlementService",
	HandlerType: (*SettlementServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBatch",
			Handler:    _SettlementService_GetBatch_Handler,
		},
		{
			MethodName: "ListBatches",
			Handler:    _SettlementService_ListBatches_Handler,
		},
		{
			MethodName: "ListTradesInBatch",
			Handler:    _SettlementService_ListTradesInBatch_Handler,
		},
		{
			MethodName: "TriggerSettlement",
			Handler:    _SettlementService_TriggerSettlement_Handler,
		},
		{
			MethodName: "RetryBatch",
			Handler:    _SettlementService_RetryBatch_Handler,
		},
		{
			MethodName: "SplitBatch",
			Handler:    _SettlementService_SplitBatch_Handler,
		},
		{
			MethodName: "RollbackBatch",
			Handler:    _SettlementService_RollbackBatch_Handler,
		},
		{
			MethodName: "GetTradeSettlement",
			Handler:    _SettlementService_GetTradeSettlement_Handler,
		},
		{
			MethodName: "ListPendingTrades",
			Handler:    _SettlementService_ListPendingTrades_Handler,
		},
		{
			MethodName: "GetSettlementStats",
			Handler:    _SettlementService_GetSettlementStats_Handler,
		},
		{
			MethodName: "GetBatcherStatus",
			Handler:    _SettlementService_GetBatcherStatus_Handler,
		},
		{
			MethodName: "OnTradeMatched",
			Handler:    _SettlementService_OnTradeMatched_Handler,
		},
		{
			MethodName: "OnBatchSubmitted",
			Handler:    _SettlementService_OnBatchSubmitted_Handler,
		},
		{
			MethodName: "OnBatchConfirmed",
			Handler:    _SettlementService_OnBatchConfirmed_Handler,
		},
		{
			MethodName: "OnBatchFailed",
			Handler:    _SettlementService_OnBatchFailed_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "settlement/v1/settlement.proto",
}
