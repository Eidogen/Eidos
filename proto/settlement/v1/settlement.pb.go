// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v5.29.3
// source: settlement/v1/settlement.proto

package settlementv1

import (
	common "github.com/eidos-exchange/eidos/proto/common"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// SettlementBatch represents a batch of trades to be settled
type SettlementBatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique batch identifier
	BatchId string `protobuf:"bytes,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// Number of trades in the batch
	TradeCount int32 `protobuf:"varint,2,opt,name=trade_count,json=tradeCount,proto3" json:"trade_count,omitempty"`
	// Trade IDs in this batch
	TradeIds []string `protobuf:"bytes,3,rep,name=trade_ids,json=tradeIds,proto3" json:"trade_ids,omitempty"`
	// Current batch status
	Status common.BatchStatus `protobuf:"varint,4,opt,name=status,proto3,enum=eidos.common.v1.BatchStatus" json:"status,omitempty"`
	// Chain ID for settlement
	ChainId int64 `protobuf:"varint,5,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Contract address for settlement
	ContractAddress string `protobuf:"bytes,6,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"`
	// Transaction hash (set when submitted)
	TxHash string `protobuf:"bytes,7,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	// Block number (set when confirmed)
	BlockNumber int64 `protobuf:"varint,8,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	// Gas used (set when confirmed)
	GasUsed int64 `protobuf:"varint,9,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
	// Gas price in wei (set when submitted)
	GasPrice string `protobuf:"bytes,10,opt,name=gas_price,json=gasPrice,proto3" json:"gas_price,omitempty"`
	// Effective gas price in wei (set when confirmed)
	EffectiveGasPrice string `protobuf:"bytes,11,opt,name=effective_gas_price,json=effectiveGasPrice,proto3" json:"effective_gas_price,omitempty"`
	// Transaction nonce
	Nonce uint64 `protobuf:"varint,12,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Retry count
	RetryCount int32 `protobuf:"varint,13,opt,name=retry_count,json=retryCount,proto3" json:"retry_count,omitempty"`
	// Maximum retries allowed
	MaxRetries int32 `protobuf:"varint,14,opt,name=max_retries,json=maxRetries,proto3" json:"max_retries,omitempty"`
	// Last error message
	ErrorMessage string `protobuf:"bytes,15,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Last error code
	ErrorCode string `protobuf:"bytes,16,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	// Total base volume in batch (decimal string)
	TotalBaseVolume string `protobuf:"bytes,17,opt,name=total_base_volume,json=totalBaseVolume,proto3" json:"total_base_volume,omitempty"`
	// Total quote volume in batch (decimal string)
	TotalQuoteVolume string `protobuf:"bytes,18,opt,name=total_quote_volume,json=totalQuoteVolume,proto3" json:"total_quote_volume,omitempty"`
	// Batch creation timestamp (Unix milliseconds)
	CreatedAt int64 `protobuf:"varint,19,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// Batch submission timestamp (Unix milliseconds)
	SubmittedAt int64 `protobuf:"varint,20,opt,name=submitted_at,json=submittedAt,proto3" json:"submitted_at,omitempty"`
	// Batch confirmation timestamp (Unix milliseconds)
	ConfirmedAt int64 `protobuf:"varint,21,opt,name=confirmed_at,json=confirmedAt,proto3" json:"confirmed_at,omitempty"`
	// Last update timestamp (Unix milliseconds)
	UpdatedAt     int64 `protobuf:"varint,22,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SettlementBatch) Reset() {
	*x = SettlementBatch{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SettlementBatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SettlementBatch) ProtoMessage() {}

func (x *SettlementBatch) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SettlementBatch.ProtoReflect.Descriptor instead.
func (*SettlementBatch) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{0}
}

func (x *SettlementBatch) GetBatchId() string {
	if x != nil {
		return x.BatchId
	}
	return ""
}

func (x *SettlementBatch) GetTradeCount() int32 {
	if x != nil {
		return x.TradeCount
	}
	return 0
}

func (x *SettlementBatch) GetTradeIds() []string {
	if x != nil {
		return x.TradeIds
	}
	return nil
}

func (x *SettlementBatch) GetStatus() common.BatchStatus {
	if x != nil {
		return x.Status
	}
	return common.BatchStatus(0)
}

func (x *SettlementBatch) GetChainId() int64 {
	if x != nil {
		return x.ChainId
	}
	return 0
}

func (x *SettlementBatch) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

func (x *SettlementBatch) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *SettlementBatch) GetBlockNumber() int64 {
	if x != nil {
		return x.BlockNumber
	}
	return 0
}

func (x *SettlementBatch) GetGasUsed() int64 {
	if x != nil {
		return x.GasUsed
	}
	return 0
}

func (x *SettlementBatch) GetGasPrice() string {
	if x != nil {
		return x.GasPrice
	}
	return ""
}

func (x *SettlementBatch) GetEffectiveGasPrice() string {
	if x != nil {
		return x.EffectiveGasPrice
	}
	return ""
}

func (x *SettlementBatch) GetNonce() uint64 {
	if x != nil {
		return x.Nonce
	}
	return 0
}

func (x *SettlementBatch) GetRetryCount() int32 {
	if x != nil {
		return x.RetryCount
	}
	return 0
}

func (x *SettlementBatch) GetMaxRetries() int32 {
	if x != nil {
		return x.MaxRetries
	}
	return 0
}

func (x *SettlementBatch) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *SettlementBatch) GetErrorCode() string {
	if x != nil {
		return x.ErrorCode
	}
	return ""
}

func (x *SettlementBatch) GetTotalBaseVolume() string {
	if x != nil {
		return x.TotalBaseVolume
	}
	return ""
}

func (x *SettlementBatch) GetTotalQuoteVolume() string {
	if x != nil {
		return x.TotalQuoteVolume
	}
	return ""
}

func (x *SettlementBatch) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

func (x *SettlementBatch) GetSubmittedAt() int64 {
	if x != nil {
		return x.SubmittedAt
	}
	return 0
}

func (x *SettlementBatch) GetConfirmedAt() int64 {
	if x != nil {
		return x.ConfirmedAt
	}
	return 0
}

func (x *SettlementBatch) GetUpdatedAt() int64 {
	if x != nil {
		return x.UpdatedAt
	}
	return 0
}

// GetBatchRequest is the request to get batch details
type GetBatchRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Batch ID to retrieve
	BatchId       string `protobuf:"bytes,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetBatchRequest) Reset() {
	*x = GetBatchRequest{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetBatchRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetBatchRequest) ProtoMessage() {}

func (x *GetBatchRequest) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetBatchRequest.ProtoReflect.Descriptor instead.
func (*GetBatchRequest) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{1}
}

func (x *GetBatchRequest) GetBatchId() string {
	if x != nil {
		return x.BatchId
	}
	return ""
}

// GetBatchResponse contains batch details
type GetBatchResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Settlement batch
	Batch         *SettlementBatch `protobuf:"bytes,1,opt,name=batch,proto3" json:"batch,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetBatchResponse) Reset() {
	*x = GetBatchResponse{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetBatchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetBatchResponse) ProtoMessage() {}

func (x *GetBatchResponse) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetBatchResponse.ProtoReflect.Descriptor instead.
func (*GetBatchResponse) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{2}
}

func (x *GetBatchResponse) GetBatch() *SettlementBatch {
	if x != nil {
		return x.Batch
	}
	return nil
}

// ListBatchesRequest is the request to list batches
type ListBatchesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Filter by batch status (optional)
	Status common.BatchStatus `protobuf:"varint,1,opt,name=status,proto3,enum=eidos.common.v1.BatchStatus" json:"status,omitempty"`
	// Filter by chain ID (optional)
	ChainId int64 `protobuf:"varint,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Start time filter (Unix milliseconds, optional)
	StartTime int64 `protobuf:"varint,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// End time filter (Unix milliseconds, optional)
	EndTime int64 `protobuf:"varint,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// Pagination
	Pagination    *common.PaginationRequest `protobuf:"bytes,5,opt,name=pagination,proto3" json:"pagination,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListBatchesRequest) Reset() {
	*x = ListBatchesRequest{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListBatchesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListBatchesRequest) ProtoMessage() {}

func (x *ListBatchesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListBatchesRequest.ProtoReflect.Descriptor instead.
func (*ListBatchesRequest) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{3}
}

func (x *ListBatchesRequest) GetStatus() common.BatchStatus {
	if x != nil {
		return x.Status
	}
	return common.BatchStatus(0)
}

func (x *ListBatchesRequest) GetChainId() int64 {
	if x != nil {
		return x.ChainId
	}
	return 0
}

func (x *ListBatchesRequest) GetStartTime() int64 {
	if x != nil {
		return x.StartTime
	}
	return 0
}

func (x *ListBatchesRequest) GetEndTime() int64 {
	if x != nil {
		return x.EndTime
	}
	return 0
}

func (x *ListBatchesRequest) GetPagination() *common.PaginationRequest {
	if x != nil {
		return x.Pagination
	}
	return nil
}

// ListBatchesResponse contains list of batches
type ListBatchesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Settlement batches
	Batches []*SettlementBatch `protobuf:"bytes,1,rep,name=batches,proto3" json:"batches,omitempty"`
	// Pagination
	Pagination    *common.PaginationResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListBatchesResponse) Reset() {
	*x = ListBatchesResponse{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListBatchesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListBatchesResponse) ProtoMessage() {}

func (x *ListBatchesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListBatchesResponse.ProtoReflect.Descriptor instead.
func (*ListBatchesResponse) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{4}
}

func (x *ListBatchesResponse) GetBatches() []*SettlementBatch {
	if x != nil {
		return x.Batches
	}
	return nil
}

func (x *ListBatchesResponse) GetPagination() *common.PaginationResponse {
	if x != nil {
		return x.Pagination
	}
	return nil
}

// ListTradesInBatchRequest is the request to list trades in a batch
type ListTradesInBatchRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Batch ID
	BatchId string `protobuf:"bytes,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// Pagination
	Pagination    *common.PaginationRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListTradesInBatchRequest) Reset() {
	*x = ListTradesInBatchRequest{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListTradesInBatchRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListTradesInBatchRequest) ProtoMessage() {}

func (x *ListTradesInBatchRequest) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListTradesInBatchRequest.ProtoReflect.Descriptor instead.
func (*ListTradesInBatchRequest) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{5}
}

func (x *ListTradesInBatchRequest) GetBatchId() string {
	if x != nil {
		return x.BatchId
	}
	return ""
}

func (x *ListTradesInBatchRequest) GetPagination() *common.PaginationRequest {
	if x != nil {
		return x.Pagination
	}
	return nil
}

// ListTradesInBatchResponse contains trades in batch
type ListTradesInBatchResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Trades in the batch
	Trades []*SettlementTrade `protobuf:"bytes,1,rep,name=trades,proto3" json:"trades,omitempty"`
	// Pagination
	Pagination    *common.PaginationResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListTradesInBatchResponse) Reset() {
	*x = ListTradesInBatchResponse{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListTradesInBatchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListTradesInBatchResponse) ProtoMessage() {}

func (x *ListTradesInBatchResponse) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListTradesInBatchResponse.ProtoReflect.Descriptor instead.
func (*ListTradesInBatchResponse) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{6}
}

func (x *ListTradesInBatchResponse) GetTrades() []*SettlementTrade {
	if x != nil {
		return x.Trades
	}
	return nil
}

func (x *ListTradesInBatchResponse) GetPagination() *common.PaginationResponse {
	if x != nil {
		return x.Pagination
	}
	return nil
}

// SettlementTrade represents a trade in settlement context
type SettlementTrade struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Trade ID
	TradeId string `protobuf:"bytes,1,opt,name=trade_id,json=tradeId,proto3" json:"trade_id,omitempty"`
	// Trading pair symbol
	Market string `protobuf:"bytes,2,opt,name=market,proto3" json:"market,omitempty"`
	// Maker wallet address
	MakerWallet string `protobuf:"bytes,3,opt,name=maker_wallet,json=makerWallet,proto3" json:"maker_wallet,omitempty"`
	// Taker wallet address
	TakerWallet string `protobuf:"bytes,4,opt,name=taker_wallet,json=takerWallet,proto3" json:"taker_wallet,omitempty"`
	// Base token symbol
	BaseToken string `protobuf:"bytes,5,opt,name=base_token,json=baseToken,proto3" json:"base_token,omitempty"`
	// Quote token symbol
	QuoteToken string `protobuf:"bytes,6,opt,name=quote_token,json=quoteToken,proto3" json:"quote_token,omitempty"`
	// Base token contract address
	BaseTokenAddress string `protobuf:"bytes,7,opt,name=base_token_address,json=baseTokenAddress,proto3" json:"base_token_address,omitempty"`
	// Quote token contract address
	QuoteTokenAddress string `protobuf:"bytes,8,opt,name=quote_token_address,json=quoteTokenAddress,proto3" json:"quote_token_address,omitempty"`
	// Trade price (decimal string)
	Price string `protobuf:"bytes,9,opt,name=price,proto3" json:"price,omitempty"`
	// Base amount (decimal string)
	BaseAmount string `protobuf:"bytes,10,opt,name=base_amount,json=baseAmount,proto3" json:"base_amount,omitempty"`
	// Quote amount (decimal string)
	QuoteAmount string `protobuf:"bytes,11,opt,name=quote_amount,json=quoteAmount,proto3" json:"quote_amount,omitempty"`
	// Taker side
	TakerSide common.OrderSide `protobuf:"varint,12,opt,name=taker_side,json=takerSide,proto3,enum=eidos.common.v1.OrderSide" json:"taker_side,omitempty"`
	// Maker fee (decimal string)
	MakerFee string `protobuf:"bytes,13,opt,name=maker_fee,json=makerFee,proto3" json:"maker_fee,omitempty"`
	// Taker fee (decimal string)
	TakerFee string `protobuf:"bytes,14,opt,name=taker_fee,json=takerFee,proto3" json:"taker_fee,omitempty"`
	// Current settlement status
	SettlementStatus common.SettlementStatus `protobuf:"varint,15,opt,name=settlement_status,json=settlementStatus,proto3,enum=eidos.common.v1.SettlementStatus" json:"settlement_status,omitempty"`
	// Batch ID (if assigned)
	BatchId string `protobuf:"bytes,16,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// Trade timestamp (Unix milliseconds)
	MatchedAt int64 `protobuf:"varint,17,opt,name=matched_at,json=matchedAt,proto3" json:"matched_at,omitempty"`
	// Settlement timestamp (Unix milliseconds)
	SettledAt     int64 `protobuf:"varint,18,opt,name=settled_at,json=settledAt,proto3" json:"settled_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SettlementTrade) Reset() {
	*x = SettlementTrade{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SettlementTrade) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SettlementTrade) ProtoMessage() {}

func (x *SettlementTrade) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SettlementTrade.ProtoReflect.Descriptor instead.
func (*SettlementTrade) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{7}
}

func (x *SettlementTrade) GetTradeId() string {
	if x != nil {
		return x.TradeId
	}
	return ""
}

func (x *SettlementTrade) GetMarket() string {
	if x != nil {
		return x.Market
	}
	return ""
}

func (x *SettlementTrade) GetMakerWallet() string {
	if x != nil {
		return x.MakerWallet
	}
	return ""
}

func (x *SettlementTrade) GetTakerWallet() string {
	if x != nil {
		return x.TakerWallet
	}
	return ""
}

func (x *SettlementTrade) GetBaseToken() string {
	if x != nil {
		return x.BaseToken
	}
	return ""
}

func (x *SettlementTrade) GetQuoteToken() string {
	if x != nil {
		return x.QuoteToken
	}
	return ""
}

func (x *SettlementTrade) GetBaseTokenAddress() string {
	if x != nil {
		return x.BaseTokenAddress
	}
	return ""
}

func (x *SettlementTrade) GetQuoteTokenAddress() string {
	if x != nil {
		return x.QuoteTokenAddress
	}
	return ""
}

func (x *SettlementTrade) GetPrice() string {
	if x != nil {
		return x.Price
	}
	return ""
}

func (x *SettlementTrade) GetBaseAmount() string {
	if x != nil {
		return x.BaseAmount
	}
	return ""
}

func (x *SettlementTrade) GetQuoteAmount() string {
	if x != nil {
		return x.QuoteAmount
	}
	return ""
}

func (x *SettlementTrade) GetTakerSide() common.OrderSide {
	if x != nil {
		return x.TakerSide
	}
	return common.OrderSide(0)
}

func (x *SettlementTrade) GetMakerFee() string {
	if x != nil {
		return x.MakerFee
	}
	return ""
}

func (x *SettlementTrade) GetTakerFee() string {
	if x != nil {
		return x.TakerFee
	}
	return ""
}

func (x *SettlementTrade) GetSettlementStatus() common.SettlementStatus {
	if x != nil {
		return x.SettlementStatus
	}
	return common.SettlementStatus(0)
}

func (x *SettlementTrade) GetBatchId() string {
	if x != nil {
		return x.BatchId
	}
	return ""
}

func (x *SettlementTrade) GetMatchedAt() int64 {
	if x != nil {
		return x.MatchedAt
	}
	return 0
}

func (x *SettlementTrade) GetSettledAt() int64 {
	if x != nil {
		return x.SettledAt
	}
	return 0
}

// TriggerSettlementRequest is the request to trigger settlement
type TriggerSettlementRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Trading pair filter (optional, empty = all markets)
	Market string `protobuf:"bytes,1,opt,name=market,proto3" json:"market,omitempty"`
	// Maximum trades to include (optional, default 100)
	MaxTrades int32 `protobuf:"varint,2,opt,name=max_trades,json=maxTrades,proto3" json:"max_trades,omitempty"`
	// Priority level (0 = normal, 1 = high)
	Priority int32 `protobuf:"varint,3,opt,name=priority,proto3" json:"priority,omitempty"`
	// Force immediate submission (skip batching delay)
	ForceImmediate bool `protobuf:"varint,4,opt,name=force_immediate,json=forceImmediate,proto3" json:"force_immediate,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *TriggerSettlementRequest) Reset() {
	*x = TriggerSettlementRequest{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TriggerSettlementRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TriggerSettlementRequest) ProtoMessage() {}

func (x *TriggerSettlementRequest) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TriggerSettlementRequest.ProtoReflect.Descriptor instead.
func (*TriggerSettlementRequest) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{8}
}

func (x *TriggerSettlementRequest) GetMarket() string {
	if x != nil {
		return x.Market
	}
	return ""
}

func (x *TriggerSettlementRequest) GetMaxTrades() int32 {
	if x != nil {
		return x.MaxTrades
	}
	return 0
}

func (x *TriggerSettlementRequest) GetPriority() int32 {
	if x != nil {
		return x.Priority
	}
	return 0
}

func (x *TriggerSettlementRequest) GetForceImmediate() bool {
	if x != nil {
		return x.ForceImmediate
	}
	return false
}

// TriggerSettlementResponse is the response after triggering settlement
type TriggerSettlementResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether trigger was accepted
	Accepted bool `protobuf:"varint,1,opt,name=accepted,proto3" json:"accepted,omitempty"`
	// Created batch ID (if immediate)
	BatchId string `protobuf:"bytes,2,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// Number of trades to be settled
	TradeCount int32 `protobuf:"varint,3,opt,name=trade_count,json=tradeCount,proto3" json:"trade_count,omitempty"`
	// Message
	Message       string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TriggerSettlementResponse) Reset() {
	*x = TriggerSettlementResponse{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TriggerSettlementResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TriggerSettlementResponse) ProtoMessage() {}

func (x *TriggerSettlementResponse) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TriggerSettlementResponse.ProtoReflect.Descriptor instead.
func (*TriggerSettlementResponse) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{9}
}

func (x *TriggerSettlementResponse) GetAccepted() bool {
	if x != nil {
		return x.Accepted
	}
	return false
}

func (x *TriggerSettlementResponse) GetBatchId() string {
	if x != nil {
		return x.BatchId
	}
	return ""
}

func (x *TriggerSettlementResponse) GetTradeCount() int32 {
	if x != nil {
		return x.TradeCount
	}
	return 0
}

func (x *TriggerSettlementResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// RetryBatchRequest is the request to retry a failed batch
type RetryBatchRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Batch ID to retry
	BatchId string `protobuf:"bytes,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// Increase gas price percentage (0-100)
	GasBumpPercent int32 `protobuf:"varint,2,opt,name=gas_bump_percent,json=gasBumpPercent,proto3" json:"gas_bump_percent,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *RetryBatchRequest) Reset() {
	*x = RetryBatchRequest{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RetryBatchRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RetryBatchRequest) ProtoMessage() {}

func (x *RetryBatchRequest) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RetryBatchRequest.ProtoReflect.Descriptor instead.
func (*RetryBatchRequest) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{10}
}

func (x *RetryBatchRequest) GetBatchId() string {
	if x != nil {
		return x.BatchId
	}
	return ""
}

func (x *RetryBatchRequest) GetGasBumpPercent() int32 {
	if x != nil {
		return x.GasBumpPercent
	}
	return 0
}

// RetryBatchResponse is the response after retry
type RetryBatchResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether retry was accepted
	Accepted bool `protobuf:"varint,1,opt,name=accepted,proto3" json:"accepted,omitempty"`
	// New transaction hash
	NewTxHash string `protobuf:"bytes,2,opt,name=new_tx_hash,json=newTxHash,proto3" json:"new_tx_hash,omitempty"`
	// Message
	Message       string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RetryBatchResponse) Reset() {
	*x = RetryBatchResponse{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RetryBatchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RetryBatchResponse) ProtoMessage() {}

func (x *RetryBatchResponse) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RetryBatchResponse.ProtoReflect.Descriptor instead.
func (*RetryBatchResponse) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{11}
}

func (x *RetryBatchResponse) GetAccepted() bool {
	if x != nil {
		return x.Accepted
	}
	return false
}

func (x *RetryBatchResponse) GetNewTxHash() string {
	if x != nil {
		return x.NewTxHash
	}
	return ""
}

func (x *RetryBatchResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// SplitBatchRequest is the request to split a failed batch
type SplitBatchRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Batch ID to split
	BatchId string `protobuf:"bytes,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// Number of new batches (default 2)
	SplitCount    int32 `protobuf:"varint,2,opt,name=split_count,json=splitCount,proto3" json:"split_count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SplitBatchRequest) Reset() {
	*x = SplitBatchRequest{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SplitBatchRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SplitBatchRequest) ProtoMessage() {}

func (x *SplitBatchRequest) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SplitBatchRequest.ProtoReflect.Descriptor instead.
func (*SplitBatchRequest) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{12}
}

func (x *SplitBatchRequest) GetBatchId() string {
	if x != nil {
		return x.BatchId
	}
	return ""
}

func (x *SplitBatchRequest) GetSplitCount() int32 {
	if x != nil {
		return x.SplitCount
	}
	return 0
}

// SplitBatchResponse is the response after split
type SplitBatchResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether split was successful
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// New batch IDs created
	NewBatchIds []string `protobuf:"bytes,2,rep,name=new_batch_ids,json=newBatchIds,proto3" json:"new_batch_ids,omitempty"`
	// Message
	Message       string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SplitBatchResponse) Reset() {
	*x = SplitBatchResponse{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SplitBatchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SplitBatchResponse) ProtoMessage() {}

func (x *SplitBatchResponse) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SplitBatchResponse.ProtoReflect.Descriptor instead.
func (*SplitBatchResponse) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{13}
}

func (x *SplitBatchResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *SplitBatchResponse) GetNewBatchIds() []string {
	if x != nil {
		return x.NewBatchIds
	}
	return nil
}

func (x *SplitBatchResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// RollbackBatchRequest is the request to rollback a batch
type RollbackBatchRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Batch ID to rollback
	BatchId string `protobuf:"bytes,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// Rollback reason
	Reason string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	// Operator ID (for audit)
	OperatorId    string `protobuf:"bytes,3,opt,name=operator_id,json=operatorId,proto3" json:"operator_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RollbackBatchRequest) Reset() {
	*x = RollbackBatchRequest{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RollbackBatchRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RollbackBatchRequest) ProtoMessage() {}

func (x *RollbackBatchRequest) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RollbackBatchRequest.ProtoReflect.Descriptor instead.
func (*RollbackBatchRequest) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{14}
}

func (x *RollbackBatchRequest) GetBatchId() string {
	if x != nil {
		return x.BatchId
	}
	return ""
}

func (x *RollbackBatchRequest) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

func (x *RollbackBatchRequest) GetOperatorId() string {
	if x != nil {
		return x.OperatorId
	}
	return ""
}

// RollbackBatchResponse is the response after rollback
type RollbackBatchResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether rollback was successful
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Number of trades rolled back
	TradesRolledBack int32 `protobuf:"varint,2,opt,name=trades_rolled_back,json=tradesRolledBack,proto3" json:"trades_rolled_back,omitempty"`
	// Message
	Message       string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RollbackBatchResponse) Reset() {
	*x = RollbackBatchResponse{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RollbackBatchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RollbackBatchResponse) ProtoMessage() {}

func (x *RollbackBatchResponse) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RollbackBatchResponse.ProtoReflect.Descriptor instead.
func (*RollbackBatchResponse) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{15}
}

func (x *RollbackBatchResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *RollbackBatchResponse) GetTradesRolledBack() int32 {
	if x != nil {
		return x.TradesRolledBack
	}
	return 0
}

func (x *RollbackBatchResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// GetTradeSettlementRequest is the request to get trade settlement status
type GetTradeSettlementRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Trade ID
	TradeId       string `protobuf:"bytes,1,opt,name=trade_id,json=tradeId,proto3" json:"trade_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetTradeSettlementRequest) Reset() {
	*x = GetTradeSettlementRequest{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetTradeSettlementRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetTradeSettlementRequest) ProtoMessage() {}

func (x *GetTradeSettlementRequest) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetTradeSettlementRequest.ProtoReflect.Descriptor instead.
func (*GetTradeSettlementRequest) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{16}
}

func (x *GetTradeSettlementRequest) GetTradeId() string {
	if x != nil {
		return x.TradeId
	}
	return ""
}

// GetTradeSettlementResponse contains trade settlement details
type GetTradeSettlementResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Trade settlement info
	Trade *SettlementTrade `protobuf:"bytes,1,opt,name=trade,proto3" json:"trade,omitempty"`
	// Batch info (if assigned)
	Batch         *SettlementBatch `protobuf:"bytes,2,opt,name=batch,proto3" json:"batch,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetTradeSettlementResponse) Reset() {
	*x = GetTradeSettlementResponse{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetTradeSettlementResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetTradeSettlementResponse) ProtoMessage() {}

func (x *GetTradeSettlementResponse) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetTradeSettlementResponse.ProtoReflect.Descriptor instead.
func (*GetTradeSettlementResponse) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{17}
}

func (x *GetTradeSettlementResponse) GetTrade() *SettlementTrade {
	if x != nil {
		return x.Trade
	}
	return nil
}

func (x *GetTradeSettlementResponse) GetBatch() *SettlementBatch {
	if x != nil {
		return x.Batch
	}
	return nil
}

// ListPendingTradesRequest is the request to list pending trades
type ListPendingTradesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Filter by market (optional)
	Market string `protobuf:"bytes,1,opt,name=market,proto3" json:"market,omitempty"`
	// Filter by wallet (optional)
	Wallet string `protobuf:"bytes,2,opt,name=wallet,proto3" json:"wallet,omitempty"`
	// Minimum age in seconds (optional)
	MinAgeSeconds int64 `protobuf:"varint,3,opt,name=min_age_seconds,json=minAgeSeconds,proto3" json:"min_age_seconds,omitempty"`
	// Pagination
	Pagination    *common.PaginationRequest `protobuf:"bytes,4,opt,name=pagination,proto3" json:"pagination,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListPendingTradesRequest) Reset() {
	*x = ListPendingTradesRequest{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListPendingTradesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPendingTradesRequest) ProtoMessage() {}

func (x *ListPendingTradesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPendingTradesRequest.ProtoReflect.Descriptor instead.
func (*ListPendingTradesRequest) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{18}
}

func (x *ListPendingTradesRequest) GetMarket() string {
	if x != nil {
		return x.Market
	}
	return ""
}

func (x *ListPendingTradesRequest) GetWallet() string {
	if x != nil {
		return x.Wallet
	}
	return ""
}

func (x *ListPendingTradesRequest) GetMinAgeSeconds() int64 {
	if x != nil {
		return x.MinAgeSeconds
	}
	return 0
}

func (x *ListPendingTradesRequest) GetPagination() *common.PaginationRequest {
	if x != nil {
		return x.Pagination
	}
	return nil
}

// ListPendingTradesResponse contains pending trades
type ListPendingTradesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Pending trades
	Trades []*SettlementTrade `protobuf:"bytes,1,rep,name=trades,proto3" json:"trades,omitempty"`
	// Total pending volume (quote, decimal string)
	TotalPendingVolume string `protobuf:"bytes,2,opt,name=total_pending_volume,json=totalPendingVolume,proto3" json:"total_pending_volume,omitempty"`
	// Pagination
	Pagination    *common.PaginationResponse `protobuf:"bytes,3,opt,name=pagination,proto3" json:"pagination,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListPendingTradesResponse) Reset() {
	*x = ListPendingTradesResponse{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListPendingTradesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPendingTradesResponse) ProtoMessage() {}

func (x *ListPendingTradesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPendingTradesResponse.ProtoReflect.Descriptor instead.
func (*ListPendingTradesResponse) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{19}
}

func (x *ListPendingTradesResponse) GetTrades() []*SettlementTrade {
	if x != nil {
		return x.Trades
	}
	return nil
}

func (x *ListPendingTradesResponse) GetTotalPendingVolume() string {
	if x != nil {
		return x.TotalPendingVolume
	}
	return ""
}

func (x *ListPendingTradesResponse) GetPagination() *common.PaginationResponse {
	if x != nil {
		return x.Pagination
	}
	return nil
}

// GetSettlementStatsRequest is the request to get settlement stats
type GetSettlementStatsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Time period in hours (default 24)
	PeriodHours int32 `protobuf:"varint,1,opt,name=period_hours,json=periodHours,proto3" json:"period_hours,omitempty"`
	// Filter by market (optional)
	Market        string `protobuf:"bytes,2,opt,name=market,proto3" json:"market,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetSettlementStatsRequest) Reset() {
	*x = GetSettlementStatsRequest{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSettlementStatsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSettlementStatsRequest) ProtoMessage() {}

func (x *GetSettlementStatsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSettlementStatsRequest.ProtoReflect.Descriptor instead.
func (*GetSettlementStatsRequest) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{20}
}

func (x *GetSettlementStatsRequest) GetPeriodHours() int32 {
	if x != nil {
		return x.PeriodHours
	}
	return 0
}

func (x *GetSettlementStatsRequest) GetMarket() string {
	if x != nil {
		return x.Market
	}
	return ""
}

// GetSettlementStatsResponse contains settlement statistics
type GetSettlementStatsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Time period start (Unix milliseconds)
	PeriodStart int64 `protobuf:"varint,1,opt,name=period_start,json=periodStart,proto3" json:"period_start,omitempty"`
	// Time period end (Unix milliseconds)
	PeriodEnd int64 `protobuf:"varint,2,opt,name=period_end,json=periodEnd,proto3" json:"period_end,omitempty"`
	// Total trades matched
	TradesMatched int64 `protobuf:"varint,3,opt,name=trades_matched,json=tradesMatched,proto3" json:"trades_matched,omitempty"`
	// Total trades settled
	TradesSettled int64 `protobuf:"varint,4,opt,name=trades_settled,json=tradesSettled,proto3" json:"trades_settled,omitempty"`
	// Total trades pending
	TradesPending int64 `protobuf:"varint,5,opt,name=trades_pending,json=tradesPending,proto3" json:"trades_pending,omitempty"`
	// Total trades failed
	TradesFailed int64 `protobuf:"varint,6,opt,name=trades_failed,json=tradesFailed,proto3" json:"trades_failed,omitempty"`
	// Total batches created
	BatchesCreated int64 `protobuf:"varint,7,opt,name=batches_created,json=batchesCreated,proto3" json:"batches_created,omitempty"`
	// Total batches confirmed
	BatchesConfirmed int64 `protobuf:"varint,8,opt,name=batches_confirmed,json=batchesConfirmed,proto3" json:"batches_confirmed,omitempty"`
	// Total batches failed
	BatchesFailed int64 `protobuf:"varint,9,opt,name=batches_failed,json=batchesFailed,proto3" json:"batches_failed,omitempty"`
	// Average batch size
	AvgBatchSize float64 `protobuf:"fixed64,10,opt,name=avg_batch_size,json=avgBatchSize,proto3" json:"avg_batch_size,omitempty"`
	// Average settlement time (seconds)
	AvgSettlementTimeSeconds float64 `protobuf:"fixed64,11,opt,name=avg_settlement_time_seconds,json=avgSettlementTimeSeconds,proto3" json:"avg_settlement_time_seconds,omitempty"`
	// P99 settlement time (seconds)
	P99SettlementTimeSeconds float64 `protobuf:"fixed64,12,opt,name=p99_settlement_time_seconds,json=p99SettlementTimeSeconds,proto3" json:"p99_settlement_time_seconds,omitempty"`
	// Total gas spent (wei, decimal string)
	TotalGasSpent string `protobuf:"bytes,13,opt,name=total_gas_spent,json=totalGasSpent,proto3" json:"total_gas_spent,omitempty"`
	// Average gas per trade (wei, decimal string)
	AvgGasPerTrade string `protobuf:"bytes,14,opt,name=avg_gas_per_trade,json=avgGasPerTrade,proto3" json:"avg_gas_per_trade,omitempty"`
	// Total volume settled (quote, decimal string)
	TotalVolumeSettled string `protobuf:"bytes,15,opt,name=total_volume_settled,json=totalVolumeSettled,proto3" json:"total_volume_settled,omitempty"`
	// Per-market statistics
	MarketStats   []*MarketSettlementStats `protobuf:"bytes,16,rep,name=market_stats,json=marketStats,proto3" json:"market_stats,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetSettlementStatsResponse) Reset() {
	*x = GetSettlementStatsResponse{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSettlementStatsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSettlementStatsResponse) ProtoMessage() {}

func (x *GetSettlementStatsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSettlementStatsResponse.ProtoReflect.Descriptor instead.
func (*GetSettlementStatsResponse) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{21}
}

func (x *GetSettlementStatsResponse) GetPeriodStart() int64 {
	if x != nil {
		return x.PeriodStart
	}
	return 0
}

func (x *GetSettlementStatsResponse) GetPeriodEnd() int64 {
	if x != nil {
		return x.PeriodEnd
	}
	return 0
}

func (x *GetSettlementStatsResponse) GetTradesMatched() int64 {
	if x != nil {
		return x.TradesMatched
	}
	return 0
}

func (x *GetSettlementStatsResponse) GetTradesSettled() int64 {
	if x != nil {
		return x.TradesSettled
	}
	return 0
}

func (x *GetSettlementStatsResponse) GetTradesPending() int64 {
	if x != nil {
		return x.TradesPending
	}
	return 0
}

func (x *GetSettlementStatsResponse) GetTradesFailed() int64 {
	if x != nil {
		return x.TradesFailed
	}
	return 0
}

func (x *GetSettlementStatsResponse) GetBatchesCreated() int64 {
	if x != nil {
		return x.BatchesCreated
	}
	return 0
}

func (x *GetSettlementStatsResponse) GetBatchesConfirmed() int64 {
	if x != nil {
		return x.BatchesConfirmed
	}
	return 0
}

func (x *GetSettlementStatsResponse) GetBatchesFailed() int64 {
	if x != nil {
		return x.BatchesFailed
	}
	return 0
}

func (x *GetSettlementStatsResponse) GetAvgBatchSize() float64 {
	if x != nil {
		return x.AvgBatchSize
	}
	return 0
}

func (x *GetSettlementStatsResponse) GetAvgSettlementTimeSeconds() float64 {
	if x != nil {
		return x.AvgSettlementTimeSeconds
	}
	return 0
}

func (x *GetSettlementStatsResponse) GetP99SettlementTimeSeconds() float64 {
	if x != nil {
		return x.P99SettlementTimeSeconds
	}
	return 0
}

func (x *GetSettlementStatsResponse) GetTotalGasSpent() string {
	if x != nil {
		return x.TotalGasSpent
	}
	return ""
}

func (x *GetSettlementStatsResponse) GetAvgGasPerTrade() string {
	if x != nil {
		return x.AvgGasPerTrade
	}
	return ""
}

func (x *GetSettlementStatsResponse) GetTotalVolumeSettled() string {
	if x != nil {
		return x.TotalVolumeSettled
	}
	return ""
}

func (x *GetSettlementStatsResponse) GetMarketStats() []*MarketSettlementStats {
	if x != nil {
		return x.MarketStats
	}
	return nil
}

// MarketSettlementStats contains per-market statistics
type MarketSettlementStats struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Trading pair symbol
	Market string `protobuf:"bytes,1,opt,name=market,proto3" json:"market,omitempty"`
	// Trades settled
	TradesSettled int64 `protobuf:"varint,2,opt,name=trades_settled,json=tradesSettled,proto3" json:"trades_settled,omitempty"`
	// Trades pending
	TradesPending int64 `protobuf:"varint,3,opt,name=trades_pending,json=tradesPending,proto3" json:"trades_pending,omitempty"`
	// Volume settled (quote, decimal string)
	VolumeSettled string `protobuf:"bytes,4,opt,name=volume_settled,json=volumeSettled,proto3" json:"volume_settled,omitempty"`
	// Average settlement time (seconds)
	AvgSettlementTimeSeconds float64 `protobuf:"fixed64,5,opt,name=avg_settlement_time_seconds,json=avgSettlementTimeSeconds,proto3" json:"avg_settlement_time_seconds,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *MarketSettlementStats) Reset() {
	*x = MarketSettlementStats{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MarketSettlementStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MarketSettlementStats) ProtoMessage() {}

func (x *MarketSettlementStats) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MarketSettlementStats.ProtoReflect.Descriptor instead.
func (*MarketSettlementStats) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{22}
}

func (x *MarketSettlementStats) GetMarket() string {
	if x != nil {
		return x.Market
	}
	return ""
}

func (x *MarketSettlementStats) GetTradesSettled() int64 {
	if x != nil {
		return x.TradesSettled
	}
	return 0
}

func (x *MarketSettlementStats) GetTradesPending() int64 {
	if x != nil {
		return x.TradesPending
	}
	return 0
}

func (x *MarketSettlementStats) GetVolumeSettled() string {
	if x != nil {
		return x.VolumeSettled
	}
	return ""
}

func (x *MarketSettlementStats) GetAvgSettlementTimeSeconds() float64 {
	if x != nil {
		return x.AvgSettlementTimeSeconds
	}
	return 0
}

// GetBatcherStatusRequest is the request to get batcher status
type GetBatcherStatusRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetBatcherStatusRequest) Reset() {
	*x = GetBatcherStatusRequest{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetBatcherStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetBatcherStatusRequest) ProtoMessage() {}

func (x *GetBatcherStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetBatcherStatusRequest.ProtoReflect.Descriptor instead.
func (*GetBatcherStatusRequest) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{23}
}

// GetBatcherStatusResponse contains batcher status
type GetBatcherStatusResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether batcher is running
	IsRunning bool `protobuf:"varint,1,opt,name=is_running,json=isRunning,proto3" json:"is_running,omitempty"`
	// Whether batcher is paused
	IsPaused bool `protobuf:"varint,2,opt,name=is_paused,json=isPaused,proto3" json:"is_paused,omitempty"`
	// Current pending trade count
	PendingTradeCount int64 `protobuf:"varint,3,opt,name=pending_trade_count,json=pendingTradeCount,proto3" json:"pending_trade_count,omitempty"`
	// Current pending batch count
	PendingBatchCount int64 `protobuf:"varint,4,opt,name=pending_batch_count,json=pendingBatchCount,proto3" json:"pending_batch_count,omitempty"`
	// Current in-flight batch count
	InflightBatchCount int64 `protobuf:"varint,5,opt,name=inflight_batch_count,json=inflightBatchCount,proto3" json:"inflight_batch_count,omitempty"`
	// Last batch created timestamp (Unix milliseconds)
	LastBatchCreatedAt int64 `protobuf:"varint,6,opt,name=last_batch_created_at,json=lastBatchCreatedAt,proto3" json:"last_batch_created_at,omitempty"`
	// Last batch confirmed timestamp (Unix milliseconds)
	LastBatchConfirmedAt int64 `protobuf:"varint,7,opt,name=last_batch_confirmed_at,json=lastBatchConfirmedAt,proto3" json:"last_batch_confirmed_at,omitempty"`
	// Batcher configuration
	Config *BatcherConfig `protobuf:"bytes,8,opt,name=config,proto3" json:"config,omitempty"`
	// Per-chain status
	ChainStatus   []*ChainBatcherStatus `protobuf:"bytes,9,rep,name=chain_status,json=chainStatus,proto3" json:"chain_status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetBatcherStatusResponse) Reset() {
	*x = GetBatcherStatusResponse{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetBatcherStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetBatcherStatusResponse) ProtoMessage() {}

func (x *GetBatcherStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetBatcherStatusResponse.ProtoReflect.Descriptor instead.
func (*GetBatcherStatusResponse) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{24}
}

func (x *GetBatcherStatusResponse) GetIsRunning() bool {
	if x != nil {
		return x.IsRunning
	}
	return false
}

func (x *GetBatcherStatusResponse) GetIsPaused() bool {
	if x != nil {
		return x.IsPaused
	}
	return false
}

func (x *GetBatcherStatusResponse) GetPendingTradeCount() int64 {
	if x != nil {
		return x.PendingTradeCount
	}
	return 0
}

func (x *GetBatcherStatusResponse) GetPendingBatchCount() int64 {
	if x != nil {
		return x.PendingBatchCount
	}
	return 0
}

func (x *GetBatcherStatusResponse) GetInflightBatchCount() int64 {
	if x != nil {
		return x.InflightBatchCount
	}
	return 0
}

func (x *GetBatcherStatusResponse) GetLastBatchCreatedAt() int64 {
	if x != nil {
		return x.LastBatchCreatedAt
	}
	return 0
}

func (x *GetBatcherStatusResponse) GetLastBatchConfirmedAt() int64 {
	if x != nil {
		return x.LastBatchConfirmedAt
	}
	return 0
}

func (x *GetBatcherStatusResponse) GetConfig() *BatcherConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *GetBatcherStatusResponse) GetChainStatus() []*ChainBatcherStatus {
	if x != nil {
		return x.ChainStatus
	}
	return nil
}

// BatcherConfig contains batcher configuration
type BatcherConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Maximum trades per batch
	MaxBatchSize int32 `protobuf:"varint,1,opt,name=max_batch_size,json=maxBatchSize,proto3" json:"max_batch_size,omitempty"`
	// Batch interval in seconds
	BatchIntervalSeconds int32 `protobuf:"varint,2,opt,name=batch_interval_seconds,json=batchIntervalSeconds,proto3" json:"batch_interval_seconds,omitempty"`
	// Maximum concurrent batches
	MaxConcurrentBatches int32 `protobuf:"varint,3,opt,name=max_concurrent_batches,json=maxConcurrentBatches,proto3" json:"max_concurrent_batches,omitempty"`
	// Confirmation blocks required
	ConfirmationBlocks int32 `protobuf:"varint,4,opt,name=confirmation_blocks,json=confirmationBlocks,proto3" json:"confirmation_blocks,omitempty"`
	// Gas price strategy (auto, fixed, aggressive)
	GasStrategy string `protobuf:"bytes,5,opt,name=gas_strategy,json=gasStrategy,proto3" json:"gas_strategy,omitempty"`
	// Maximum gas price (wei, decimal string)
	MaxGasPrice   string `protobuf:"bytes,6,opt,name=max_gas_price,json=maxGasPrice,proto3" json:"max_gas_price,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatcherConfig) Reset() {
	*x = BatcherConfig{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatcherConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatcherConfig) ProtoMessage() {}

func (x *BatcherConfig) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatcherConfig.ProtoReflect.Descriptor instead.
func (*BatcherConfig) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{25}
}

func (x *BatcherConfig) GetMaxBatchSize() int32 {
	if x != nil {
		return x.MaxBatchSize
	}
	return 0
}

func (x *BatcherConfig) GetBatchIntervalSeconds() int32 {
	if x != nil {
		return x.BatchIntervalSeconds
	}
	return 0
}

func (x *BatcherConfig) GetMaxConcurrentBatches() int32 {
	if x != nil {
		return x.MaxConcurrentBatches
	}
	return 0
}

func (x *BatcherConfig) GetConfirmationBlocks() int32 {
	if x != nil {
		return x.ConfirmationBlocks
	}
	return 0
}

func (x *BatcherConfig) GetGasStrategy() string {
	if x != nil {
		return x.GasStrategy
	}
	return ""
}

func (x *BatcherConfig) GetMaxGasPrice() string {
	if x != nil {
		return x.MaxGasPrice
	}
	return ""
}

// ChainBatcherStatus contains per-chain batcher status
type ChainBatcherStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain ID
	ChainId int64 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Current block number
	CurrentBlock int64 `protobuf:"varint,2,opt,name=current_block,json=currentBlock,proto3" json:"current_block,omitempty"`
	// Hot wallet address
	WalletAddress string `protobuf:"bytes,3,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address,omitempty"`
	// Hot wallet balance (ETH, decimal string)
	WalletBalance string `protobuf:"bytes,4,opt,name=wallet_balance,json=walletBalance,proto3" json:"wallet_balance,omitempty"`
	// Current nonce
	CurrentNonce uint64 `protobuf:"varint,5,opt,name=current_nonce,json=currentNonce,proto3" json:"current_nonce,omitempty"`
	// Pending transaction count
	PendingTxCount int32 `protobuf:"varint,6,opt,name=pending_tx_count,json=pendingTxCount,proto3" json:"pending_tx_count,omitempty"`
	// Current gas price (wei, decimal string)
	CurrentGasPrice string `protobuf:"bytes,7,opt,name=current_gas_price,json=currentGasPrice,proto3" json:"current_gas_price,omitempty"`
	// Is healthy
	IsHealthy bool `protobuf:"varint,8,opt,name=is_healthy,json=isHealthy,proto3" json:"is_healthy,omitempty"`
	// Last error (if any)
	LastError     string `protobuf:"bytes,9,opt,name=last_error,json=lastError,proto3" json:"last_error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChainBatcherStatus) Reset() {
	*x = ChainBatcherStatus{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChainBatcherStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChainBatcherStatus) ProtoMessage() {}

func (x *ChainBatcherStatus) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChainBatcherStatus.ProtoReflect.Descriptor instead.
func (*ChainBatcherStatus) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{26}
}

func (x *ChainBatcherStatus) GetChainId() int64 {
	if x != nil {
		return x.ChainId
	}
	return 0
}

func (x *ChainBatcherStatus) GetCurrentBlock() int64 {
	if x != nil {
		return x.CurrentBlock
	}
	return 0
}

func (x *ChainBatcherStatus) GetWalletAddress() string {
	if x != nil {
		return x.WalletAddress
	}
	return ""
}

func (x *ChainBatcherStatus) GetWalletBalance() string {
	if x != nil {
		return x.WalletBalance
	}
	return ""
}

func (x *ChainBatcherStatus) GetCurrentNonce() uint64 {
	if x != nil {
		return x.CurrentNonce
	}
	return 0
}

func (x *ChainBatcherStatus) GetPendingTxCount() int32 {
	if x != nil {
		return x.PendingTxCount
	}
	return 0
}

func (x *ChainBatcherStatus) GetCurrentGasPrice() string {
	if x != nil {
		return x.CurrentGasPrice
	}
	return ""
}

func (x *ChainBatcherStatus) GetIsHealthy() bool {
	if x != nil {
		return x.IsHealthy
	}
	return false
}

func (x *ChainBatcherStatus) GetLastError() string {
	if x != nil {
		return x.LastError
	}
	return ""
}

// OnTradeMatchedRequest is sent when a trade is matched
type OnTradeMatchedRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Trade details
	Trade         *SettlementTrade `protobuf:"bytes,1,opt,name=trade,proto3" json:"trade,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OnTradeMatchedRequest) Reset() {
	*x = OnTradeMatchedRequest{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OnTradeMatchedRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OnTradeMatchedRequest) ProtoMessage() {}

func (x *OnTradeMatchedRequest) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OnTradeMatchedRequest.ProtoReflect.Descriptor instead.
func (*OnTradeMatchedRequest) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{27}
}

func (x *OnTradeMatchedRequest) GetTrade() *SettlementTrade {
	if x != nil {
		return x.Trade
	}
	return nil
}

// OnTradeMatchedResponse is the response
type OnTradeMatchedResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether trade was queued for settlement
	Queued        bool `protobuf:"varint,1,opt,name=queued,proto3" json:"queued,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OnTradeMatchedResponse) Reset() {
	*x = OnTradeMatchedResponse{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OnTradeMatchedResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OnTradeMatchedResponse) ProtoMessage() {}

func (x *OnTradeMatchedResponse) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OnTradeMatchedResponse.ProtoReflect.Descriptor instead.
func (*OnTradeMatchedResponse) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{28}
}

func (x *OnTradeMatchedResponse) GetQueued() bool {
	if x != nil {
		return x.Queued
	}
	return false
}

// OnBatchSubmittedRequest is sent when a batch is submitted
type OnBatchSubmittedRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Batch ID
	BatchId string `protobuf:"bytes,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// Transaction hash
	TxHash string `protobuf:"bytes,2,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	// Nonce used
	Nonce uint64 `protobuf:"varint,3,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Gas price (wei, decimal string)
	GasPrice string `protobuf:"bytes,4,opt,name=gas_price,json=gasPrice,proto3" json:"gas_price,omitempty"`
	// Submission timestamp (Unix milliseconds)
	SubmittedAt   int64 `protobuf:"varint,5,opt,name=submitted_at,json=submittedAt,proto3" json:"submitted_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OnBatchSubmittedRequest) Reset() {
	*x = OnBatchSubmittedRequest{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OnBatchSubmittedRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OnBatchSubmittedRequest) ProtoMessage() {}

func (x *OnBatchSubmittedRequest) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OnBatchSubmittedRequest.ProtoReflect.Descriptor instead.
func (*OnBatchSubmittedRequest) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{29}
}

func (x *OnBatchSubmittedRequest) GetBatchId() string {
	if x != nil {
		return x.BatchId
	}
	return ""
}

func (x *OnBatchSubmittedRequest) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *OnBatchSubmittedRequest) GetNonce() uint64 {
	if x != nil {
		return x.Nonce
	}
	return 0
}

func (x *OnBatchSubmittedRequest) GetGasPrice() string {
	if x != nil {
		return x.GasPrice
	}
	return ""
}

func (x *OnBatchSubmittedRequest) GetSubmittedAt() int64 {
	if x != nil {
		return x.SubmittedAt
	}
	return 0
}

// OnBatchSubmittedResponse is the response
type OnBatchSubmittedResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether update was successful
	Success       bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OnBatchSubmittedResponse) Reset() {
	*x = OnBatchSubmittedResponse{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OnBatchSubmittedResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OnBatchSubmittedResponse) ProtoMessage() {}

func (x *OnBatchSubmittedResponse) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OnBatchSubmittedResponse.ProtoReflect.Descriptor instead.
func (*OnBatchSubmittedResponse) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{30}
}

func (x *OnBatchSubmittedResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

// OnBatchConfirmedRequest is sent when a batch is confirmed
type OnBatchConfirmedRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Batch ID
	BatchId string `protobuf:"bytes,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// Transaction hash
	TxHash string `protobuf:"bytes,2,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	// Block number
	BlockNumber int64 `protobuf:"varint,3,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	// Gas used
	GasUsed int64 `protobuf:"varint,4,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
	// Effective gas price (wei, decimal string)
	EffectiveGasPrice string `protobuf:"bytes,5,opt,name=effective_gas_price,json=effectiveGasPrice,proto3" json:"effective_gas_price,omitempty"`
	// Confirmation timestamp (Unix milliseconds)
	ConfirmedAt   int64 `protobuf:"varint,6,opt,name=confirmed_at,json=confirmedAt,proto3" json:"confirmed_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OnBatchConfirmedRequest) Reset() {
	*x = OnBatchConfirmedRequest{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OnBatchConfirmedRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OnBatchConfirmedRequest) ProtoMessage() {}

func (x *OnBatchConfirmedRequest) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OnBatchConfirmedRequest.ProtoReflect.Descriptor instead.
func (*OnBatchConfirmedRequest) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{31}
}

func (x *OnBatchConfirmedRequest) GetBatchId() string {
	if x != nil {
		return x.BatchId
	}
	return ""
}

func (x *OnBatchConfirmedRequest) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *OnBatchConfirmedRequest) GetBlockNumber() int64 {
	if x != nil {
		return x.BlockNumber
	}
	return 0
}

func (x *OnBatchConfirmedRequest) GetGasUsed() int64 {
	if x != nil {
		return x.GasUsed
	}
	return 0
}

func (x *OnBatchConfirmedRequest) GetEffectiveGasPrice() string {
	if x != nil {
		return x.EffectiveGasPrice
	}
	return ""
}

func (x *OnBatchConfirmedRequest) GetConfirmedAt() int64 {
	if x != nil {
		return x.ConfirmedAt
	}
	return 0
}

// OnBatchConfirmedResponse is the response
type OnBatchConfirmedResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether update was successful
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Number of trades confirmed
	TradesConfirmed int32 `protobuf:"varint,2,opt,name=trades_confirmed,json=tradesConfirmed,proto3" json:"trades_confirmed,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *OnBatchConfirmedResponse) Reset() {
	*x = OnBatchConfirmedResponse{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OnBatchConfirmedResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OnBatchConfirmedResponse) ProtoMessage() {}

func (x *OnBatchConfirmedResponse) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OnBatchConfirmedResponse.ProtoReflect.Descriptor instead.
func (*OnBatchConfirmedResponse) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{32}
}

func (x *OnBatchConfirmedResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *OnBatchConfirmedResponse) GetTradesConfirmed() int32 {
	if x != nil {
		return x.TradesConfirmed
	}
	return 0
}

// OnBatchFailedRequest is sent when a batch fails
type OnBatchFailedRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Batch ID
	BatchId string `protobuf:"bytes,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// Error code
	ErrorCode string `protobuf:"bytes,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	// Error message
	ErrorMessage string `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Whether batch can be retried
	CanRetry bool `protobuf:"varint,4,opt,name=can_retry,json=canRetry,proto3" json:"can_retry,omitempty"`
	// Failure timestamp (Unix milliseconds)
	FailedAt      int64 `protobuf:"varint,5,opt,name=failed_at,json=failedAt,proto3" json:"failed_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OnBatchFailedRequest) Reset() {
	*x = OnBatchFailedRequest{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OnBatchFailedRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OnBatchFailedRequest) ProtoMessage() {}

func (x *OnBatchFailedRequest) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OnBatchFailedRequest.ProtoReflect.Descriptor instead.
func (*OnBatchFailedRequest) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{33}
}

func (x *OnBatchFailedRequest) GetBatchId() string {
	if x != nil {
		return x.BatchId
	}
	return ""
}

func (x *OnBatchFailedRequest) GetErrorCode() string {
	if x != nil {
		return x.ErrorCode
	}
	return ""
}

func (x *OnBatchFailedRequest) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *OnBatchFailedRequest) GetCanRetry() bool {
	if x != nil {
		return x.CanRetry
	}
	return false
}

func (x *OnBatchFailedRequest) GetFailedAt() int64 {
	if x != nil {
		return x.FailedAt
	}
	return 0
}

// OnBatchFailedResponse is the response
type OnBatchFailedResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether update was successful
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Action taken (retry, split, rollback)
	Action        string `protobuf:"bytes,2,opt,name=action,proto3" json:"action,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OnBatchFailedResponse) Reset() {
	*x = OnBatchFailedResponse{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OnBatchFailedResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OnBatchFailedResponse) ProtoMessage() {}

func (x *OnBatchFailedResponse) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OnBatchFailedResponse.ProtoReflect.Descriptor instead.
func (*OnBatchFailedResponse) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{34}
}

func (x *OnBatchFailedResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *OnBatchFailedResponse) GetAction() string {
	if x != nil {
		return x.Action
	}
	return ""
}

// SettlementRequestMessage is published to request settlement (Kafka: settlement-requests)
type SettlementRequestMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Trade to settle
	Trade *SettlementTrade `protobuf:"bytes,1,opt,name=trade,proto3" json:"trade,omitempty"`
	// Priority level
	Priority int32 `protobuf:"varint,2,opt,name=priority,proto3" json:"priority,omitempty"`
	// Request timestamp (Unix milliseconds)
	RequestedAt   int64 `protobuf:"varint,3,opt,name=requested_at,json=requestedAt,proto3" json:"requested_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SettlementRequestMessage) Reset() {
	*x = SettlementRequestMessage{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SettlementRequestMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SettlementRequestMessage) ProtoMessage() {}

func (x *SettlementRequestMessage) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SettlementRequestMessage.ProtoReflect.Descriptor instead.
func (*SettlementRequestMessage) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{35}
}

func (x *SettlementRequestMessage) GetTrade() *SettlementTrade {
	if x != nil {
		return x.Trade
	}
	return nil
}

func (x *SettlementRequestMessage) GetPriority() int32 {
	if x != nil {
		return x.Priority
	}
	return 0
}

func (x *SettlementRequestMessage) GetRequestedAt() int64 {
	if x != nil {
		return x.RequestedAt
	}
	return 0
}

// BatchCreatedMessage is published when batch is created (Kafka: settlement-batches)
type BatchCreatedMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Batch details
	Batch         *SettlementBatch `protobuf:"bytes,1,opt,name=batch,proto3" json:"batch,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchCreatedMessage) Reset() {
	*x = BatchCreatedMessage{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchCreatedMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchCreatedMessage) ProtoMessage() {}

func (x *BatchCreatedMessage) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchCreatedMessage.ProtoReflect.Descriptor instead.
func (*BatchCreatedMessage) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{36}
}

func (x *BatchCreatedMessage) GetBatch() *SettlementBatch {
	if x != nil {
		return x.Batch
	}
	return nil
}

// BatchStatusMessage is published on batch status change (Kafka: settlement-status)
type BatchStatusMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Batch ID
	BatchId string `protobuf:"bytes,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// New status
	Status common.BatchStatus `protobuf:"varint,2,opt,name=status,proto3,enum=eidos.common.v1.BatchStatus" json:"status,omitempty"`
	// Previous status
	PreviousStatus common.BatchStatus `protobuf:"varint,3,opt,name=previous_status,json=previousStatus,proto3,enum=eidos.common.v1.BatchStatus" json:"previous_status,omitempty"`
	// Transaction hash (if applicable)
	TxHash string `protobuf:"bytes,4,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	// Error message (if failed)
	ErrorMessage string `protobuf:"bytes,5,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Status change timestamp (Unix milliseconds)
	UpdatedAt     int64 `protobuf:"varint,6,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchStatusMessage) Reset() {
	*x = BatchStatusMessage{}
	mi := &file_settlement_v1_settlement_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchStatusMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchStatusMessage) ProtoMessage() {}

func (x *BatchStatusMessage) ProtoReflect() protoreflect.Message {
	mi := &file_settlement_v1_settlement_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchStatusMessage.ProtoReflect.Descriptor instead.
func (*BatchStatusMessage) Descriptor() ([]byte, []int) {
	return file_settlement_v1_settlement_proto_rawDescGZIP(), []int{37}
}

func (x *BatchStatusMessage) GetBatchId() string {
	if x != nil {
		return x.BatchId
	}
	return ""
}

func (x *BatchStatusMessage) GetStatus() common.BatchStatus {
	if x != nil {
		return x.Status
	}
	return common.BatchStatus(0)
}

func (x *BatchStatusMessage) GetPreviousStatus() common.BatchStatus {
	if x != nil {
		return x.PreviousStatus
	}
	return common.BatchStatus(0)
}

func (x *BatchStatusMessage) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *BatchStatusMessage) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *BatchStatusMessage) GetUpdatedAt() int64 {
	if x != nil {
		return x.UpdatedAt
	}
	return 0
}

var File_settlement_v1_settlement_proto protoreflect.FileDescriptor

const file_settlement_v1_settlement_proto_rawDesc = "" +
	"\n" +
	"\x1esettlement/v1/settlement.proto\x12\x13eidos.settlement.v1\x1a\x12common/enums.proto\x1a\x17common/pagination.proto\"\x84\x06\n" +
	"\x0fSettlementBatch\x12\x19\n" +
	"\bbatch_id\x18\x01 \x01(\tR\abatchId\x12\x1f\n" +
	"\vtrade_count\x18\x02 \x01(\x05R\n" +
	"tradeCount\x12\x1b\n" +
	"\ttrade_ids\x18\x03 \x03(\tR\btradeIds\x124\n" +
	"\x06status\x18\x04 \x01(\x0e2\x1c.eidos.common.v1.BatchStatusR\x06status\x12\x19\n" +
	"\bchain_id\x18\x05 \x01(\x03R\achainId\x12)\n" +
	"\x10contract_address\x18\x06 \x01(\tR\x0fcontractAddress\x12\x17\n" +
	"\atx_hash\x18\a \x01(\tR\x06txHash\x12!\n" +
	"\fblock_number\x18\b \x01(\x03R\vblockNumber\x12\x19\n" +
	"\bgas_used\x18\t \x01(\x03R\agasUsed\x12\x1b\n" +
	"\tgas_price\x18\n" +
	" \x01(\tR\bgasPrice\x12.\n" +
	"\x13effective_gas_price\x18\v \x01(\tR\x11effectiveGasPrice\x12\x14\n" +
	"\x05nonce\x18\f \x01(\x04R\x05nonce\x12\x1f\n" +
	"\vretry_count\x18\r \x01(\x05R\n" +
	"retryCount\x12\x1f\n" +
	"\vmax_retries\x18\x0e \x01(\x05R\n" +
	"maxRetries\x12#\n" +
	"\rerror_message\x18\x0f \x01(\tR\ferrorMessage\x12\x1d\n" +
	"\n" +
	"error_code\x18\x10 \x01(\tR\terrorCode\x12*\n" +
	"\x11total_base_volume\x18\x11 \x01(\tR\x0ftotalBaseVolume\x12,\n" +
	"\x12total_quote_volume\x18\x12 \x01(\tR\x10totalQuoteVolume\x12\x1d\n" +
	"\n" +
	"created_at\x18\x13 \x01(\x03R\tcreatedAt\x12!\n" +
	"\fsubmitted_at\x18\x14 \x01(\x03R\vsubmittedAt\x12!\n" +
	"\fconfirmed_at\x18\x15 \x01(\x03R\vconfirmedAt\x12\x1d\n" +
	"\n" +
	"updated_at\x18\x16 \x01(\x03R\tupdatedAt\",\n" +
	"\x0fGetBatchRequest\x12\x19\n" +
	"\bbatch_id\x18\x01 \x01(\tR\abatchId\"N\n" +
	"\x10GetBatchResponse\x12:\n" +
	"\x05batch\x18\x01 \x01(\v2$.eidos.settlement.v1.SettlementBatchR\x05batch\"\xe3\x01\n" +
	"\x12ListBatchesRequest\x124\n" +
	"\x06status\x18\x01 \x01(\x0e2\x1c.eidos.common.v1.BatchStatusR\x06status\x12\x19\n" +
	"\bchain_id\x18\x02 \x01(\x03R\achainId\x12\x1d\n" +
	"\n" +
	"start_time\x18\x03 \x01(\x03R\tstartTime\x12\x19\n" +
	"\bend_time\x18\x04 \x01(\x03R\aendTime\x12B\n" +
	"\n" +
	"pagination\x18\x05 \x01(\v2\".eidos.common.v1.PaginationRequestR\n" +
	"pagination\"\x9a\x01\n" +
	"\x13ListBatchesResponse\x12>\n" +
	"\abatches\x18\x01 \x03(\v2$.eidos.settlement.v1.SettlementBatchR\abatches\x12C\n" +
	"\n" +
	"pagination\x18\x02 \x01(\v2#.eidos.common.v1.PaginationResponseR\n" +
	"pagination\"y\n" +
	"\x18ListTradesInBatchRequest\x12\x19\n" +
	"\bbatch_id\x18\x01 \x01(\tR\abatchId\x12B\n" +
	"\n" +
	"pagination\x18\x02 \x01(\v2\".eidos.common.v1.PaginationRequestR\n" +
	"pagination\"\x9e\x01\n" +
	"\x19ListTradesInBatchResponse\x12<\n" +
	"\x06trades\x18\x01 \x03(\v2$.eidos.settlement.v1.SettlementTradeR\x06trades\x12C\n" +
	"\n" +
	"pagination\x18\x02 \x01(\v2#.eidos.common.v1.PaginationResponseR\n" +
	"pagination\"\xa0\x05\n" +
	"\x0fSettlementTrade\x12\x19\n" +
	"\btrade_id\x18\x01 \x01(\tR\atradeId\x12\x16\n" +
	"\x06market\x18\x02 \x01(\tR\x06market\x12!\n" +
	"\fmaker_wallet\x18\x03 \x01(\tR\vmakerWallet\x12!\n" +
	"\ftaker_wallet\x18\x04 \x01(\tR\vtakerWallet\x12\x1d\n" +
	"\n" +
	"base_token\x18\x05 \x01(\tR\tbaseToken\x12\x1f\n" +
	"\vquote_token\x18\x06 \x01(\tR\n" +
	"quoteToken\x12,\n" +
	"\x12base_token_address\x18\a \x01(\tR\x10baseTokenAddress\x12.\n" +
	"\x13quote_token_address\x18\b \x01(\tR\x11quoteTokenAddress\x12\x14\n" +
	"\x05price\x18\t \x01(\tR\x05price\x12\x1f\n" +
	"\vbase_amount\x18\n" +
	" \x01(\tR\n" +
	"baseAmount\x12!\n" +
	"\fquote_amount\x18\v \x01(\tR\vquoteAmount\x129\n" +
	"\n" +
	"taker_side\x18\f \x01(\x0e2\x1a.eidos.common.v1.OrderSideR\ttakerSide\x12\x1b\n" +
	"\tmaker_fee\x18\r \x01(\tR\bmakerFee\x12\x1b\n" +
	"\ttaker_fee\x18\x0e \x01(\tR\btakerFee\x12N\n" +
	"\x11settlement_status\x18\x0f \x01(\x0e2!.eidos.common.v1.SettlementStatusR\x10settlementStatus\x12\x19\n" +
	"\bbatch_id\x18\x10 \x01(\tR\abatchId\x12\x1d\n" +
	"\n" +
	"matched_at\x18\x11 \x01(\x03R\tmatchedAt\x12\x1d\n" +
	"\n" +
	"settled_at\x18\x12 \x01(\x03R\tsettledAt\"\x96\x01\n" +
	"\x18TriggerSettlementRequest\x12\x16\n" +
	"\x06market\x18\x01 \x01(\tR\x06market\x12\x1d\n" +
	"\n" +
	"max_trades\x18\x02 \x01(\x05R\tmaxTrades\x12\x1a\n" +
	"\bpriority\x18\x03 \x01(\x05R\bpriority\x12'\n" +
	"\x0fforce_immediate\x18\x04 \x01(\bR\x0eforceImmediate\"\x8d\x01\n" +
	"\x19TriggerSettlementResponse\x12\x1a\n" +
	"\baccepted\x18\x01 \x01(\bR\baccepted\x12\x19\n" +
	"\bbatch_id\x18\x02 \x01(\tR\abatchId\x12\x1f\n" +
	"\vtrade_count\x18\x03 \x01(\x05R\n" +
	"tradeCount\x12\x18\n" +
	"\amessage\x18\x04 \x01(\tR\amessage\"X\n" +
	"\x11RetryBatchRequest\x12\x19\n" +
	"\bbatch_id\x18\x01 \x01(\tR\abatchId\x12(\n" +
	"\x10gas_bump_percent\x18\x02 \x01(\x05R\x0egasBumpPercent\"j\n" +
	"\x12RetryBatchResponse\x12\x1a\n" +
	"\baccepted\x18\x01 \x01(\bR\baccepted\x12\x1e\n" +
	"\vnew_tx_hash\x18\x02 \x01(\tR\tnewTxHash\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\"O\n" +
	"\x11SplitBatchRequest\x12\x19\n" +
	"\bbatch_id\x18\x01 \x01(\tR\abatchId\x12\x1f\n" +
	"\vsplit_count\x18\x02 \x01(\x05R\n" +
	"splitCount\"l\n" +
	"\x12SplitBatchResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\"\n" +
	"\rnew_batch_ids\x18\x02 \x03(\tR\vnewBatchIds\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\"j\n" +
	"\x14RollbackBatchRequest\x12\x19\n" +
	"\bbatch_id\x18\x01 \x01(\tR\abatchId\x12\x16\n" +
	"\x06reason\x18\x02 \x01(\tR\x06reason\x12\x1f\n" +
	"\voperator_id\x18\x03 \x01(\tR\n" +
	"operatorId\"y\n" +
	"\x15RollbackBatchResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12,\n" +
	"\x12trades_rolled_back\x18\x02 \x01(\x05R\x10tradesRolledBack\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\"6\n" +
	"\x19GetTradeSettlementRequest\x12\x19\n" +
	"\btrade_id\x18\x01 \x01(\tR\atradeId\"\x94\x01\n" +
	"\x1aGetTradeSettlementResponse\x12:\n" +
	"\x05trade\x18\x01 \x01(\v2$.eidos.settlement.v1.SettlementTradeR\x05trade\x12:\n" +
	"\x05batch\x18\x02 \x01(\v2$.eidos.settlement.v1.SettlementBatchR\x05batch\"\xb6\x01\n" +
	"\x18ListPendingTradesRequest\x12\x16\n" +
	"\x06market\x18\x01 \x01(\tR\x06market\x12\x16\n" +
	"\x06wallet\x18\x02 \x01(\tR\x06wallet\x12&\n" +
	"\x0fmin_age_seconds\x18\x03 \x01(\x03R\rminAgeSeconds\x12B\n" +
	"\n" +
	"pagination\x18\x04 \x01(\v2\".eidos.common.v1.PaginationRequestR\n" +
	"pagination\"\xd0\x01\n" +
	"\x19ListPendingTradesResponse\x12<\n" +
	"\x06trades\x18\x01 \x03(\v2$.eidos.settlement.v1.SettlementTradeR\x06trades\x120\n" +
	"\x14total_pending_volume\x18\x02 \x01(\tR\x12totalPendingVolume\x12C\n" +
	"\n" +
	"pagination\x18\x03 \x01(\v2#.eidos.common.v1.PaginationResponseR\n" +
	"pagination\"V\n" +
	"\x19GetSettlementStatsRequest\x12!\n" +
	"\fperiod_hours\x18\x01 \x01(\x05R\vperiodHours\x12\x16\n" +
	"\x06market\x18\x02 \x01(\tR\x06market\"\xed\x05\n" +
	"\x1aGetSettlementStatsResponse\x12!\n" +
	"\fperiod_start\x18\x01 \x01(\x03R\vperiodStart\x12\x1d\n" +
	"\n" +
	"period_end\x18\x02 \x01(\x03R\tperiodEnd\x12%\n" +
	"\x0etrades_matched\x18\x03 \x01(\x03R\rtradesMatched\x12%\n" +
	"\x0etrades_settled\x18\x04 \x01(\x03R\rtradesSettled\x12%\n" +
	"\x0etrades_pending\x18\x05 \x01(\x03R\rtradesPending\x12#\n" +
	"\rtrades_failed\x18\x06 \x01(\x03R\ftradesFailed\x12'\n" +
	"\x0fbatches_created\x18\a \x01(\x03R\x0ebatchesCreated\x12+\n" +
	"\x11batches_confirmed\x18\b \x01(\x03R\x10batchesConfirmed\x12%\n" +
	"\x0ebatches_failed\x18\t \x01(\x03R\rbatchesFailed\x12$\n" +
	"\x0eavg_batch_size\x18\n" +
	" \x01(\x01R\favgBatchSize\x12=\n" +
	"\x1bavg_settlement_time_seconds\x18\v \x01(\x01R\x18avgSettlementTimeSeconds\x12=\n" +
	"\x1bp99_settlement_time_seconds\x18\f \x01(\x01R\x18p99SettlementTimeSeconds\x12&\n" +
	"\x0ftotal_gas_spent\x18\r \x01(\tR\rtotalGasSpent\x12)\n" +
	"\x11avg_gas_per_trade\x18\x0e \x01(\tR\x0eavgGasPerTrade\x120\n" +
	"\x14total_volume_settled\x18\x0f \x01(\tR\x12totalVolumeSettled\x12M\n" +
	"\fmarket_stats\x18\x10 \x03(\v2*.eidos.settlement.v1.MarketSettlementStatsR\vmarketStats\"\xe3\x01\n" +
	"\x15MarketSettlementStats\x12\x16\n" +
	"\x06market\x18\x01 \x01(\tR\x06market\x12%\n" +
	"\x0etrades_settled\x18\x02 \x01(\x03R\rtradesSettled\x12%\n" +
	"\x0etrades_pending\x18\x03 \x01(\x03R\rtradesPending\x12%\n" +
	"\x0evolume_settled\x18\x04 \x01(\tR\rvolumeSettled\x12=\n" +
	"\x1bavg_settlement_time_seconds\x18\x05 \x01(\x01R\x18avgSettlementTimeSeconds\"\x19\n" +
	"\x17GetBatcherStatusRequest\"\xda\x03\n" +
	"\x18GetBatcherStatusResponse\x12\x1d\n" +
	"\n" +
	"is_running\x18\x01 \x01(\bR\tisRunning\x12\x1b\n" +
	"\tis_paused\x18\x02 \x01(\bR\bisPaused\x12.\n" +
	"\x13pending_trade_count\x18\x03 \x01(\x03R\x11pendingTradeCount\x12.\n" +
	"\x13pending_batch_count\x18\x04 \x01(\x03R\x11pendingBatchCount\x120\n" +
	"\x14inflight_batch_count\x18\x05 \x01(\x03R\x12inflightBatchCount\x121\n" +
	"\x15last_batch_created_at\x18\x06 \x01(\x03R\x12lastBatchCreatedAt\x125\n" +
	"\x17last_batch_confirmed_at\x18\a \x01(\x03R\x14lastBatchConfirmedAt\x12:\n" +
	"\x06config\x18\b \x01(\v2\".eidos.settlement.v1.BatcherConfigR\x06config\x12J\n" +
	"\fchain_status\x18\t \x03(\v2'.eidos.settlement.v1.ChainBatcherStatusR\vchainStatus\"\x99\x02\n" +
	"\rBatcherConfig\x12$\n" +
	"\x0emax_batch_size\x18\x01 \x01(\x05R\fmaxBatchSize\x124\n" +
	"\x16batch_interval_seconds\x18\x02 \x01(\x05R\x14batchIntervalSeconds\x124\n" +
	"\x16max_concurrent_batches\x18\x03 \x01(\x05R\x14maxConcurrentBatches\x12/\n" +
	"\x13confirmation_blocks\x18\x04 \x01(\x05R\x12confirmationBlocks\x12!\n" +
	"\fgas_strategy\x18\x05 \x01(\tR\vgasStrategy\x12\"\n" +
	"\rmax_gas_price\x18\x06 \x01(\tR\vmaxGasPrice\"\xdb\x02\n" +
	"\x12ChainBatcherStatus\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\x03R\achainId\x12#\n" +
	"\rcurrent_block\x18\x02 \x01(\x03R\fcurrentBlock\x12%\n" +
	"\x0ewallet_address\x18\x03 \x01(\tR\rwalletAddress\x12%\n" +
	"\x0ewallet_balance\x18\x04 \x01(\tR\rwalletBalance\x12#\n" +
	"\rcurrent_nonce\x18\x05 \x01(\x04R\fcurrentNonce\x12(\n" +
	"\x10pending_tx_count\x18\x06 \x01(\x05R\x0ependingTxCount\x12*\n" +
	"\x11current_gas_price\x18\a \x01(\tR\x0fcurrentGasPrice\x12\x1d\n" +
	"\n" +
	"is_healthy\x18\b \x01(\bR\tisHealthy\x12\x1d\n" +
	"\n" +
	"last_error\x18\t \x01(\tR\tlastError\"S\n" +
	"\x15OnTradeMatchedRequest\x12:\n" +
	"\x05trade\x18\x01 \x01(\v2$.eidos.settlement.v1.SettlementTradeR\x05trade\"0\n" +
	"\x16OnTradeMatchedResponse\x12\x16\n" +
	"\x06queued\x18\x01 \x01(\bR\x06queued\"\xa3\x01\n" +
	"\x17OnBatchSubmittedRequest\x12\x19\n" +
	"\bbatch_id\x18\x01 \x01(\tR\abatchId\x12\x17\n" +
	"\atx_hash\x18\x02 \x01(\tR\x06txHash\x12\x14\n" +
	"\x05nonce\x18\x03 \x01(\x04R\x05nonce\x12\x1b\n" +
	"\tgas_price\x18\x04 \x01(\tR\bgasPrice\x12!\n" +
	"\fsubmitted_at\x18\x05 \x01(\x03R\vsubmittedAt\"4\n" +
	"\x18OnBatchSubmittedResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\"\xde\x01\n" +
	"\x17OnBatchConfirmedRequest\x12\x19\n" +
	"\bbatch_id\x18\x01 \x01(\tR\abatchId\x12\x17\n" +
	"\atx_hash\x18\x02 \x01(\tR\x06txHash\x12!\n" +
	"\fblock_number\x18\x03 \x01(\x03R\vblockNumber\x12\x19\n" +
	"\bgas_used\x18\x04 \x01(\x03R\agasUsed\x12.\n" +
	"\x13effective_gas_price\x18\x05 \x01(\tR\x11effectiveGasPrice\x12!\n" +
	"\fconfirmed_at\x18\x06 \x01(\x03R\vconfirmedAt\"_\n" +
	"\x18OnBatchConfirmedResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12)\n" +
	"\x10trades_confirmed\x18\x02 \x01(\x05R\x0ftradesConfirmed\"\xaf\x01\n" +
	"\x14OnBatchFailedRequest\x12\x19\n" +
	"\bbatch_id\x18\x01 \x01(\tR\abatchId\x12\x1d\n" +
	"\n" +
	"error_code\x18\x02 \x01(\tR\terrorCode\x12#\n" +
	"\rerror_message\x18\x03 \x01(\tR\ferrorMessage\x12\x1b\n" +
	"\tcan_retry\x18\x04 \x01(\bR\bcanRetry\x12\x1b\n" +
	"\tfailed_at\x18\x05 \x01(\x03R\bfailedAt\"I\n" +
	"\x15OnBatchFailedResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x16\n" +
	"\x06action\x18\x02 \x01(\tR\x06action\"\x95\x01\n" +
	"\x18SettlementRequestMessage\x12:\n" +
	"\x05trade\x18\x01 \x01(\v2$.eidos.settlement.v1.SettlementTradeR\x05trade\x12\x1a\n" +
	"\bpriority\x18\x02 \x01(\x05R\bpriority\x12!\n" +
	"\frequested_at\x18\x03 \x01(\x03R\vrequestedAt\"Q\n" +
	"\x13BatchCreatedMessage\x12:\n" +
	"\x05batch\x18\x01 \x01(\v2$.eidos.settlement.v1.SettlementBatchR\x05batch\"\x89\x02\n" +
	"\x12BatchStatusMessage\x12\x19\n" +
	"\bbatch_id\x18\x01 \x01(\tR\abatchId\x124\n" +
	"\x06status\x18\x02 \x01(\x0e2\x1c.eidos.common.v1.BatchStatusR\x06status\x12E\n" +
	"\x0fprevious_status\x18\x03 \x01(\x0e2\x1c.eidos.common.v1.BatchStatusR\x0epreviousStatus\x12\x17\n" +
	"\atx_hash\x18\x04 \x01(\tR\x06txHash\x12#\n" +
	"\rerror_message\x18\x05 \x01(\tR\ferrorMessage\x12\x1d\n" +
	"\n" +
	"updated_at\x18\x06 \x01(\x03R\tupdatedAt2\xe4\f\n" +
	"\x11SettlementService\x12W\n" +
	"\bGetBatch\x12$.eidos.settlement.v1.GetBatchRequest\x1a%.eidos.settlement.v1.GetBatchResponse\x12`\n" +
	"\vListBatches\x12'.eidos.settlement.v1.ListBatchesRequest\x1a(.eidos.settlement.v1.ListBatchesResponse\x12r\n" +
	"\x11ListTradesInBatch\x12-.eidos.settlement.v1.ListTradesInBatchRequest\x1a..eidos.settlement.v1.ListTradesInBatchResponse\x12r\n" +
	"\x11TriggerSettlement\x12-.eidos.settlement.v1.TriggerSettlementRequest\x1a..eidos.settlement.v1.TriggerSettlementResponse\x12]\n" +
	"\n" +
	"RetryBatch\x12&.eidos.settlement.v1.RetryBatchRequest\x1a'.eidos.settlement.v1.RetryBatchResponse\x12]\n" +
	"\n" +
	"SplitBatch\x12&.eidos.settlement.v1.SplitBatchRequest\x1a'.eidos.settlement.v1.SplitBatchResponse\x12f\n" +
	"\rRollbackBatch\x12).eidos.settlement.v1.RollbackBatchRequest\x1a*.eidos.settlement.v1.RollbackBatchResponse\x12u\n" +
	"\x12GetTradeSettlement\x12..eidos.settlement.v1.GetTradeSettlementRequest\x1a/.eidos.settlement.v1.GetTradeSettlementResponse\x12r\n" +
	"\x11ListPendingTrades\x12-.eidos.settlement.v1.ListPendingTradesRequest\x1a..eidos.settlement.v1.ListPendingTradesResponse\x12u\n" +
	"\x12GetSettlementStats\x12..eidos.settlement.v1.GetSettlementStatsRequest\x1a/.eidos.settlement.v1.GetSettlementStatsResponse\x12o\n" +
	"\x10GetBatcherStatus\x12,.eidos.settlement.v1.GetBatcherStatusRequest\x1a-.eidos.settlement.v1.GetBatcherStatusResponse\x12i\n" +
	"\x0eOnTradeMatched\x12*.eidos.settlement.v1.OnTradeMatchedRequest\x1a+.eidos.settlement.v1.OnTradeMatchedResponse\x12o\n" +
	"\x10OnBatchSubmitted\x12,.eidos.settlement.v1.OnBatchSubmittedRequest\x1a-.eidos.settlement.v1.OnBatchSubmittedResponse\x12o\n" +
	"\x10OnBatchConfirmed\x12,.eidos.settlement.v1.OnBatchConfirmedRequest\x1a-.eidos.settlement.v1.OnBatchConfirmedResponse\x12f\n" +
	"\rOnBatchFailed\x12).eidos.settlement.v1.OnBatchFailedRequest\x1a*.eidos.settlement.v1.OnBatchFailedResponseBBZ@github.com/eidos-exchange/eidos/proto/settlement/v1;settlementv1b\x06proto3"

var (
	file_settlement_v1_settlement_proto_rawDescOnce sync.Once
	file_settlement_v1_settlement_proto_rawDescData []byte
)

func file_settlement_v1_settlement_proto_rawDescGZIP() []byte {
	file_settlement_v1_settlement_proto_rawDescOnce.Do(func() {
		file_settlement_v1_settlement_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_settlement_v1_settlement_proto_rawDesc), len(file_settlement_v1_settlement_proto_rawDesc)))
	})
	return file_settlement_v1_settlement_proto_rawDescData
}

var file_settlement_v1_settlement_proto_msgTypes = make([]protoimpl.MessageInfo, 38)
var file_settlement_v1_settlement_proto_goTypes = []any{
	(*SettlementBatch)(nil),            // 0: eidos.settlement.v1.SettlementBatch
	(*GetBatchRequest)(nil),            // 1: eidos.settlement.v1.GetBatchRequest
	(*GetBatchResponse)(nil),           // 2: eidos.settlement.v1.GetBatchResponse
	(*ListBatchesRequest)(nil),         // 3: eidos.settlement.v1.ListBatchesRequest
	(*ListBatchesResponse)(nil),        // 4: eidos.settlement.v1.ListBatchesResponse
	(*ListTradesInBatchRequest)(nil),   // 5: eidos.settlement.v1.ListTradesInBatchRequest
	(*ListTradesInBatchResponse)(nil),  // 6: eidos.settlement.v1.ListTradesInBatchResponse
	(*SettlementTrade)(nil),            // 7: eidos.settlement.v1.SettlementTrade
	(*TriggerSettlementRequest)(nil),   // 8: eidos.settlement.v1.TriggerSettlementRequest
	(*TriggerSettlementResponse)(nil),  // 9: eidos.settlement.v1.TriggerSettlementResponse
	(*RetryBatchRequest)(nil),          // 10: eidos.settlement.v1.RetryBatchRequest
	(*RetryBatchResponse)(nil),         // 11: eidos.settlement.v1.RetryBatchResponse
	(*SplitBatchRequest)(nil),          // 12: eidos.settlement.v1.SplitBatchRequest
	(*SplitBatchResponse)(nil),         // 13: eidos.settlement.v1.SplitBatchResponse
	(*RollbackBatchRequest)(nil),       // 14: eidos.settlement.v1.RollbackBatchRequest
	(*RollbackBatchResponse)(nil),      // 15: eidos.settlement.v1.RollbackBatchResponse
	(*GetTradeSettlementRequest)(nil),  // 16: eidos.settlement.v1.GetTradeSettlementRequest
	(*GetTradeSettlementResponse)(nil), // 17: eidos.settlement.v1.GetTradeSettlementResponse
	(*ListPendingTradesRequest)(nil),   // 18: eidos.settlement.v1.ListPendingTradesRequest
	(*ListPendingTradesResponse)(nil),  // 19: eidos.settlement.v1.ListPendingTradesResponse
	(*GetSettlementStatsRequest)(nil),  // 20: eidos.settlement.v1.GetSettlementStatsRequest
	(*GetSettlementStatsResponse)(nil), // 21: eidos.settlement.v1.GetSettlementStatsResponse
	(*MarketSettlementStats)(nil),      // 22: eidos.settlement.v1.MarketSettlementStats
	(*GetBatcherStatusRequest)(nil),    // 23: eidos.settlement.v1.GetBatcherStatusRequest
	(*GetBatcherStatusResponse)(nil),   // 24: eidos.settlement.v1.GetBatcherStatusResponse
	(*BatcherConfig)(nil),              // 25: eidos.settlement.v1.BatcherConfig
	(*ChainBatcherStatus)(nil),         // 26: eidos.settlement.v1.ChainBatcherStatus
	(*OnTradeMatchedRequest)(nil),      // 27: eidos.settlement.v1.OnTradeMatchedRequest
	(*OnTradeMatchedResponse)(nil),     // 28: eidos.settlement.v1.OnTradeMatchedResponse
	(*OnBatchSubmittedRequest)(nil),    // 29: eidos.settlement.v1.OnBatchSubmittedRequest
	(*OnBatchSubmittedResponse)(nil),   // 30: eidos.settlement.v1.OnBatchSubmittedResponse
	(*OnBatchConfirmedRequest)(nil),    // 31: eidos.settlement.v1.OnBatchConfirmedRequest
	(*OnBatchConfirmedResponse)(nil),   // 32: eidos.settlement.v1.OnBatchConfirmedResponse
	(*OnBatchFailedRequest)(nil),       // 33: eidos.settlement.v1.OnBatchFailedRequest
	(*OnBatchFailedResponse)(nil),      // 34: eidos.settlement.v1.OnBatchFailedResponse
	(*SettlementRequestMessage)(nil),   // 35: eidos.settlement.v1.SettlementRequestMessage
	(*BatchCreatedMessage)(nil),        // 36: eidos.settlement.v1.BatchCreatedMessage
	(*BatchStatusMessage)(nil),         // 37: eidos.settlement.v1.BatchStatusMessage
	(common.BatchStatus)(0),            // 38: eidos.common.v1.BatchStatus
	(*common.PaginationRequest)(nil),   // 39: eidos.common.v1.PaginationRequest
	(*common.PaginationResponse)(nil),  // 40: eidos.common.v1.PaginationResponse
	(common.OrderSide)(0),              // 41: eidos.common.v1.OrderSide
	(common.SettlementStatus)(0),       // 42: eidos.common.v1.SettlementStatus
}
var file_settlement_v1_settlement_proto_depIdxs = []int32{
	38, // 0: eidos.settlement.v1.SettlementBatch.status:type_name -> eidos.common.v1.BatchStatus
	0,  // 1: eidos.settlement.v1.GetBatchResponse.batch:type_name -> eidos.settlement.v1.SettlementBatch
	38, // 2: eidos.settlement.v1.ListBatchesRequest.status:type_name -> eidos.common.v1.BatchStatus
	39, // 3: eidos.settlement.v1.ListBatchesRequest.pagination:type_name -> eidos.common.v1.PaginationRequest
	0,  // 4: eidos.settlement.v1.ListBatchesResponse.batches:type_name -> eidos.settlement.v1.SettlementBatch
	40, // 5: eidos.settlement.v1.ListBatchesResponse.pagination:type_name -> eidos.common.v1.PaginationResponse
	39, // 6: eidos.settlement.v1.ListTradesInBatchRequest.pagination:type_name -> eidos.common.v1.PaginationRequest
	7,  // 7: eidos.settlement.v1.ListTradesInBatchResponse.trades:type_name -> eidos.settlement.v1.SettlementTrade
	40, // 8: eidos.settlement.v1.ListTradesInBatchResponse.pagination:type_name -> eidos.common.v1.PaginationResponse
	41, // 9: eidos.settlement.v1.SettlementTrade.taker_side:type_name -> eidos.common.v1.OrderSide
	42, // 10: eidos.settlement.v1.SettlementTrade.settlement_status:type_name -> eidos.common.v1.SettlementStatus
	7,  // 11: eidos.settlement.v1.GetTradeSettlementResponse.trade:type_name -> eidos.settlement.v1.SettlementTrade
	0,  // 12: eidos.settlement.v1.GetTradeSettlementResponse.batch:type_name -> eidos.settlement.v1.SettlementBatch
	39, // 13: eidos.settlement.v1.ListPendingTradesRequest.pagination:type_name -> eidos.common.v1.PaginationRequest
	7,  // 14: eidos.settlement.v1.ListPendingTradesResponse.trades:type_name -> eidos.settlement.v1.SettlementTrade
	40, // 15: eidos.settlement.v1.ListPendingTradesResponse.pagination:type_name -> eidos.common.v1.PaginationResponse
	22, // 16: eidos.settlement.v1.GetSettlementStatsResponse.market_stats:type_name -> eidos.settlement.v1.MarketSettlementStats
	25, // 17: eidos.settlement.v1.GetBatcherStatusResponse.config:type_name -> eidos.settlement.v1.BatcherConfig
	26, // 18: eidos.settlement.v1.GetBatcherStatusResponse.chain_status:type_name -> eidos.settlement.v1.ChainBatcherStatus
	7,  // 19: eidos.settlement.v1.OnTradeMatchedRequest.trade:type_name -> eidos.settlement.v1.SettlementTrade
	7,  // 20: eidos.settlement.v1.SettlementRequestMessage.trade:type_name -> eidos.settlement.v1.SettlementTrade
	0,  // 21: eidos.settlement.v1.BatchCreatedMessage.batch:type_name -> eidos.settlement.v1.SettlementBatch
	38, // 22: eidos.settlement.v1.BatchStatusMessage.status:type_name -> eidos.common.v1.BatchStatus
	38, // 23: eidos.settlement.v1.BatchStatusMessage.previous_status:type_name -> eidos.common.v1.BatchStatus
	1,  // 24: eidos.settlement.v1.SettlementService.GetBatch:input_type -> eidos.settlement.v1.GetBatchRequest
	3,  // 25: eidos.settlement.v1.SettlementService.ListBatches:input_type -> eidos.settlement.v1.ListBatchesRequest
	5,  // 26: eidos.settlement.v1.SettlementService.ListTradesInBatch:input_type -> eidos.settlement.v1.ListTradesInBatchRequest
	8,  // 27: eidos.settlement.v1.SettlementService.TriggerSettlement:input_type -> eidos.settlement.v1.TriggerSettlementRequest
	10, // 28: eidos.settlement.v1.SettlementService.RetryBatch:input_type -> eidos.settlement.v1.RetryBatchRequest
	12, // 29: eidos.settlement.v1.SettlementService.SplitBatch:input_type -> eidos.settlement.v1.SplitBatchRequest
	14, // 30: eidos.settlement.v1.SettlementService.RollbackBatch:input_type -> eidos.settlement.v1.RollbackBatchRequest
	16, // 31: eidos.settlement.v1.SettlementService.GetTradeSettlement:input_type -> eidos.settlement.v1.GetTradeSettlementRequest
	18, // 32: eidos.settlement.v1.SettlementService.ListPendingTrades:input_type -> eidos.settlement.v1.ListPendingTradesRequest
	20, // 33: eidos.settlement.v1.SettlementService.GetSettlementStats:input_type -> eidos.settlement.v1.GetSettlementStatsRequest
	23, // 34: eidos.settlement.v1.SettlementService.GetBatcherStatus:input_type -> eidos.settlement.v1.GetBatcherStatusRequest
	27, // 35: eidos.settlement.v1.SettlementService.OnTradeMatched:input_type -> eidos.settlement.v1.OnTradeMatchedRequest
	29, // 36: eidos.settlement.v1.SettlementService.OnBatchSubmitted:input_type -> eidos.settlement.v1.OnBatchSubmittedRequest
	31, // 37: eidos.settlement.v1.SettlementService.OnBatchConfirmed:input_type -> eidos.settlement.v1.OnBatchConfirmedRequest
	33, // 38: eidos.settlement.v1.SettlementService.OnBatchFailed:input_type -> eidos.settlement.v1.OnBatchFailedRequest
	2,  // 39: eidos.settlement.v1.SettlementService.GetBatch:output_type -> eidos.settlement.v1.GetBatchResponse
	4,  // 40: eidos.settlement.v1.SettlementService.ListBatches:output_type -> eidos.settlement.v1.ListBatchesResponse
	6,  // 41: eidos.settlement.v1.SettlementService.ListTradesInBatch:output_type -> eidos.settlement.v1.ListTradesInBatchResponse
	9,  // 42: eidos.settlement.v1.SettlementService.TriggerSettlement:output_type -> eidos.settlement.v1.TriggerSettlementResponse
	11, // 43: eidos.settlement.v1.SettlementService.RetryBatch:output_type -> eidos.settlement.v1.RetryBatchResponse
	13, // 44: eidos.settlement.v1.SettlementService.SplitBatch:output_type -> eidos.settlement.v1.SplitBatchResponse
	15, // 45: eidos.settlement.v1.SettlementService.RollbackBatch:output_type -> eidos.settlement.v1.RollbackBatchResponse
	17, // 46: eidos.settlement.v1.SettlementService.GetTradeSettlement:output_type -> eidos.settlement.v1.GetTradeSettlementResponse
	19, // 47: eidos.settlement.v1.SettlementService.ListPendingTrades:output_type -> eidos.settlement.v1.ListPendingTradesResponse
	21, // 48: eidos.settlement.v1.SettlementService.GetSettlementStats:output_type -> eidos.settlement.v1.GetSettlementStatsResponse
	24, // 49: eidos.settlement.v1.SettlementService.GetBatcherStatus:output_type -> eidos.settlement.v1.GetBatcherStatusResponse
	28, // 50: eidos.settlement.v1.SettlementService.OnTradeMatched:output_type -> eidos.settlement.v1.OnTradeMatchedResponse
	30, // 51: eidos.settlement.v1.SettlementService.OnBatchSubmitted:output_type -> eidos.settlement.v1.OnBatchSubmittedResponse
	32, // 52: eidos.settlement.v1.SettlementService.OnBatchConfirmed:output_type -> eidos.settlement.v1.OnBatchConfirmedResponse
	34, // 53: eidos.settlement.v1.SettlementService.OnBatchFailed:output_type -> eidos.settlement.v1.OnBatchFailedResponse
	39, // [39:54] is the sub-list for method output_type
	24, // [24:39] is the sub-list for method input_type
	24, // [24:24] is the sub-list for extension type_name
	24, // [24:24] is the sub-list for extension extendee
	0,  // [0:24] is the sub-list for field type_name
}

func init() { file_settlement_v1_settlement_proto_init() }
func file_settlement_v1_settlement_proto_init() {
	if File_settlement_v1_settlement_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_settlement_v1_settlement_proto_rawDesc), len(file_settlement_v1_settlement_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   38,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_settlement_v1_settlement_proto_goTypes,
		DependencyIndexes: file_settlement_v1_settlement_proto_depIdxs,
		MessageInfos:      file_settlement_v1_settlement_proto_msgTypes,
	}.Build()
	File_settlement_v1_settlement_proto = out.File
	file_settlement_v1_settlement_proto_goTypes = nil
	file_settlement_v1_settlement_proto_depIdxs = nil
}
